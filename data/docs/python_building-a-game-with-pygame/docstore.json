{"docstore/data": {"1676c315-33be-47be-b625-2a92507aca74": {"__data__": {"id_": "1676c315-33be-47be-b625-2a92507aca74", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5446c915-eddd-4a8d-91de-d4079b0fd99e", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "hash": "6f3d94d542419cf3c018e3a0830956412a2b888ce79def169e4d1a7887d7d2a7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c728857b-9b31-4150-ad17-4a19bd23c6e2", "node_type": "1", "metadata": {}, "hash": "4c77ba14ed7d7ab291852de984ddd84289703b6413155b0229040e28fef0c98f", "class_name": "RelatedNodeInfo"}}, "hash": "c382ef9cff2fee07d55395180394fbb2c5b2dbd29944d670ef03556c7d323d45", "text": "if\n\n__name__\n\n==\n\n\"__main__\"\n\nmain\n\nThis code looks a bit more complicated than it needs to be because in addition to drawing the ball to the screen, it also sets up a game loop. While basic 2D games appear to move objects around the screen, they usually actually simulate this effect by redrawing the entire screen many times per second. To account for this we need to run our logic in a while True: loop.\n\nWe start by importing PyGame and setting up some global variables: the size of our screen and the background color (black). We then define our Ball, setting up an object that knows where to find the image for the ball and how to get the default coordinates of where the image should be drawn.\n\nWe then set up PyGame by calling init() and starting the screen as well as a clock. The clock is necessary because each loop might take a different amount of time, based on how much logic needs to run to calculate the new screen. PyGame has built-in logic to calculate how much time elapses between calls to clock.tick() to draw frames faster or slower as necessary to keep the game experience smooth.\n\nWe start the game loop and call blit on our ball. Blitting refers to moving all of the pixels from our sprite file (the tennis ball) to our game environment. The flip() function updates our screen and the tick(60) call means that our game will redraw the screen around 60 times per second.\n\nIf you run this code, you should see the ball pop up in the top right pane, as shown below.\n\nMaking our tennis ball move with each frame\u200b\n\nAlthough PyGame has a lot of built-in logic for handling common game operations, you still need to get your hands dirty with calculating some of the basic movements. For every loop, we need to tell our game the new X and Y coordinates to draw the ball. As we want our ball to move at a constant speed, we'll move the X and Y coordinates each loop.\n\nAdd two methods to your Ball class: update and move, and add a speed attribute. The new code for your Ball class should look as follows.\n\nclass\n\nBall\n\ndef\n\n__init__\n\nself\n\nself\n\nimage\n\npygame\n\nimage\n\nload\n\n\"small_tennis.png\"\n\nself\n\nspeed\n\nself\n\nrect\n\nself\n\nimage\n\nget_rect\n\ndef\n\nupdate\n\nself\n\nself\n\nmove\n\ndef\n\nmove\n\nself\n\nself\n\nrect\n\nself\n\nrect\n\nmove\n\nself\n\nspeed\n\nNow modify your game loop to include a call to the new update() method. The loop should look as follows.\n\nwhile\n\nTrue\n\nscreen\n\nfill\n\nBACKGROUND\n\nscreen\n\nblit\n\nball\n\nimage\n\nball\n\nrect\n\nball\n\nupdate\n\npygame\n\ndisplay\n\nflip\n\nclock\n\ntick\n\n60\n\nThe (0, 1) tuple causes the ball to move its Y coordinate by 1 each loop and keep a constant X coordinate. This has the effect of making the ball drop slowly down the screen. Run your code again to check that this works.\n\nWhen the ball gets to the bottom of the screen, it'll just keep falling but that's OK for now. Let's see how we can add click detection.\n\nProcessing events: Detecting mouse clicks\u200b\n\nPyGame records all \"events\", including mouse clicks, and makes these available through pygame.event.get:(). We need to check what events happened in each game loop and see if any of them were important.\n\nIf the user clicks on an empty space, that will still be recorded but we will simply ignore it. If the user clicks on a falling ball, we want it to change direction.\n\nAt the start of the loop, right after the line that reads while True, add the following lines of code.\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nMOUSEBUTTONDOWN\n\nif\n\nball\n\nrect\n\ncollidepoint\n\npygame\n\nmouse\n\nget_pos\n\nball\n\nspeed\n\nWith this code, we loop through all events and check for left click (MOUSEBUTTONDOWN) events. If we find one, we check if the click happened on top of the ball (using collidepoint() which checks for overlapping coordinates), and in this case we reverse the direction of the ball (still no x-axis or horizontal movement, but we make the ball move negatively on the y-axis, which is up.)\n\nIf you run this code again, you should now be able to click on the ball (let it fall for a while first) and see it change direction until it goes off the top of the screen.", "start_char_idx": 0, "end_char_idx": 4074, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c728857b-9b31-4150-ad17-4a19bd23c6e2": {"__data__": {"id_": "c728857b-9b31-4150-ad17-4a19bd23c6e2", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5446c915-eddd-4a8d-91de-d4079b0fd99e", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "hash": "6f3d94d542419cf3c018e3a0830956412a2b888ce79def169e4d1a7887d7d2a7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1676c315-33be-47be-b625-2a92507aca74", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "hash": "c382ef9cff2fee07d55395180394fbb2c5b2dbd29944d670ef03556c7d323d45", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "85127576-061c-461e-91dd-43b639aaed4e", "node_type": "1", "metadata": {}, "hash": "661d27790fa464aa3199f0967be004bb1a14d73cd608ca9467dbfe786208ba76", "class_name": "RelatedNodeInfo"}}, "hash": "4c77ba14ed7d7ab291852de984ddd84289703b6413155b0229040e28fef0c98f", "text": "At the start of the loop, right after the line that reads while True, add the following lines of code.\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nMOUSEBUTTONDOWN\n\nif\n\nball\n\nrect\n\ncollidepoint\n\npygame\n\nmouse\n\nget_pos\n\nball\n\nspeed\n\nWith this code, we loop through all events and check for left click (MOUSEBUTTONDOWN) events. If we find one, we check if the click happened on top of the ball (using collidepoint() which checks for overlapping coordinates), and in this case we reverse the direction of the ball (still no x-axis or horizontal movement, but we make the ball move negatively on the y-axis, which is up.)\n\nIf you run this code again, you should now be able to click on the ball (let it fall for a while first) and see it change direction until it goes off the top of the screen.\n\nMaking the ball bounce off the edges and move randomly\u200b\n\nTo simulate juggling, we want the ball to bounce of the \"roof\" (top edge of the screen) and \"walls\" (left and right edge). If the ball touches the \"floor\" (bottom edge) we want to kill it and remove it from the game as a dropped ball.\n\nTo achieve this, we'll add logic to our update() method (this is why we kept it separate from our move() method before). Add two lines of code to update() to make it look as follows.\n\ndef\n\nupdate\n\nself\n\nif\n\nself\n\nrect\n\ntop\n\nself\n\nspeed\n\nself\n\nmove\n\nThis checks to see if the top of the ball is above the top of the screen. If it is, we set the speed back to (0, 1) (moving down).\n\nSo far, we have restricted the ball to moving vertically, but we can apply the same principles and move it horizontally or diagonally too. Let's also add some randomness into the mix so that it's less predictable (and harder for the player to press). The ball will randomly change its horizontal movement when it bounces off the ceiling and each time we throw it.\n\nImport the random module at the top of your file and use the random.randrange() function to specify the range of acceptable horizontal movement. Also modify the update() function to detect if the ball is falling off the left or right edges and reverse its horizontal movement in this case.\n\nFinally, modify the collision detection section to add randomness there too.\n\nYour full code should now look as follows.\n\nimport\n\npygame\n\nimport\n\nrandom\n\nWIDTH\n\n800\n\nHEIGHT\n\n600\n\nBACKGROUND\n\nclass\n\nBall\n\ndef\n\n__init__\n\nself\n\nself\n\nimage\n\npygame\n\nimage\n\nload\n\n\"small_tennis.png\"\n\nself\n\nspeed\n\nrandom\n\nuniform\n\nself\n\nrect\n\nself\n\nimage\n\nget_rect\n\ndef\n\nupdate\n\nself\n\nif\n\nself\n\nrect\n\ntop\n\nself\n\nspeed\n\nself\n\nspeed\n\nself\n\nspeed\n\nrandom\n\nuniform\n\nelif\n\nself\n\nrect\n\nleft\n\nor\n\nself\n\nrect\n\nright\n\nWIDTH\n\nself\n\nspeed\n\nself\n\nspeed\n\nself\n\nmove\n\ndef\n\nmove\n\nself\n\nself\n\nrect\n\nself\n\nrect\n\nmove\n\nself\n\nspeed\n\ndef\n\nmain\n\nclock\n\npygame\n\ntime\n\nClock\n\nball\n\nBall\n\npygame\n\ninit\n\nscreen\n\npygame\n\ndisplay\n\nset_mode\n\nWIDTH\n\nHEIGHT\n\nwhile\n\nTrue\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nMOUSEBUTTONDOWN\n\nif\n\nball\n\nrect\n\ncollidepoint\n\npygame\n\nmouse\n\nget_pos\n\nball\n\nspeed\n\nrandom\n\nuniform\n\nball\n\nspeed\n\nscreen\n\nfill\n\nBACKGROUND\n\nscreen\n\nblit\n\nball\n\nimage\n\nball\n\nrect\n\nball\n\nupdate\n\npygame\n\ndisplay\n\nflip\n\nclock\n\ntick\n\n60\n\nif\n\n__name__\n\n==\n\n\"__main__\"\n\nmain\n\nIf you run your code again, you should be able to juggle the ball around by clicking on it and watch it randomly bounce off the ceiling and walls.\n\nAdding more balls\u200b\n\nJuggling with one ball is no fun, so let's add some more. Because we used Object Oriented Programming (OOP), we can create more balls by instantiating more Ball() objects. We'll need to keep track of these so we'll add them to an array. For each iteration of the game loop, we'll need to update the position of each ball, so we'll need one more loop to account for this.\n\nWe also want to start keeping track of which of our balls is \"alive\" (that is, hasn't hit the ground), so add an attribute for this to the Ball class too, in the __init__ function.", "start_char_idx": 3262, "end_char_idx": 7180, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "85127576-061c-461e-91dd-43b639aaed4e": {"__data__": {"id_": "85127576-061c-461e-91dd-43b639aaed4e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5446c915-eddd-4a8d-91de-d4079b0fd99e", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "hash": "6f3d94d542419cf3c018e3a0830956412a2b888ce79def169e4d1a7887d7d2a7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c728857b-9b31-4150-ad17-4a19bd23c6e2", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}, "hash": "4c77ba14ed7d7ab291852de984ddd84289703b6413155b0229040e28fef0c98f", "class_name": "RelatedNodeInfo"}}, "hash": "661d27790fa464aa3199f0967be004bb1a14d73cd608ca9467dbfe786208ba76", "text": "Adding more balls\u200b\n\nJuggling with one ball is no fun, so let's add some more. Because we used Object Oriented Programming (OOP), we can create more balls by instantiating more Ball() objects. We'll need to keep track of these so we'll add them to an array. For each iteration of the game loop, we'll need to update the position of each ball, so we'll need one more loop to account for this.\n\nWe also want to start keeping track of which of our balls is \"alive\" (that is, hasn't hit the ground), so add an attribute for this to the Ball class too, in the __init__ function.\n\nself\n\nalive\n\nTrue\n\nIn the main() function, directly before the while True: line, add the following code.\n\nball1\n\nBall\n\nball2\n\nBall\n\nball3\n\nBall\n\nballs\n\nball1\n\nball2\n\nball3\n\nNow remove the ball=Ball(), ball.update() and screen.blit(...) lines and replace them with a loop that updates all of the balls and removes the dead ones (even though we haven't written the logic yet to stop the balls from ever being alive.)\n\nfor\n\nball\n\nin\n\nenumerate\n\nballs\n\nif\n\nball\n\nalive\n\nscreen\n\nblit\n\nball\n\nimage\n\nball\n\nrect\n\nball\n\nupdate\n\nif\n\nnot\n\nball\n\nalive\n\ndel\n\nballs\n\nYou'll also need to account for multiple balls in the the event detection loop. For each event, loop through all of the balls and check if the mouse click collided with any of them.\n\nAt this point, the full main() function should look as follows.\n\ndef\n\nmain\n\nclock\n\npygame\n\ntime\n\nClock\n\npygame\n\ninit\n\nscreen\n\npygame\n\ndisplay\n\nset_mode\n\nWIDTH\n\nHEIGHT\n\nball1\n\nBall\n\nball2\n\nBall\n\nball3\n\nBall\n\nballs\n\nball1\n\nball2\n\nball3\n\nwhile\n\nTrue\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nMOUSEBUTTONDOWN\n\nfor\n\nball\n\nin\n\nballs\n\nif\n\nball\n\nrect\n\ncollidepoint\n\npygame\n\nmouse\n\nget_pos\n\nball\n\nspeed\n\nrandom\n\nrandrange\n\nball\n\nspeed\n\nbreak\n\nscreen\n\nfill\n\nBACKGROUND\n\nfor\n\nball\n\nin\n\nenumerate\n\nballs\n\nif\n\nball\n\nalive\n\nscreen\n\nblit\n\nball\n\nimage\n\nball\n\nrect\n\nball\n\nupdate\n\nif\n\nnot\n\nball\n\nalive\n\ndel\n\nballs\n\npygame\n\ndisplay\n\nflip\n\nclock\n\ntick\n\n60\n\nTo kill balls when they fall through the floor, we can add another check to the update() function as follows.\n\nelif\n\nself\n\nrect\n\nbottom\n\nHEIGHT\n\nself\n\nalive\n\nFalse\n\nRun the code again and you should be able to juggle three balls. See how long you can keep them in the air.\n\nIf you want a harder version, add a counter to keep track of how many successful throws the player has achieved and add a new ball for every three successful throws.\n\nNow the game is to see how many balls you can juggle with. If it's too easy, modify the speeds and angles of the balls.\n\nMake it your own\u200b\n\nIf you followed along, you'll already have your own version of the repl to extend. If not, start from ours. Fork it from the embed below.\n\nWhere next?\u200b\n\nYou've learned how to make 2D games using PyGame. If you want to make more games but are stuck for ideas, check out PyGame's extensive collection of examples.\n\nYou could also extend the juggling game more. For example, make the balls accelerate as they fall, or increase the speed of all balls over time.\n\n< Previous: Building with Nix on Replit\n\nNext: Creating interactive Python plots with matplotlib >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nCreating a PyGame repl\n\nDisplaying the sprite using PyGame\n\nMaking our tennis ball move with each frame\n\nProcessing events: Detecting mouse clicks\n\nMaking the ball bounce off the edges and move randomly\n\nAdding more balls\n\nMake it your own\n\nWhere next?", "start_char_idx": 6608, "end_char_idx": 10020, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"5446c915-eddd-4a8d-91de-d4079b0fd99e": {"node_ids": ["1676c315-33be-47be-b625-2a92507aca74", "c728857b-9b31-4150-ad17-4a19bd23c6e2", "85127576-061c-461e-91dd-43b639aaed4e"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/building-a-game-with-pygame.html"}}}, "docstore/metadata": {"1676c315-33be-47be-b625-2a92507aca74": {"doc_hash": "c382ef9cff2fee07d55395180394fbb2c5b2dbd29944d670ef03556c7d323d45", "ref_doc_id": "5446c915-eddd-4a8d-91de-d4079b0fd99e"}, "c728857b-9b31-4150-ad17-4a19bd23c6e2": {"doc_hash": "4c77ba14ed7d7ab291852de984ddd84289703b6413155b0229040e28fef0c98f", "ref_doc_id": "5446c915-eddd-4a8d-91de-d4079b0fd99e"}, "85127576-061c-461e-91dd-43b639aaed4e": {"doc_hash": "661d27790fa464aa3199f0967be004bb1a14d73cd608ca9467dbfe786208ba76", "ref_doc_id": "5446c915-eddd-4a8d-91de-d4079b0fd99e"}}}