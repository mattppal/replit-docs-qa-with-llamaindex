{"docstore/data": {"3f083146-9c5a-4f90-8842-7048cdbb5c43": {"__data__": {"id_": "3f083146-9c5a-4f90-8842-7048cdbb5c43", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "hash": "cd93a8f24940a734544120e6092b0ce2c6aec19e24cc94171d2df54d9a27958b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "32899621-2f58-41d6-b398-46a0f13e2eca", "node_type": "1", "metadata": {}, "hash": "abdc218f3c4b713d57bd19a5c422ab3ef369e1783f98743cae41fe45a976192d", "class_name": "RelatedNodeInfo"}}, "hash": "8b5002187bb79b53e83cc797eb0c7b44bf46e845e419ec2bfc5e85e9e5f9e22e", "text": "10\n\n16\n\n100\n\nWe've got the geometry, or points, of the 3D objects. Now we need to create a material to cover them with. You can think of the material as the skin of the object. Add the following line to the script.js file:\n\nconst\n\nmaterial\n\nnew\n\nTHREE\n\nMeshBasicMaterial\n\ncolor\n\n0x00ff00\n\nThe MeshBasicMaterial is a simple material that covers the geometry with a solid color, in this case using the hexadecimal RGB code for pure green. You can also use a Texture to cover the geometry with a texture.\n\nThe next step is combining the geometries and the material to make a mesh. Add the following lines to the script.js file:\n\nconst\n\ncube\n\nnew\n\nTHREE\n\nMesh\n\nboxGeometry\n\nmaterial\n\nconst\n\ntorus\n\nnew\n\nTHREE\n\nMesh\n\ntorusGeometry\n\nmaterial\n\nThese meshes are what we'll add to the scene. We'll add the cube first, then the torus.\n\nscene\n\nadd\n\ncube\n\nscene\n\nadd\n\ntorus\n\nA camera determines what we see rendered, depending on where it is placed and where it is aimed. Add the following line to the script.js file:\n\nconst\n\ncamera\n\nnew\n\nTHREE\n\nPerspectiveCamera\n\n75\n\nwindow\n\ninnerWidth\n\nwindow\n\ninnerHeight\n\n0.1\n\n1000\n\ncamera\n\nposition\n\n25\n\nWe've got all the pieces we need to start rendering the scene. Now we just need to tell the renderer to draw the scene. Add the following line to the script.js file:\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\nNow try running the code, by pushing the Run button at the top of the Replit window. You should see your first scene, a green cube and torus:\n\nOur scene doesn't look very \"3D\" yet, but we'll get there soon.\n\nAnimating a scene\u200b\n\nAnimating a scene or moving the camera can create more of a 3D effect. Let's add a little animation to our scene by rotating the torus and cube. In the script.js file, replace renderer.render(scene, camera); with the following lines:\n\nfunction\n\nanimate\n\ntorus\n\nrotation\n\n+=\n\n0.01\n\ntorus\n\nrotation\n\n+=\n\n0.01\n\ncube\n\nrotation\n\n+=\n\n0.01\n\ncube\n\nrotation\n\n+=\n\n0.01\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\nrequestAnimationFrame\n\nanimate\n\nanimate\n\nThis creates a new function, animate(), that will be called on every frame. We rotate the torus and cube by 0.01 radians around the objects' x and y axes using the rotation property of each mesh. This is a handy method that saves us from calculating the rotation ourselves.\n\nAfter we rotate the objects, we call the renderer.render(scene, camera); method to draw the scene. This will cause the scene to be redrawn every frame, with the updated rotations.\n\nThe requestAnimationFrame function is a built-in browser API call that will fire the animate() function on the next frame. Each time animate() is called, requestAnimationFrame will call it again for the next frame. We call this function so that we can keep the animation running.\n\nTo kick off the animation for the first time, we call the animate() function ourselves. Thereafter, it will keep itself running.\n\nPress the \"Run\" button again and you should see the torus and cube rotating in the Replit window:\n\nThat looks a lot more 3D now!\n\nTry changing up the material color and see what happens. You can also define different materials for the torus and cube, to make them look different.\n\nAdding a model to the scene\u200b\n\nWe've created some basic 3D shapes programmatically. As you can imagine, building up a complex 3D world or character using this method would be very tedious. Fortunately, there are many 3D models available online, or perhaps you or a friend have played with making models in 3D animation applications like Blender. Three.js has a built-in loader to load these models into the scene.\n\nTo add the model loading functionality, we need to import it into our script. At the top of the script.js file, just below the existing import line, add the following:\n\nimport\n\nGLTFLoader\n\nfrom\n\n\"https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js\"\n\nThis gives us the GLTFLoader class, which we'll use to load the model. \"glTF\" stands for Graphics Language Transmission Format, and is widely used as a way to import and export 3D models from various 3D applications.", "start_char_idx": 0, "end_char_idx": 4042, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "32899621-2f58-41d6-b398-46a0f13e2eca": {"__data__": {"id_": "32899621-2f58-41d6-b398-46a0f13e2eca", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "hash": "cd93a8f24940a734544120e6092b0ce2c6aec19e24cc94171d2df54d9a27958b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3f083146-9c5a-4f90-8842-7048cdbb5c43", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "hash": "8b5002187bb79b53e83cc797eb0c7b44bf46e845e419ec2bfc5e85e9e5f9e22e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cf58c69f-d13c-47c8-9419-a9f735a2f90e", "node_type": "1", "metadata": {}, "hash": "81fa3b6ea3a21a5689bc3ada4bcea9f03316ea5d6e29095c68b7bfa1c458ece0", "class_name": "RelatedNodeInfo"}}, "hash": "abdc218f3c4b713d57bd19a5c422ab3ef369e1783f98743cae41fe45a976192d", "text": "As you can imagine, building up a complex 3D world or character using this method would be very tedious. Fortunately, there are many 3D models available online, or perhaps you or a friend have played with making models in 3D animation applications like Blender. Three.js has a built-in loader to load these models into the scene.\n\nTo add the model loading functionality, we need to import it into our script. At the top of the script.js file, just below the existing import line, add the following:\n\nimport\n\nGLTFLoader\n\nfrom\n\n\"https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js\"\n\nThis gives us the GLTFLoader class, which we'll use to load the model. \"glTF\" stands for Graphics Language Transmission Format, and is widely used as a way to import and export 3D models from various 3D applications. All we need to know is that we can import any model that is saved in this format into our three.js applications. If you search for \"free GLTF 3D models\" on the web, you'll find a lot of sites where creators upload their models. Many are free to use in your projects, and some you need to pay for. We'll look for some free ones to experiment with.\n\nLet's use this model of soda cans to start. Download the model, choosing the glTF format. We've also included the model here, so you can download it easily.\n\nAdd the model to your repl by dragging the folder into the \"Files\" panel on the left.\n\nWe'll need to remove or comment out the previous code that drew the cube and torus. Remove the lines that create the cube and torus geometries, materials, and meshes, as well as the animation code. You should have only the following lines remaining:\n\nimport\n\nas\n\nTHREE\n\nfrom\n\n\"https://cdn.skypack.dev/three@0.136.0\"\n\nimport\n\nGLTFLoader\n\nfrom\n\n\"https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js\"\n\nconst\n\nrenderer\n\nnew\n\nTHREE\n\nWebGLRenderer\n\nrenderer\n\nsetSize\n\nwindow\n\ninnerWidth\n\nwindow\n\ninnerHeight\n\ndocument\n\nbody\n\nappendChild\n\nrenderer\n\ndomElement\n\nconst\n\nscene\n\nnew\n\nTHREE\n\nScene\n\nconst\n\ncamera\n\nnew\n\nTHREE\n\nPerspectiveCamera\n\n75\n\nwindow\n\ninnerWidth\n\nwindow\n\ninnerHeight\n\n0.1\n\n1000\n\nWe need to add a few extra steps when loading a model. First, we need to create a new GLTFLoader object. Add the following line to the script.js file, just below the scene variable line:\n\nconst\n\nloader\n\nnew\n\nGLTFLoader\n\nconst\n\nfileName\n\n\"./soda_cans/scene.gltf\"\n\nlet\n\nmodel\n\nHere we've created a new loader object, and we've created a variable fileName with the path to the soda can model we want to load. We also have a variable model that will hold the loaded model, which we can manipulate later.\n\nNow for the actual loading code. We'll use the load method of the loader. Add the following lines to the script.js file, below the code we've just added:\n\nloader\n\nload\n\nfileName\n\nfunction\n\ngltf\n\nmodel\n\ngltf\n\nscene\n\nscene\n\nadd\n\nmodel\n\nundefined\n\nfunction\n\nconsole\n\nerror\n\nThe load method takes a few parameters:\n\nthe path to the model,\n\na callback function that will be called when the model is loaded,\n\na loading progress callback function, and\n\nan error callback function that will be called if there is an error loading the model.\n\nWe supply the undefined value for the progress callback, as we don't need it for this example, although it is a nice touch in a production application to give feedback to the user.\n\nThis alone won't always make a model visible on the screen. This is because a model may have no lighting, or the material may not be self-illuminating, or the model may be too large or too small to be visible from our default camera angle. To account for these possibilities, we'll include some helper functions to add lighting, adjust the model's position, and set the camera's position and angle.\n\nLet's start with adding some lighting. Add the following function to the script.js file:\n\nfunction\n\naddLight\n\nconst\n\nlight\n\nnew\n\nTHREE\n\nDirectionalLight\n\n0xffffff\n\nlight\n\nposition\n\nset\n\n0.5\n\n0.866\n\ncamera\n\nadd\n\nlight\n\nThis function will add a directional light with a white color to the scene, at a position slightly offset from the camera.", "start_char_idx": 3224, "end_char_idx": 7302, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf58c69f-d13c-47c8-9419-a9f735a2f90e": {"__data__": {"id_": "cf58c69f-d13c-47c8-9419-a9f735a2f90e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "hash": "cd93a8f24940a734544120e6092b0ce2c6aec19e24cc94171d2df54d9a27958b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "32899621-2f58-41d6-b398-46a0f13e2eca", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "hash": "abdc218f3c4b713d57bd19a5c422ab3ef369e1783f98743cae41fe45a976192d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e8f14d85-01e4-4268-8123-8165920f4911", "node_type": "1", "metadata": {}, "hash": "8ecd032cd6229687fd4d106d14cb18b8da30ab634397c69716f13d16dbda5134", "class_name": "RelatedNodeInfo"}}, "hash": "81fa3b6ea3a21a5689bc3ada4bcea9f03316ea5d6e29095c68b7bfa1c458ece0", "text": "This alone won't always make a model visible on the screen. This is because a model may have no lighting, or the material may not be self-illuminating, or the model may be too large or too small to be visible from our default camera angle. To account for these possibilities, we'll include some helper functions to add lighting, adjust the model's position, and set the camera's position and angle.\n\nLet's start with adding some lighting. Add the following function to the script.js file:\n\nfunction\n\naddLight\n\nconst\n\nlight\n\nnew\n\nTHREE\n\nDirectionalLight\n\n0xffffff\n\nlight\n\nposition\n\nset\n\n0.5\n\n0.866\n\ncamera\n\nadd\n\nlight\n\nThis function will add a directional light with a white color to the scene, at a position slightly offset from the camera. We attach the light to the camera so that it is always shining at whatever the camera is looking at.\n\nThe second helper function adjusts the positions of the model and the camera. Add the following function to the script.js file:\n\nfunction\n\nadjustModelAndCamera\n\nconst\n\nbox\n\nnew\n\nTHREE\n\nBox3\n\nsetFromObject\n\nmodel\n\nconst\n\nsize\n\nbox\n\ngetSize\n\nnew\n\nTHREE\n\nVector3\n\nlength\n\nconst\n\ncenter\n\nbox\n\ngetCenter\n\nnew\n\nTHREE\n\nVector3\n\nmodel\n\nposition\n\n+=\n\nmodel\n\nposition\n\ncenter\n\nmodel\n\nposition\n\n+=\n\nmodel\n\nposition\n\ncenter\n\nmodel\n\nposition\n\n+=\n\nmodel\n\nposition\n\ncenter\n\ncamera\n\nnear\n\nsize\n\n100\n\ncamera\n\nfar\n\nsize\n\n100\n\ncamera\n\nupdateProjectionMatrix\n\ncamera\n\nposition\n\ncopy\n\ncenter\n\ncamera\n\nposition\n\n+=\n\nsize\n\n0.2\n\ncamera\n\nposition\n\n+=\n\nsize\n\ncamera\n\nposition\n\n+=\n\nsize\n\n100\n\ncamera\n\nlookAt\n\ncenter\n\nThis function works by finding the bounding box of the model. The bounding box is the smallest box that can contain all the vertices of the model. We can then use this box to set the camera's near and far clipping planes, and also to adjust the position of the model and the camera. Clipping planes are used to determine what is visible in the camera's view. The near plane is the closest distance from the model that the camera can \"see\". The far plane is the furthest distance the camera can \"see\". This is used to determine what is visible in the camera's view. We use camera.updateProjectionMatrix to recalculate the camera's internal parameters.\n\nWe center the camera on the model, and then adjust the camera's position and angle to make sure the model is visible. We also point the camera to the center of the model using the lookAt method.\n\nNow let's call these new functions from the loader's callback function. We'll also render the scene after this setup. Update the loader.load callback function as follows:\n\nloader\n\nload\n\nfileName\n\nfunction\n\ngltf\n\nmodel\n\ngltf\n\nscene\n\nscene\n\nadd\n\nmodel\n\naddLight\n\nadjustModelAndCamera\n\nscene\n\nadd\n\ncamera\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\nundefined\n\nfunction\n\nconsole\n\nerror\n\nYou'll notice that, along with calls to the new function, we added in an extra line scene.add(camera). This is because we added the light to the camera to follow it around. A light is part of the scene, so we add the camera with the light attached to our scene.\n\nIf you run the code, you'll see that the model is now visible in the scene. However, it's a side-on view and a bit far away.\n\nAdding controls to the scene\u200b\n\nTo be able to see and inspect the model better, we can add some mouse controls to the scene so that we can zoom in or rotate the model. Three.js has a built-in OrbitControls class that we can use.\n\nFirst, add the following import code to the top of the script.js file, along with the other import statements:\n\nimport\n\nOrbitControls\n\nfrom\n\n\"https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js\"\n\nTo initiate the orbit controls, we'll need to add the following code to the script.js file, after the renderer and camera have been created:\n\nconst\n\ncontrols\n\nnew\n\nOrbitControls\n\ncamera\n\nrenderer\n\ndomElement\n\ncontrols\n\nscreenSpacePanning\n\ntrue\n\nThis creates a new controls object, and specifies what object it controls, the camera, and the DOM element the controls should listen to mouse inputs from. We also set the screenSpacePanning property to true, which allows us to pan the camera around the model.", "start_char_idx": 6562, "end_char_idx": 10660, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e8f14d85-01e4-4268-8123-8165920f4911": {"__data__": {"id_": "e8f14d85-01e4-4268-8123-8165920f4911", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "hash": "cd93a8f24940a734544120e6092b0ce2c6aec19e24cc94171d2df54d9a27958b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cf58c69f-d13c-47c8-9419-a9f735a2f90e", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}, "hash": "81fa3b6ea3a21a5689bc3ada4bcea9f03316ea5d6e29095c68b7bfa1c458ece0", "class_name": "RelatedNodeInfo"}}, "hash": "8ecd032cd6229687fd4d106d14cb18b8da30ab634397c69716f13d16dbda5134", "text": "Three.js has a built-in OrbitControls class that we can use.\n\nFirst, add the following import code to the top of the script.js file, along with the other import statements:\n\nimport\n\nOrbitControls\n\nfrom\n\n\"https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js\"\n\nTo initiate the orbit controls, we'll need to add the following code to the script.js file, after the renderer and camera have been created:\n\nconst\n\ncontrols\n\nnew\n\nOrbitControls\n\ncamera\n\nrenderer\n\ndomElement\n\ncontrols\n\nscreenSpacePanning\n\ntrue\n\nThis creates a new controls object, and specifies what object it controls, the camera, and the DOM element the controls should listen to mouse inputs from. We also set the screenSpacePanning property to true, which allows us to pan the camera around the model.\n\nThe controls change the view of the model as we move around it, so we need to add a modified animate function to redraw the scene each frame. Add the following code to the script.js file:\n\nfunction\n\nanimate\n\nrequestAnimationFrame\n\nanimate\n\ncontrols\n\nupdate\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\nNow replace the renderer.render(scene, camera); line in the loader.load callback function with the following call to the animate function to start it off;\n\nanimate\n\nSave and run the project. Now you can try using the mouse to rotate the model and zoom in and out.\n\nNext Steps\u200b\n\nNow that you know how to build a simple 3D scene using three.js, you might like to explore three.js and 3D rendering a little more. Head over to the three.js documentation to learn more about the tool and see other examples of what you can do with it. You can also download and try Blender to create your own 3D models.\n\n< Previous: 3D obstacle avoiding game with three.js\n\nNext: Classic Basic on Replit >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nCreating a new project in Replit\n\nImporting three.js to the project\n\nCreating a basic scene\n\nAnimating a scene\n\nAdding a model to the scene\n\nAdding controls to the scene\n\nNext Steps", "start_char_idx": 9872, "end_char_idx": 11868, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"9b3f3449-a4e7-4744-804d-7fa003a16fc6": {"node_ids": ["3f083146-9c5a-4f90-8842-7048cdbb5c43", "32899621-2f58-41d6-b398-46a0f13e2eca", "cf58c69f-d13c-47c8-9419-a9f735a2f90e", "e8f14d85-01e4-4268-8123-8165920f4911"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/3D-rendering-with-threejs.html"}}}, "docstore/metadata": {"3f083146-9c5a-4f90-8842-7048cdbb5c43": {"doc_hash": "8b5002187bb79b53e83cc797eb0c7b44bf46e845e419ec2bfc5e85e9e5f9e22e", "ref_doc_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6"}, "32899621-2f58-41d6-b398-46a0f13e2eca": {"doc_hash": "abdc218f3c4b713d57bd19a5c422ab3ef369e1783f98743cae41fe45a976192d", "ref_doc_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6"}, "cf58c69f-d13c-47c8-9419-a9f735a2f90e": {"doc_hash": "81fa3b6ea3a21a5689bc3ada4bcea9f03316ea5d6e29095c68b7bfa1c458ece0", "ref_doc_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6"}, "e8f14d85-01e4-4268-8123-8165920f4911": {"doc_hash": "8ecd032cd6229687fd4d106d14cb18b8da30ab634397c69716f13d16dbda5134", "ref_doc_id": "9b3f3449-a4e7-4744-804d-7fa003a16fc6"}}}