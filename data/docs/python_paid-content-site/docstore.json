{"docstore/data": {"1d3e88d5-347f-4273-b473-bcc41e20144c": {"__data__": {"id_": "1d3e88d5-347f-4273-b473-bcc41e20144c", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "43d97bd7-9240-4e25-a28e-4b05f12f3840", "node_type": "1", "metadata": {}, "hash": "5ff396d120a33c5eee33622d293aca25d5c6a180428783ff33433a21228f1ed8", "class_name": "RelatedNodeInfo"}}, "hash": "ecbf0449a9037ebf72ce091409ba6bb92a8cd5204ba370942fc50353b2f40ae2", "text": "app\n\nconfig\n\n\"SECRET_KEY\"\n\nos\n\nenviron\n\n\"SECRET_KEY\"\n\nOur secret key will be a long, random string. You can generate one in your repl's Python console with the following two lines of code:\n\nimport\n\nrandom\n\nstring\n\n''\n\njoin\n\nrandom\n\nSystemRandom\n\nchoice\n\nstring\n\nascii_uppercase\n\nstring\n\ndigits\n\nfor\n\nin\n\nrange\n\n20\n\nRather than putting this value directly into our code, we'll retrieve it from an environment variable. This will keep it out of source control and is good practice for sensitive data.\n\nIn your repl's Secrets tab, add a new key named SECRET_KEY and enter the random string you just generated as its value.\n\nOnce that's done, return to main.py and add the code below to initialize our Replit database:\n\n# Database setup\n\ndef\n\ndb_init\n\nif\n\n\"content\"\n\nnot\n\nin\n\ndb\n\nkeys\n\ndb\n\n\"content\"\n\nif\n\n\"orders\"\n\nnot\n\nin\n\ndb\n\nkeys\n\ndb\n\n\"orders\"\n\n# Create directories\n\nif\n\nnot\n\nos\n\npath\n\nexists\n\n\"static\"\n\nos\n\nmkdir\n\n\"static\"\n\nif\n\nnot\n\nos\n\npath\n\nexists\n\n\"content\"\n\nos\n\nmkdir\n\n\"content\"\n\ndb_init\n\nReplit's Database can be thought of and used as one big Python dictionary that we can access with db. Any values we store in db will persist between repl restarts.\n\nWe've written a function to initialize the database as we may want to do it again if we need to refresh our data during testing. Whenever we initialize our database, we will also create the content and static directories, which will contain user-uploaded files.\n\nNext we need to create our UserStore (a secondary database keyed by username), and list of admins:\n\nusers\n\nweb\n\nUserStore\n\nADMINS\n\n\"YOUR-REPLIT-USERNAME-HERE\"\n\nMake sure to replace the contents of the ADMINS list with your Replit username.\n\nFinally, let's make our root page. Add the following code, and then run your repl.\n\n# Main app\n\n@app\n\nroute\n\n\"/\"\n\n@web\n\nauthenticated\n\ndef\n\nindex\n\nreturn\n\nf\"Hello\n\nweb\n\nauth\n\nname\n\nweb\n\nrun\n\napp\n\nBecause we've added the @web.authenticated function decorator to our index page, it will only be available to logged-in users. You should see this now, as your app will show a login button. Click on that button, and authorize your application to use Replit authentication in the window that pops up.\n\nHaving done that, you should now see the greeting we implemented above. If you send your repl to a friend, they will also be able to log in and see their Replit username on the greeting message.\n\nContent upload and other admin functionality\u200b\n\nBefore we do anything else with our site, we need to have some PDFs to sell. While we could manually upload our PDFs to our repl and write code to add each one to the database, it will make our site more user-friendly if we include an upload form for this purpose.\n\nThis upload form should only be accessible by admins, so we can enforce some level of quality control. We'll also create a route that allows admins to refresh the application database.\n\nAccess control\u200b\n\nAdd the following functions to main.py, just below the line where you've assigned ADMINS:\n\n# Helper functions\n\ndef\n\nis_admin\n\nusername\n\nreturn\n\nusername\n\nin\n\nADMINS\n\n# Auth decorators\n\ndef\n\nadmin_only\n\n@wraps\n\ndef\n\ndecorated_function\n\nargs\n\n**\n\nkwargs\n\nif\n\nnot\n\nis_admin\n\nweb\n\nauth\n\nname\n\nflash\n\n\"Permission denied.\"\n\n\"warning\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nargs\n\n**\n\nkwargs\n\nreturn\n\ndecorated_function\n\nThe code in the second function may look a bit strange if you haven't written your own decorators before. Here's how it works: admin_only is the name of our decorator. You can think of decorators as functions that take other functions as arguments. (The two code snippets below are for illustration and not part of our program.) Therefore, if we write the following:\n\n@admin_only\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_function\n\nit will be roughly equivalent to:\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_only\n\nadmin_function\n\nSo whenever admin_function gets called, the code we've defined in decorated_function will execute before anything we define in admin_function. This means we don't have to include an if not is_admin check in every piece of admin functionality. As per the code, if a non-admin attempts to access restricted functionality, our app will flash a warning message and redirect them to the home page.", "start_char_idx": 0, "end_char_idx": 4232, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "43d97bd7-9240-4e25-a28e-4b05f12f3840": {"__data__": {"id_": "43d97bd7-9240-4e25-a28e-4b05f12f3840", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1d3e88d5-347f-4273-b473-bcc41e20144c", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "ecbf0449a9037ebf72ce091409ba6bb92a8cd5204ba370942fc50353b2f40ae2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3e9cf369-e3af-42d5-8156-043f5ae6e227", "node_type": "1", "metadata": {}, "hash": "1fa325bae929a97f4c01c8ca1911ab1b68f51266f9357a4361998a54ed7a98e3", "class_name": "RelatedNodeInfo"}}, "hash": "5ff396d120a33c5eee33622d293aca25d5c6a180428783ff33433a21228f1ed8", "text": "Here's how it works: admin_only is the name of our decorator. You can think of decorators as functions that take other functions as arguments. (The two code snippets below are for illustration and not part of our program.) Therefore, if we write the following:\n\n@admin_only\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_function\n\nit will be roughly equivalent to:\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_only\n\nadmin_function\n\nSo whenever admin_function gets called, the code we've defined in decorated_function will execute before anything we define in admin_function. This means we don't have to include an if not is_admin check in every piece of admin functionality. As per the code, if a non-admin attempts to access restricted functionality, our app will flash a warning message and redirect them to the home page.\n\nNow we can create the following admin routes below the definition of the index function:\n\n# Admin functionality\n\n@app\n\nroute\n\n'/admin/content-create'\n\nmethods\n\n\"GET\"\n\n\"POST\"\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\ncontent_create\n\npass\n\n@app\n\nroute\n\n'/admin/db-flush'\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\nflush_db\n\npass\n\nNote that both of these functions are protected with the @web.authenticated and @admin_only decorators, restricting their use to logged-in admins.\n\nThe first function will let our admins create content, and the second will allow us to flush the database. While the second function will be useful during development, it's not something we'd want to use in a finished application, as our database will contain records of user payments.\n\nContent creation form\u200b\n\nBefore we can fill in the code for content creation, we need to create the web form our admins will use. As the form creation code will include a lot of information and functionality and require several special imports, we're going to put it in its own file so we can keep a navigable codebase. In your repl's files pane, create forms.py.\n\nEnter the following import statements at the top of forms.py:\n\nfrom\n\nflask_wtf\n\nimport\n\nFlaskForm\n\nfrom\n\nflask_wtf\n\nfile\n\nimport\n\nFileField\n\nFileRequired\n\nFileAllowed\n\nfrom\n\nwtforms\n\nimport\n\nStringField\n\nTextAreaField\n\nSubmitField\n\nFloatField\n\nValidationError\n\nfrom\n\nwtforms\n\nvalidators\n\nimport\n\nInputRequired\n\nNumberRange\n\nLength\n\nfrom\n\nreplit\n\nimport\n\ndb\n\nHere we're importing from WTForms, an extensive library for building web forms, and Flask WTF, a library which bridges WTForms and Flask. We're also importing our Replit database, which we'll need for uniqueness validations.\n\nThe structure of our forms is dictated by the structure of our database. In our db_init function, we defined two dictionaries, \"content\" and \"orders\". The former will contain entries for each of the PDFs we have for sale. These entries will contain the PDF's filename as well as general metadata. Thus, our \"content\" data structure will look something like this:\n\n\"content\"\n\n\"ID\"\n\n\"name\"\n\n\"NAME\"\n\n\"description\"\n\n\"DESCRIPTION\"\n\n\"file\"\n\n\"PDF_FILENAME\"\n\n\"preview_image\"\n\n\"IMAGE_FILENAME\"\n\n\"price\"\n\nThe ID value will be the content's name, all-lowercase, with spaces replaced by hyphens, so we can use it in our app's URLs. Let's create a function that turns names into IDs, in forms.py, just below our imports:\n\ndef\n\nname_to_id\n\nname\n\nreturn\n\nname\n\nlower\n\nreplace\n\n\" \"\n\n\"-\"\n\nNow we can create our form. With Flask WTF, we model a form as a class inheriting from FlaskForm. This class takes in the value of Flask's request.form and applies validations to the fields therein. Add the following class definition to the bottom of forms.py:\n\nclass\n\nContentCreateForm\n\nFlaskForm\n\nname\n\nStringField\n\n\"Title\"\n\nvalidators\n\nInputRequired\n\nLength\n\ndescription\n\nTextAreaField\n\n\"Description\"\n\nvalidators\n\nInputRequired\n\nfile\n\nFileField\n\n\"PDF file\"\n\nvalidators\n\nFileRequired\n\nFileAllowed\n\n'pdf'\n\n\"PDFs only.\"\n\nimage\n\nFileField\n\n\"Preview image\"\n\nvalidators\n\nFileRequired\n\nFileAllowed\n\n'jpg'\n\n'jpeg'\n\n'png'\n\n'svg'\n\n\"Images only.\"\n\nprice\n\nFloatField\n\n\"Price in USD (0 = free)\"\n\nvalidators\n\nInputRequired\n\nNumberRange\n\nsubmit\n\nSubmitField\n\n\"Create content\"\n\ndef\n\nvalidate_name\n\nform\n\nfield\n\nif\n\nname_to_id\n\nfield\n\ndata\n\nin\n\ndb\n\n\"content\"\n\nkeys\n\nraise\n\nValidationError\n\n\"Content name already taken.\"", "start_char_idx": 3396, "end_char_idx": 7617, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3e9cf369-e3af-42d5-8156-043f5ae6e227": {"__data__": {"id_": "3e9cf369-e3af-42d5-8156-043f5ae6e227", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "43d97bd7-9240-4e25-a28e-4b05f12f3840", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "5ff396d120a33c5eee33622d293aca25d5c6a180428783ff33433a21228f1ed8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "63e75bd2-a212-4fe8-ab04-d70c4ec96ad2", "node_type": "1", "metadata": {}, "hash": "5238289d2075a23935d7b21ef76fb59be27332cf0b212dbae6e2528d79df0942", "class_name": "RelatedNodeInfo"}}, "hash": "1fa325bae929a97f4c01c8ca1911ab1b68f51266f9357a4361998a54ed7a98e3", "text": "This class takes in the value of Flask's request.form and applies validations to the fields therein. Add the following class definition to the bottom of forms.py:\n\nclass\n\nContentCreateForm\n\nFlaskForm\n\nname\n\nStringField\n\n\"Title\"\n\nvalidators\n\nInputRequired\n\nLength\n\ndescription\n\nTextAreaField\n\n\"Description\"\n\nvalidators\n\nInputRequired\n\nfile\n\nFileField\n\n\"PDF file\"\n\nvalidators\n\nFileRequired\n\nFileAllowed\n\n'pdf'\n\n\"PDFs only.\"\n\nimage\n\nFileField\n\n\"Preview image\"\n\nvalidators\n\nFileRequired\n\nFileAllowed\n\n'jpg'\n\n'jpeg'\n\n'png'\n\n'svg'\n\n\"Images only.\"\n\nprice\n\nFloatField\n\n\"Price in USD (0 = free)\"\n\nvalidators\n\nInputRequired\n\nNumberRange\n\nsubmit\n\nSubmitField\n\n\"Create content\"\n\ndef\n\nvalidate_name\n\nform\n\nfield\n\nif\n\nname_to_id\n\nfield\n\ndata\n\nin\n\ndb\n\n\"content\"\n\nkeys\n\nraise\n\nValidationError\n\n\"Content name already taken.\"\n\nWhen admins create content, they'll specify a name, a description, and a price, as well as upload both the PDF and a preview image. We've used WTForm's validators to restrict the file types that can be uploaded for each. Should we decide to branch out from selling PDFs in the future, we can add additional file extensions to the file field's FileAllowed validator. We could also make individual fields optional by removing their InputRequired() or FileRequired() validators.\n\nThe final part of our form is a custom validator to reject new PDFs with IDs that match existing PDFs. Because we're validating on ID rather than name, admins won't be able to create PDFs with the same name but different capitalization (e.g. \"Sherlock Holmes\" and \"SHERLOCK HOLMES\").\n\nWe've finished creating our form class. Now we can return to main.py and import the class with the following import statement, which you can add just below the other imports at the top of the file.\n\nfrom\n\nforms\n\nimport\n\nname_to_id\n\nContentCreateForm\n\nNote that we've also imported name_to_id, which we'll use when populating the database.\n\nAdmin routes\u200b\n\nWe can now use our form to implement our content creation route. Populate the content_create function with this code:\n\n# Admin functionality\n\n@app\n\nroute\n\n'/admin/content-create'\n\nmethods\n\n\"GET\"\n\n\"POST\"\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\ncontent_create\n\nform\n\nContentCreateForm\n\nif\n\nrequest\n\nmethod\n\n==\n\n\"POST\"\n\nand\n\nform\n\nvalidate\n\ncontent_name\n\nform\n\nname\n\ndata\n\ncontent_id\n\nname_to_id\n\ncontent_name\n\ncontent_price\n\nform\n\nprice\n\ndata\n\ncontent_file\n\nform\n\nfile\n\ndata\n\ncontent_filename\n\nsecure_filename\n\ncontent_file\n\nfilename\n\ncontent_file\n\nsave\n\nos\n\npath\n\njoin\n\n'content'\n\ncontent_filename\n\nimage_file\n\nform\n\nimage\n\ndata\n\nimage_filename\n\nsecure_filename\n\nimage_file\n\nfilename\n\nimage_file\n\nsave\n\nos\n\npath\n\njoin\n\n'static'\n\nimage_filename\n\ncontent_paywalled\n\ncontent_price\n\n# Construct content dictionary\n\ndb\n\n\"content\"\n\ncontent_id\n\n\"name\"\n\ncontent_name\n\n\"description\"\n\nform\n\ndescription\n\ndata\n\n\"filename\"\n\ncontent_filename\n\n\"preview_image\"\n\nimage_filename\n\n\"paywalled\"\n\ncontent_paywalled\n\n\"price\"\n\ncontent_price\n\nflash\n\n\"Content created!\"\n\nreturn\n\nredirect\n\nurl_for\n\n'content'\n\ncontent_id\n\ncontent_id\n\nreturn\n\nrender_template\n\n\"admin/content-create.html\"\n\nform\n\nform\n\n**\n\ncontext\n\nFirst, we create an instance of ContentCreateForm. This will automatically use the values in request.form, including the uploaded files. We then check whether the current request is an HTTP POST, and we call validate() on the form. Behind the scenes, this method will run all of our field validators, and return error messages to the user for fields that fail validation. It will only return True once all fields validate.\n\nOnce we know we've got valid form input, we can save its data to our database. We construct our content's ID using the helper function from forms.py, store our content's price value, and then save our PDF and image files to the content and static directories. Saving images to static will allow Flask to serve them without us writing additional code. We'll need custom code for PDFs, however, as we need to ensure they're only accessible to paying customers.\n\nWe use the variable content_paywalled to determine whether this PDF should be available for free or behind a paywall.\n\nFinally, we save our content's details to the database and redirect the creator to the content page, which we'll build in the next section.\n\nAt the bottom of the function, we render our content-create page and tell it which form to use.", "start_char_idx": 6810, "end_char_idx": 11161, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "63e75bd2-a212-4fe8-ab04-d70c4ec96ad2": {"__data__": {"id_": "63e75bd2-a212-4fe8-ab04-d70c4ec96ad2", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3e9cf369-e3af-42d5-8156-043f5ae6e227", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "1fa325bae929a97f4c01c8ca1911ab1b68f51266f9357a4361998a54ed7a98e3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3bfeeb72-76d9-479c-af40-03e6a69ce4bf", "node_type": "1", "metadata": {}, "hash": "7179f817db650b5bd7b2d2ae58d76de831794393ff36c4a8acc340c7cbf4fbb5", "class_name": "RelatedNodeInfo"}}, "hash": "5238289d2075a23935d7b21ef76fb59be27332cf0b212dbae6e2528d79df0942", "text": "It will only return True once all fields validate.\n\nOnce we know we've got valid form input, we can save its data to our database. We construct our content's ID using the helper function from forms.py, store our content's price value, and then save our PDF and image files to the content and static directories. Saving images to static will allow Flask to serve them without us writing additional code. We'll need custom code for PDFs, however, as we need to ensure they're only accessible to paying customers.\n\nWe use the variable content_paywalled to determine whether this PDF should be available for free or behind a paywall.\n\nFinally, we save our content's details to the database and redirect the creator to the content page, which we'll build in the next section.\n\nAt the bottom of the function, we render our content-create page and tell it which form to use. This will happen regardless of whether the initiating request was a GET or a POST. We'll create the template and define the context function when we build the application front-end.\n\nNext, we need to create our database flushing functionality. Populate the flush_db function with the following code:\n\n@app\n\nroute\n\n'/admin/db-flush'\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\nflush_db\n\n# clear db\n\ndel\n\ndb\n\n\"content\"\n\ndel\n\ndb\n\n\"orders\"\n\n# clear users\n\nfor\n\nuser\n\nin\n\nusers\n\nitems\n\nuser\n\n\"content_library\"\n\n# delete content and images\n\nshutil\n\nrmtree\n\n\"content\"\n\nshutil\n\nrmtree\n\n\"static\"\n\n# reinit\n\ndb_init\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nAfter deleting all database content and uploaded files, we call db_init() to start afresh. Keep in mind that this function should not be used if you're storing real user data unless you've made a backup.\n\nContent viewing and paywalls\u200b\n\nNow that our site admins can upload PDFs, we need a way for users to view them. We'll start by creating another helper function, just below the definition of is_admin:\n\ndef\n\nowns_content\n\nusername\n\ncontent_id\n\nif\n\n\"content_library\"\n\nin\n\nusers\n\nusername\n\nkeys\n\nand\n\nusers\n\nusername\n\n\"content_library\"\n\nis\n\nnot\n\nNone\n\nreturn\n\ncontent_id\n\nin\n\nusers\n\nusername\n\n\"content_library\"\n\nWe have to do several checks on our user's content_library, as it can be in a few different states \u2013 the key might not exist, or it might be set to None, or it might be a list. We'll use this function to determine which content has been purchased by a given user and thus avoid writing all these checks again.\n\nNow we need to create our application's content-viewing routes. We'll start by rewriting the / route so that it renders a template rather than a greeting string. This page will contain a list of PDFs. Change the code in index to the following:\n\n# Main app\n\n@app\n\nroute\n\n\"/\"\n\n@web\n\nauthenticated\n\ndef\n\nindex\n\nreturn\n\nrender_template\n\n\"index.html\"\n\n**\n\ncontext\n\nThen we'll write a route that displays individual PDF metadata, by adding this function just below the definition of index:\n\n@app\n\nroute\n\n\"/content/<content_id>\"\n\n@web\n\nauthenticated\n\ndef\n\ncontent\n\ncontent_id\n\nreturn\n\nrender_template\n\n\"content.html\"\n\ncontent_id\n\ncontent_id\n\n**\n\ncontext\n\nThe content_id value will be the same ID that we're using in our database. This page will contain the content's name, preview image, description, and either a download link, or a purchase link, depending on whether the PDF is paywalled, and whether the current user has purchased it.\n\nLastly, we need a route that handles downloading actual PDFs. Add the following code just below the content function definition:\n\n@app\n\nroute\n\n\"/content-file/<content_id>\"\n\n@web\n\nauthenticated\n\ndef\n\ncontent_file\n\ncontent_id\n\ncontent\n\ndb\n\n\"content\"\n\ncontent_id\n\nif\n\nnot\n\ncontent\n\n\"paywalled\"\n\nor\n\nowns_content\n\nweb\n\nauth\n\nname\n\ncontent_id\n\nreturn\n\nsend_from_directory\n\n\"content\"\n\npath\n\ncontent\n\n\"filename\"\n\nelse\n\nreturn\n\n\"Access denied.\"\n\nIf the current user owns this PDF, or it's not paywalled, we use Flask's send_from_directory to allow them to download it. Otherwise, we return an error message.\n\nCreating the application frontend\u200b\n\nWe have most of our application back-end, so now let's create the front-end. We'll do this using HTML and Jinja, Flask's front-end templating language.", "start_char_idx": 10294, "end_char_idx": 14445, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3bfeeb72-76d9-479c-af40-03e6a69ce4bf": {"__data__": {"id_": "3bfeeb72-76d9-479c-af40-03e6a69ce4bf", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "63e75bd2-a212-4fe8-ab04-d70c4ec96ad2", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "5238289d2075a23935d7b21ef76fb59be27332cf0b212dbae6e2528d79df0942", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c9ce47ad-1d4a-4d24-b1b6-9b86ee377393", "node_type": "1", "metadata": {}, "hash": "7f8bddafb9c916df8af05838ff59865ac250c2da437c016b6c8f42dcbb06965a", "class_name": "RelatedNodeInfo"}}, "hash": "7179f817db650b5bd7b2d2ae58d76de831794393ff36c4a8acc340c7cbf4fbb5", "text": "Lastly, we need a route that handles downloading actual PDFs. Add the following code just below the content function definition:\n\n@app\n\nroute\n\n\"/content-file/<content_id>\"\n\n@web\n\nauthenticated\n\ndef\n\ncontent_file\n\ncontent_id\n\ncontent\n\ndb\n\n\"content\"\n\ncontent_id\n\nif\n\nnot\n\ncontent\n\n\"paywalled\"\n\nor\n\nowns_content\n\nweb\n\nauth\n\nname\n\ncontent_id\n\nreturn\n\nsend_from_directory\n\n\"content\"\n\npath\n\ncontent\n\n\"filename\"\n\nelse\n\nreturn\n\n\"Access denied.\"\n\nIf the current user owns this PDF, or it's not paywalled, we use Flask's send_from_directory to allow them to download it. Otherwise, we return an error message.\n\nCreating the application frontend\u200b\n\nWe have most of our application back-end, so now let's create the front-end. We'll do this using HTML and Jinja, Flask's front-end templating language.\n\nFirst, let's create the following HTML files in a new directory called templates:\n\ntemplates/\n\n|__ admin/\n\n|     |__  content-create.html\n\n|__  _macros.html\n\n|__  content.html\n\n|__  index.html\n\n|__  layout.html\n\nOnce you've created these files, let's populate them, starting with templates/layout.html:\n\n<!\n\nDOCTYPE\n\nhtml\n\nhtml\n\nhead\n\ntitle\n\nBooks and Manuscripts\n\n</\n\ntitle\n\n</\n\nhead\n\nbody\n\n{% with messages = get_flashed_messages() %} {% if messages %}\n\nul\n\nclass\n\nflashes\n\n{% for message in messages %}\n\nli\n\n{{ message }}\n\n</\n\nli\n\n{% endfor %}\n\n</\n\nul\n\n{% endif %} {% endwith %} {% if name != None %}\n\nLogged in as {{ username }}\n\n</\n\n{% endif %} {% block body %}{% endblock %}\n\n</\n\nbody\n\n</\n\nhtml\n\nWe'll use this file as the base of all our pages, so we don't need to repeat the same HTML. It contains features we want on every page, such as flashed messages, and an indication of who's currently logged in. All subsequent pages will inject content into the body block:\n\n{% block body %}{% endblock %}\n\nNext, we need to populate another helper file, templates/_macros.html:\n\n{% macro render_field(field) %}\n\ndt\n\n{{ field.label }}\n\n</\n\ndt\n\ndd\n\n{{ field(**kwargs)|safe }} {% if field.errors %}\n\nul\n\nclass\n\nerrors\n\n{% for error in field.errors %}\n\nli\n\n{{ error }}\n\n</\n\nli\n\n{% endfor %}\n\n</\n\nul\n\n{% endif %}\n\n</\n\ndd\n\n{% endmacro %}\n\nThis file defines the Jinja macro render_field, which we'll use to provide our form fields with error-handling, provided by WTForms.\n\nWe'll use this macro in templates/admin/content-create.html, which we'll populate with the following code:\n\n{% extends \"layout.html\" %} {% block body %} {% from \"_macros.html\" import\n\nrender_field %}\n\nh1\n\nUpload content item\n\n</\n\nh1\n\nform\n\naction\n\n/admin/content-create\n\nmethod\n\npost\n\nenctype\n\nmultipart/form-data\n\n{{ render_field(form.name) }} {{ render_field(form.description) }} {{\n\nrender_field(form.file) }} {{ render_field(form.image) }} {{\n\nrender_field(form.price) }} {{ form.csrf_token }} {{ form.submit }}\n\n</\n\nform\n\n{% endblock %}\n\nHere, {% extends \"layout.html\" %} tells our templating engine to use layout.html as a base template, and {% block body %} ... {% endblock %} defines the code to place inside layout.html's body block.\n\nOur render_function macro will be used to show our different form fields \u2013 some of these will be text input fields, while others will be file upload fields. Our form also has a hidden field specified by {{ form.csrf_token }}. This is a security feature WTForms provides to prevent cross-site request forgery vulnerabilities.\n\nLet's define our home page now, with a list of content items.", "start_char_idx": 13657, "end_char_idx": 17045, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c9ce47ad-1d4a-4d24-b1b6-9b86ee377393": {"__data__": {"id_": "c9ce47ad-1d4a-4d24-b1b6-9b86ee377393", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3bfeeb72-76d9-479c-af40-03e6a69ce4bf", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "7179f817db650b5bd7b2d2ae58d76de831794393ff36c4a8acc340c7cbf4fbb5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "85b252cd-d9a7-45b1-948c-ce2fbb377345", "node_type": "1", "metadata": {}, "hash": "26554ecba1da5d636bf29a9fd31bfab81cfaf943caaf21ba99a17fa21f02811b", "class_name": "RelatedNodeInfo"}}, "hash": "7f8bddafb9c916df8af05838ff59865ac250c2da437c016b6c8f42dcbb06965a", "text": "Our render_function macro will be used to show our different form fields \u2013 some of these will be text input fields, while others will be file upload fields. Our form also has a hidden field specified by {{ form.csrf_token }}. This is a security feature WTForms provides to prevent cross-site request forgery vulnerabilities.\n\nLet's define our home page now, with a list of content items. Add the following code to templates/index.html:\n\n{% extends \"layout.html\" %} {% block body %}\n\nh1\n\nMarketplace\n\n</\n\nh1\n\nul\n\n{% for id, content in content.items() %}\n\nli\n\nhref\n\n/content/{{ id }}\n\n{{ content.name }}\n\n</\n\n{% if content.paywalled %} {% if id in my_library %} (PURCHASED) {% else %}\n\n({{ \"${:,.2f}\".format(content.price) }}) {% endif %} {% endif %}\n\n</\n\nli\n\n{% endfor %} {% if admin %}\n\nli\n\nhref\n\n/admin/content-create\n\nNEW CONTENT...\n\n</\n\n</\n\nli\n\n{% endif %}\n\n</\n\nul\n\n{% if admin %}\n\nh1\n\nAdmin functions\n\n</\n\nh1\n\nul\n\nli\n\nhref\n\n/admin/db-flush\n\nFlush database\n\n</\n\n</\n\nli\n\n</\n\nul\n\n{% endif %} {% endblock %}\n\nWe display each piece of content in a list. If an item is paywalled, we show its price if the current user hasn't already purchased it, or \"(PURCHASED)\" if they have.\n\nIn addition, we use {% if admin %} blocks to include links to admin functionality, such as content creation and database flushing, that will only display when an admin is logged in.\n\nThe last page we need to create is templates/content.html, which will display information about individual PDFs:\n\n{% extends \"layout.html\" %} {% block body %}\n\nh1\n\n{{ content[content_id].name }}\n\n</\n\nh1\n\nimg\n\nsrc\n\n/{{ content[content_id].preview_image }}\n\nstyle\n\nmax-width\n\n150\n\npx\n\n/>\n\n{{ content[content_id].description }}\n\n</\n\n{% if content_id in my_library or not content[content_id].paywalled %}\n\nhref\n\n/content-file/{{ content_id }}\n\nDownload PDF\n\n</\n\n{% else %}\n\nform\n\naction\n\n/checkout/{{ content_id }}\n\nmethod\n\nPOST\n\nbutton\n\ntype\n\nsubmit\n\nid\n\ncheckout-button\n\nBuy {{ content[content_id].name }} for {{\n\n\"${:,.2f}\".format(content[content_id].price) }}\n\n</\n\nbutton\n\n</\n\nform\n\n{% endif %} {% endblock %}\n\nAs with the home page, we display different parts of the page depending on whether the content is paywalled, and whether the current user owns it. If the user must purchase the PDF, we include a single-button form that posts to /checkout/<content_id>, an application route we'll create in the next section.\n\nWe've referred to a lot of different variables in our front-end templates. Flask's Jinja templating framework allows us to pass the variables we need into render_template, as we did when building the application backend. Our content creation page needed a form, and our content viewing pages needed an ID. In addition, we unpack the return value of a function named context to all of our rendered pages. Define this function now with our other helper functions in main.py, just below owns_content:\n\ndef\n\ncontext\n\nif\n\n\"content_library\"\n\nin\n\nusers\n\ncurrent\n\nkeys\n\nand\n\nusers\n\ncurrent\n\n\"content_library\"\n\nis\n\nnot\n\nNone\n\nmy_library\n\nusers\n\ncurrent\n\n\"content_library\"\n\nelse\n\nmy_library\n\nreturn\n\n\"username\"\n\nweb\n\nauth\n\nname\n\n\"my_library\"\n\nmy_library\n\n\"admin\"\n\nis_admin\n\nweb\n\nauth\n\nname\n\n\"content\"\n\ndb\n\n\"content\"\n\nThis will give every page most of the application's state, including the full content dictionary and the current user's library. If we find we need another piece of state later, we can add it to the context helper function, and it will be available to all our pages.\n\nRun your repl now and add some content. For best results, open the site in a new tab, rather than using it in your repl's browser.\n\nIf you add free PDFs, you'll be able to download them, but you won't be able to purchase paywalled PDFs yet.\n\nIntegrating with Stripe\u200b\n\nOur application is fully functional for free PDFs. To have users pay for premium PDFs, we'll integrate Stripe Checkout. This will save us the trouble and risk of developing our own payment gateway or storing users' card details.\n\nTo use Stripe Checkout, you will need an activated Stripe account.", "start_char_idx": 16658, "end_char_idx": 20676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "85b252cd-d9a7-45b1-948c-ce2fbb377345": {"__data__": {"id_": "85b252cd-d9a7-45b1-948c-ce2fbb377345", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c9ce47ad-1d4a-4d24-b1b6-9b86ee377393", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "7f8bddafb9c916df8af05838ff59865ac250c2da437c016b6c8f42dcbb06965a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f069c5c0-9991-475c-aa73-fe756b51ba9a", "node_type": "1", "metadata": {}, "hash": "bde033b266e3864ebda38bbe77e2132947c2f7d2781fc5313b517a1be6ad1772", "class_name": "RelatedNodeInfo"}}, "hash": "26554ecba1da5d636bf29a9fd31bfab81cfaf943caaf21ba99a17fa21f02811b", "text": "If we find we need another piece of state later, we can add it to the context helper function, and it will be available to all our pages.\n\nRun your repl now and add some content. For best results, open the site in a new tab, rather than using it in your repl's browser.\n\nIf you add free PDFs, you'll be able to download them, but you won't be able to purchase paywalled PDFs yet.\n\nIntegrating with Stripe\u200b\n\nOur application is fully functional for free PDFs. To have users pay for premium PDFs, we'll integrate Stripe Checkout. This will save us the trouble and risk of developing our own payment gateway or storing users' card details.\n\nTo use Stripe Checkout, you will need an activated Stripe account. Create one now at https://stripe.com if you haven't already.\n\nOnce you've created a Stripe account, add the following code near the top of main.py, just below the import statements:\n\n# Stripe setup\n\nstripe\n\napi_key\n\nos\n\nenviron\n\n\"STRIPE_KEY\"\n\nDOMAIN\n\n\"YOUR-REPL-URL-HERE\"\n\nYou can find your Stripe API keys on this page of the developer dashboard. Make sure that you're in test mode and copy the secret key to your clipboard. Then return to your repl and create an environment variable called STRIPE_KEY with the value you just copied from Stripe.\n\nYou will also need to replace the value of DOMAIN with your repl's root URL. You can get this URL from the in-repl browser.\n\nStripe Checkout\u200b\n\nStripe provides detailed technical documentation and code snippets in a variety of languages, so setting up basic integration is largely a matter of copying and adapting these code snippets to our needs. We'll start by creating the /checkout/<content_id> route. This will create a new Stripe checkout session and redirect the user to a Stripe payment page. Add the following code below your content_file function definition:\n\n# Stripe integration\n\n@app\n\nroute\n\n\"/checkout/<content_id>\"\n\nmethods\n\n\"POST\"\n\n@web\n\nauthenticated\n\ndef\n\ncheckout\n\ncontent_id\n\n# Proceed to checkout\n\ntry\n\ncheckout_session\n\nstripe\n\ncheckout\n\nSession\n\ncreate\n\nline_items\n\n\"price_data\"\n\n\"currency\"\n\n\"usd\"\n\n\"product_data\"\n\n\"name\"\n\ndb\n\n\"content\"\n\ncontent_id\n\n\"name\"\n\n\"images\"\n\nDOMAIN\n\n\"/\"\n\ndb\n\n\"content\"\n\ncontent_id\n\n\"preview_image\"\n\n'unit_amount'\n\nint\n\ndb\n\n\"content\"\n\ncontent_id\n\n\"price\"\n\n100\n\n\"quantity\"\n\npayment_method_types\n\n'card'\n\nmode\n\n'payment'\n\nsuccess_url\n\nDOMAIN\n\n'/success?session_id={CHECKOUT_SESSION_ID}'\n\ncancel_url\n\nDOMAIN\n\n'/cancel'\n\nexcept\n\nException\n\nas\n\nreturn\n\nstr\n\n# Record order\n\norder_id\n\ncheckout_session\n\nid\n\ndb\n\n\"orders\"\n\norder_id\n\n\"content_id\"\n\ncontent_id\n\n\"buyer\"\n\nweb\n\nauth\n\nname\n\nreturn\n\nredirect\n\ncheckout_session\n\nurl\n\ncode\n\n303\n\nThis code is adapted from Stripe's sample integration Python code. It initiates a checkout from the pricing and product details we provide and redirects the user to Stripe's checkout website to pay. If payment is successful, it sends the user to a success_url on our site; otherwise, it sends to the user to a cancel_url. We'll define both of these shortly.\n\nWe've made two key changes to the sample code. First, we've included the details for our content item in line_items:\n\nline_items\n\n\"price_data\"\n\n\"currency\"\n\n\"usd\"\n\n\"product_data\"\n\n\"name\"\n\ndb\n\n\"content\"\n\ncontent_id\n\n\"name\"\n\n\"images\"\n\nDOMAIN\n\n\"/\"\n\ndb\n\n\"content\"\n\ncontent_id\n\n\"preview_image\"\n\n'unit_amount'\n\nint\n\ndb\n\n\"content\"\n\ncontent_id\n\n\"price\"\n\n100\n\n\"quantity\"\n\nRather than defining individual products on Stripe's side, we're programmatically constructing our products at checkout time. This saves us from having to add our PDF metadata in two places. We provide our product's name, and the full URL of its preview image, so both can be shown on the Stripe Checkout page. As Stripe expects prices in cents, we multiply the price from our database by 100 before converting it to an integer.\n\nThe second change we've made to the sample code is to record the order details in our database. We need to do this so that we can fulfill the order once it's paid for.\n\n# Record order\n\norder_id\n\ncheckout_session\n\nid\n\ndb\n\n\"orders\"\n\norder_id\n\n\"content_id\"\n\ncontent_id\n\n\"buyer\"\n\nweb\n\nauth\n\nname\n\nWe reuse Stripe's Checkout Session object's id as our order_id so that we can link the two later.", "start_char_idx": 19973, "end_char_idx": 24143, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f069c5c0-9991-475c-aa73-fe756b51ba9a": {"__data__": {"id_": "f069c5c0-9991-475c-aa73-fe756b51ba9a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "85b252cd-d9a7-45b1-948c-ce2fbb377345", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "26554ecba1da5d636bf29a9fd31bfab81cfaf943caaf21ba99a17fa21f02811b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a05df528-9222-4d41-8475-4b30505d235a", "node_type": "1", "metadata": {}, "hash": "85dea1a7ff7dd8a138357ae1b26a637815cc9a30e3131be7b7315f90de496191", "class_name": "RelatedNodeInfo"}}, "hash": "bde033b266e3864ebda38bbe77e2132947c2f7d2781fc5313b517a1be6ad1772", "text": "This saves us from having to add our PDF metadata in two places. We provide our product's name, and the full URL of its preview image, so both can be shown on the Stripe Checkout page. As Stripe expects prices in cents, we multiply the price from our database by 100 before converting it to an integer.\n\nThe second change we've made to the sample code is to record the order details in our database. We need to do this so that we can fulfill the order once it's paid for.\n\n# Record order\n\norder_id\n\ncheckout_session\n\nid\n\ndb\n\n\"orders\"\n\norder_id\n\n\"content_id\"\n\ncontent_id\n\n\"buyer\"\n\nweb\n\nauth\n\nname\n\nWe reuse Stripe's Checkout Session object's id as our order_id so that we can link the two later.\n\nIf you run your repl now, you should be able to reach the Stripe checkout page for any paywalled content you've added. Don't try to pay for anything yet though, as we still need to build order fulfillment.\n\nStripe fulfillment\u200b\n\nAs we're selling digital goods, we can integrate fulfillment directly into our application by adding purchased content to the buyer's library as soon as payment has been made. We'll do this with a function called fulfill_order, which you can add just below the checkout function definition.\n\ndef\n\nfulfill_order\n\nsession\n\n# Get order details\n\ncontent_id\n\ndb\n\n\"orders\"\n\nsession\n\nid\n\n\"content_id\"\n\nbuyer\n\ndb\n\n\"orders\"\n\nsession\n\nid\n\n\"buyer\"\n\n# Add content to library\n\nif\n\nsession\n\npayment_status\n\n==\n\n\"paid\"\n\nand\n\nnot\n\nowns_content\n\nbuyer\n\ncontent_id\n\nif\n\nusers\n\nbuyer\n\n\"content_library\"\n\nis\n\nnot\n\nNone\n\nusers\n\nbuyer\n\n\"content_library\"\n\nappend\n\ncontent_id\n\nelse\n\nusers\n\nbuyer\n\n\"content_library\"\n\ncontent_id\n\nThis function takes a Stripe Checkout Session object, retrieves the corresponding order from our database, and then adds the order's content to the buyer's library if a payment has been made, and the buyer does not already own the content.\n\nWe'll invoke this function from our /success route, which we'll define just below it.\n\n@app\n\nroute\n\n'/success'\n\nmethods\n\n'GET'\n\n@web\n\nauthenticated\n\ndef\n\nsuccess\n\n# Get payment info from Stripe\n\nsession\n\nstripe\n\ncheckout\n\nSession\n\nretrieve\n\nrequest\n\nargs\n\nget\n\n'session_id'\n\n# Abort if user is not buyer\n\nif\n\nweb\n\nauth\n\nname\n\n!=\n\ndb\n\n\"orders\"\n\nsession\n\nid\n\n\"buyer\"\n\nreturn\n\n\"Access denied.\"\n\nfulfill_order\n\nsession\n\nreturn\n\nrender_template_string\n\nf'<html><body><h1>Thanks for your order,\n\nweb\n\nauth\n\nname\n\n!</h1><p>Your purchase has been added to your <a href=\"/\">library</a>.</p></body></html>'\n\nHere we retrieve the session details from the session_id GET parameter Stripe passed to our app, ensure that the current user is also the order buyer, and call fulfill_order. We then render a simple success page. You can replace this with a full Jinja template if you want to make it a bit fancier.\n\nWe also need to define the /cancel route, used if the payment fails. This one is quite simple:\n\n@app\n\nroute\n\n'/cancel'\n\nmethods\n\n'GET'\n\n@web\n\nauthenticated\n\ndef\n\ncancel\n\nreturn\n\nrender_template_string\n\n\"<html><body><h1>Order canceled.</h1></body></html>\"\n\nIf you run your repl now, you should be able to purchase content. You can find test credit card numbers on the Stripe integration testing documentation page. You can use any future date as the expiry date and any CVV.\n\nWebhooks\u200b\n\nA potential problem with the way we're fulfilling orders is that a user might close the Stripe Checkout tab or lose internet connectivity after their payment has been confirmed, but before they're redirected to our /success route. If this happens, we'll have their money, but they won't have their PDF.\n\nFor this reason, Stripe provides an additional method for fulfilling orders, based on webhooks. A webhook is an HTTP route intended to be used by machines rather than people. Much like we've created routes for our admins to upload PDFs, and our users to buy PDFs, we'll now create a route for Stripe's bots to notify our application of completed payments.\n\nFirst, you'll need to create a webhook on your Stripe Dashboard. Visit the Webhooks page and click Add endpoint. You should then see a page like this:\n\nOn this page, do the following:\n\nFor the Endpoint URL value, enter your repl's URL, followed by /fulfill-hook.\n\nSelect the checkout.session.completed event from Select events to listen to.\n\nClick Add endpoint.", "start_char_idx": 23449, "end_char_idx": 27724, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a05df528-9222-4d41-8475-4b30505d235a": {"__data__": {"id_": "a05df528-9222-4d41-8475-4b30505d235a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aa794b15-1550-431c-aaad-1452d1344831", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "f0ff63aa348027f5b10632b9b391b10c1f19894ce72290d3f6d79c68594f2ae8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f069c5c0-9991-475c-aa73-fe756b51ba9a", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}, "hash": "bde033b266e3864ebda38bbe77e2132947c2f7d2781fc5313b517a1be6ad1772", "class_name": "RelatedNodeInfo"}}, "hash": "85dea1a7ff7dd8a138357ae1b26a637815cc9a30e3131be7b7315f90de496191", "text": "If this happens, we'll have their money, but they won't have their PDF.\n\nFor this reason, Stripe provides an additional method for fulfilling orders, based on webhooks. A webhook is an HTTP route intended to be used by machines rather than people. Much like we've created routes for our admins to upload PDFs, and our users to buy PDFs, we'll now create a route for Stripe's bots to notify our application of completed payments.\n\nFirst, you'll need to create a webhook on your Stripe Dashboard. Visit the Webhooks page and click Add endpoint. You should then see a page like this:\n\nOn this page, do the following:\n\nFor the Endpoint URL value, enter your repl's URL, followed by /fulfill-hook.\n\nSelect the checkout.session.completed event from Select events to listen to.\n\nClick Add endpoint.\n\nStripe should then redirect you to your new webhook's details page. From here you can see webhook details, logs and the signing secret. The signing secret is used to ensure that our webhook only accepts requests from Stripe \u2013 otherwise, anyone could call it with spoofed data and complete orders without paying. Reveal your webhook's signing secret and copy it to your clipboard, then return to your repl.\n\nWe'll use another environment variable here. Add the following code below your cancel function definition:\n\nendpoint_secret\n\nos\n\nenviron\n\n'ENDPOINT_SECRET'\n\nThen create an environment variable called ENDPOINT_SECRET with the value you just copied from Stripe.\n\nFor our app's webhook code, we can once again tweak Stripe's sample code. We'll use this order fulfillment code as a base. Add this code below your endpoint_secret assignment:\n\n@app\n\nroute\n\n'/fulfill-hook'\n\nmethods\n\n'POST'\n\ndef\n\nfulfill_webhook\n\nevent\n\nNone\n\npayload\n\nrequest\n\ndata\n\nsig_header\n\nrequest\n\nheaders\n\n'STRIPE_SIGNATURE'\n\ntry\n\nevent\n\nstripe\n\nWebhook\n\nconstruct_event\n\npayload\n\nsig_header\n\nendpoint_secret\n\nexcept\n\nValueError\n\nas\n\n# Invalid payload\n\nraise\n\nexcept\n\nstripe\n\nerror\n\nSignatureVerificationError\n\nas\n\n# Invalid signature\n\nraise\n\n# Handle the event\n\nif\n\nevent\n\n'type'\n\n==\n\n'checkout.session.completed'\n\nsession\n\nevent\n\n'data'\n\n'object'\n\n# Fulfill the purchase...\n\nfulfill_order\n\nsession\n\nelse\n\nprint\n\n'Unhandled event type {}'\n\nformat\n\nevent\n\n'type'\n\nreturn\n\njsonify\n\nsuccess\n\nTrue\n\nAfter ensuring that the request we've received comes from Stripe, we retrieve the Checkout Session object from Stripe's checkout.session.completed event and use it to call fulfill_order.\n\nIf you run your repl now, you should be able to purchase a PDF, close the checkout page after your payment is accepted but before being redirected, and still end up with the PDF in your library. You can also view webhook invocation logs on the Stripe Dashboard.\n\nWhere next?\u200b\n\nWe've built a functional if fairly basic storefront for digital goods. If you'd like to continue with this project, consider the following extensions:\n\nImproving the site's appearance with custom CSS.\n\nBranching out from PDFs to other files, such as audio podcasts, videos, or desktop software.\n\nProviding a subscription option that gives users access to all PDFs for a limited time.\n\nConverting the site into a peer-to-peer marketplace where users can all upload and purchase files from each other.\n\nYou can find the code for this tutorial here:\n\n< Previous: Building an internal organization tool\n\nNext: PDF report generator from spreadsheet >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting started\n\nContent upload and other admin functionalityAccess controlContent creation formAdmin routes\n\nContent viewing and paywalls\n\nCreating the application frontend\n\nIntegrating with StripeStripe CheckoutStripe fulfillmentWebhooks\n\nWhere next?", "start_char_idx": 26933, "end_char_idx": 30610, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"aa794b15-1550-431c-aaad-1452d1344831": {"node_ids": ["1d3e88d5-347f-4273-b473-bcc41e20144c", "43d97bd7-9240-4e25-a28e-4b05f12f3840", "3e9cf369-e3af-42d5-8156-043f5ae6e227", "63e75bd2-a212-4fe8-ab04-d70c4ec96ad2", "3bfeeb72-76d9-479c-af40-03e6a69ce4bf", "c9ce47ad-1d4a-4d24-b1b6-9b86ee377393", "85b252cd-d9a7-45b1-948c-ce2fbb377345", "f069c5c0-9991-475c-aa73-fe756b51ba9a", "a05df528-9222-4d41-8475-4b30505d235a"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/paid-content-site.html"}}}, "docstore/metadata": {"1d3e88d5-347f-4273-b473-bcc41e20144c": {"doc_hash": "ecbf0449a9037ebf72ce091409ba6bb92a8cd5204ba370942fc50353b2f40ae2", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "43d97bd7-9240-4e25-a28e-4b05f12f3840": {"doc_hash": "5ff396d120a33c5eee33622d293aca25d5c6a180428783ff33433a21228f1ed8", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "3e9cf369-e3af-42d5-8156-043f5ae6e227": {"doc_hash": "1fa325bae929a97f4c01c8ca1911ab1b68f51266f9357a4361998a54ed7a98e3", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "63e75bd2-a212-4fe8-ab04-d70c4ec96ad2": {"doc_hash": "5238289d2075a23935d7b21ef76fb59be27332cf0b212dbae6e2528d79df0942", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "3bfeeb72-76d9-479c-af40-03e6a69ce4bf": {"doc_hash": "7179f817db650b5bd7b2d2ae58d76de831794393ff36c4a8acc340c7cbf4fbb5", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "c9ce47ad-1d4a-4d24-b1b6-9b86ee377393": {"doc_hash": "7f8bddafb9c916df8af05838ff59865ac250c2da437c016b6c8f42dcbb06965a", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "85b252cd-d9a7-45b1-948c-ce2fbb377345": {"doc_hash": "26554ecba1da5d636bf29a9fd31bfab81cfaf943caaf21ba99a17fa21f02811b", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "f069c5c0-9991-475c-aa73-fe756b51ba9a": {"doc_hash": "bde033b266e3864ebda38bbe77e2132947c2f7d2781fc5313b517a1be6ad1772", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}, "a05df528-9222-4d41-8475-4b30505d235a": {"doc_hash": "85dea1a7ff7dd8a138357ae1b26a637815cc9a30e3131be7b7315f90de496191", "ref_doc_id": "aa794b15-1550-431c-aaad-1452d1344831"}}}