{"docstore/data": {"d0800f40-4b02-45b3-9990-8b7c5845815d": {"__data__": {"id_": "d0800f40-4b02-45b3-9990-8b7c5845815d", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "eb2fb3c8a5d4ca085a2fec05e82fb8c6504da4c3f173bdb226cc2250e99bd693", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "48a8f33c-cb80-4b57-8053-80162b35f980", "node_type": "1", "metadata": {}, "hash": "b3b9342e7d35a8697aad24a7939eebe31d3b279b543e19e837675b76cc55ed57", "class_name": "RelatedNodeInfo"}}, "hash": "94c239369bfcb9695f64c9d29d56fc2a820eae69e1921ca067dde120a3eef302", "text": "GraphQL as an alternative to REST\u200b\n\nGraphQL can be used to express almost any type of data request. As an example, the immensely popular Gatsby React framework uses GraphQL to query frontmatter and plain text inside Markdown files. Yet, in the majority of cases, GraphQL is used as an alternative to a traditional REST (Representational State Transfer) approach.\n\nGET), sending data (\n\nPOST), merging two data structures (\n\nPATCH) or even removing data (\n\nDELETE). However, the primary drawback of REST is that it relies on the creation of fixed data endpoints. This means that a single request is only scoped to a specific, pre-defined set of data.\n\nChimezie Enyinnaya, a Nigerian content creator for\n\nPusher (a service that manages remote\n\npub/sub messaging), explains it as follows:\n\n\u201cWith REST, we might have a /authors/:id endpoint to fetch an author, then another /authors/:id/posts endpoint to fetch the post of that particular author. Lastly, we could have a /authors/:id/posts/:id/comments endpoint that fetches the comments on the posts. [\u2026] It is easy to fetch more than the data you need with REST, because each endpoint in a REST API has a fixed data structure which it is meant to return whenever it is hit.\u201d\n\n\u2014 Chimezie Enyinnaya: REST versus GraphQL\n\nGraphQL was created as a solution to this problem. Facebook created it to provide a standardized syntax to write more expressive (and powerful) data queries within the Facebook mobile app when fetching remote data.\n\n\"Hello World\" in GraphQL\u200b\n\nSo where does one start with GraphQL?\n\nThere are several GraphQL libraries that provide useful abstractions when working with GraphQL. The most popular are Apollo and Relay. While these provide a lot of helpful features, like cache management and normalization, they can be overwhelming to someone just starting with GraphQL. They also tend to be quite large and opinionated \u2013 meaning that they might be overkill for smaller, more flexible projects.\n\nGrahpQL is an open standard (similar to HTML). It is therefore not locked to any specific tool, library or platform. This means that we are able to use GraphQL directly with the native JavaScript fetch API, or even with a light-weight AJAX library like Axios. In the example below, we will establish what the 'Hello World' equivalent of GraphQL in JavaScript would be. In other words:\n\nUsing a GraphQL Explorer\u200b\n\nMost GraphQL endpoints come with some form of GraphQL explorer, the most popular being GraphiQL and GraphQL Playground. As an example, let's start with a public GraphQL endpoint provided by the event management platform Universe.com. Their endpoint allows developers to retrieve data associated with specific events in their database. We can use their explorer to create and test a super basic query.\n\nIf you go to https://universe.com/graphiql, you should see the following:\n\nThe left-hand (white) pane allows you to write specific queries, whereas the middle (grey) pane shows the response from the endpoint once you run the query. Lastly, the right-hand (white) pane contains the documentation generated by the endpoint (if it is hidden, click on the top-right button that says \"< Docs\"). The play button (the sideways triangle in the upper-left) executes the current query, whereas \"Prettify\" reformats your query according to best practice (in terms of layout). \"History\" allows you to see queries used previously in the explorer.\n\nWe can run the default starting query (at the time of writing) and we'll get a JSON-like response that looks something like this:\n\n\"data\"\n\n\"event\"\n\n\"title\"\n\n\"End of Unix Time\"\n\n\"address\"\n\n\"Los Angeles, CA, USA\"\n\n\"currency\"\n\n\"USD\"\n\n\"host\"\n\n\"firstName\"\n\n\"Joshua\"\n\n\"timeSlots\"\n\n\"totalCount\"\n\n\"nodes\"\n\n\"startAt\"\n\n\"2018-08-31T12:00:00\"\n\n\"startAt\"\n\n\"2038-01-18T21:00:00\"\n\nLet's take a look at what just happened. We'll clear the left-hand pane and recreate the query step-by-step.\n\nWe can start by adding query { }. This indicates to the endpoint that we want to retrieve data from the server.\n\nPlace your cursor within the curly brackets and press the spacebar and enter keys at the same time. We should get a list of recommended queries (based on the structure of the data) as follows:\n\nAs per our initial example, let's reselect event. This means that we want to retrieve information associated with a specific event. The event we are interested in has a unique ID of 5879ad8f6672e70036d58ba5.", "start_char_idx": 0, "end_char_idx": 4401, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "48a8f33c-cb80-4b57-8053-80162b35f980": {"__data__": {"id_": "48a8f33c-cb80-4b57-8053-80162b35f980", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "eb2fb3c8a5d4ca085a2fec05e82fb8c6504da4c3f173bdb226cc2250e99bd693", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d0800f40-4b02-45b3-9990-8b7c5845815d", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "94c239369bfcb9695f64c9d29d56fc2a820eae69e1921ca067dde120a3eef302", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "651cff8d-fc10-48e7-b61e-6074e79ee3d6", "node_type": "1", "metadata": {}, "hash": "640abf7ae3106bf7323c24b2200efdb4b1bf7b79ec10cc4c00cd0522617071f2", "class_name": "RelatedNodeInfo"}}, "hash": "b3b9342e7d35a8697aad24a7939eebe31d3b279b543e19e837675b76cc55ed57", "text": "We'll clear the left-hand pane and recreate the query step-by-step.\n\nWe can start by adding query { }. This indicates to the endpoint that we want to retrieve data from the server.\n\nPlace your cursor within the curly brackets and press the spacebar and enter keys at the same time. We should get a list of recommended queries (based on the structure of the data) as follows:\n\nAs per our initial example, let's reselect event. This means that we want to retrieve information associated with a specific event. The event we are interested in has a unique ID of 5879ad8f6672e70036d58ba5. We can pass this ID as an argument to the query (similar to how we would with JavaScript functions) as follows: event(id: \"5879ad8f6672e70036d58ba5\") { }.\n\nNow that we've identified the event that we want to query, we can instruct GraphQL to only retrieve the information that we're interested in. This prevents the response from returning the entire event data-structure (called over-fetching in REST). In order to illustrate the dynamic nature of GraphQL, we will be querying completely different data associated with the event as shown in the example below:\n\nquery\n\nevent\n\nid\n\n\"5879ad8f6672e70036d58ba5\"\n\nactive\n\naddress\n\nurl\n\nNotice that our initial example had nested queries. This is where the distinction between GraphQL and REST becomes central. Everything we've done up until this point very much adheres to the way we would think about a traditional REST request.\n\nREST requests function similar to a traditional JavaScript function, where we provide specific arguments and we get a pre-determined response based on the arguments. GraphQL works a bit differently. GraphQL queries are like little maps used to navigate and find all requested data in a single journey. This means that we can conceptualize a set of real-world instructions by means of the GraphQL syntax as follows:\n\ninstructions\n\ntravel\n\ntype\n\n\"drive\"\n\nmall\n\ntravel\n\ntype\n\n\"walk\"\n\ngeneral_store\n\nfood_isle\n\nbread\n\npeanut_butter\n\nstationary_isle\n\npens\n\namount\n\n12\n\npaper\n\nhardware_store\n\nnails\n\nhammer\n\npost_office\n\npackages\n\nmail\n\ngraph-like structure, we can get information loosely related to our event without creating a completely new request. This is where GraphQL really shines when compared to REST! You can think of these as roads or pathways connecting different places. In other words, if you are in the mall (as per our example above), you can go directly to the\n\nDue to the map-like nature of queries, we can actually have a query that follows a circular route, ending up exactly where it started (there is no real practical reason for this, but it demonstrates the graph foundations of GraphQL).\n\nquery\n\nevent\n\nid\n\n\"5879ad8f6672e70036d58ba5\"\n\nactive\n\naddress\n\nurl\n\ntimeSlots\n\nnodes\n\nevent\n\nactive\n\naddress\n\nurl\n\nCreating an API\u200b\n\nCongratulations, you can now write basic GraphQL queries!\n\nUniverse.com is limiting. There are several server-side GraphQL frameworks. Some extremely popular examples are\n\nexpress-graphql for Node (running\n\nExpress) and\n\nGraphene for Python servers. Alternatively, there are several all-in-one solutions like\n\nPrisma or\n\nHasura that come with databases included.\n\nGraphQL as a Service\u200b\n\nFor the sake of simplicity, we will be using a free software as a service (SaaS) platform called GraphCMS. This allows us to get a custom GraphQL endpoint up with minimal set up.\n\nTo follow along:\n\nVisit https://graphcms.com and sign up for a free account.\n\nOnce your account has been created, create a new sample project by selecting the \"Podcast Starter\" template.\n\nMake sure that \"Include template content\" is selected, as this will populate our API with placeholder information.\n\nAdd or edit content to the API using the GraphCMS project dashboard, but make sure that you don't change the schema since we will be relying on it to write our queries.\n\nNote that GraphCMS allows you to create a new project completely from scratch, however for our purposes we only want to have a working endpoint with placeholder content. If you are interested in diving deeper into GraphCMS, you can consult their documentation at https://graphcms.com/docs.\n\nOnce your project has been created, you can select the \"Settings\" tab at the bottom-left corner, and navigate to \"API Access\". Make sure to copy the endpoint URL (at the top of the page) and save it somewhere where you will be able to access it later. We'll be directing all our GraphQL queries to this URL, so it is useful to have it at hand.", "start_char_idx": 3818, "end_char_idx": 8295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "651cff8d-fc10-48e7-b61e-6074e79ee3d6": {"__data__": {"id_": "651cff8d-fc10-48e7-b61e-6074e79ee3d6", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "eb2fb3c8a5d4ca085a2fec05e82fb8c6504da4c3f173bdb226cc2250e99bd693", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "48a8f33c-cb80-4b57-8053-80162b35f980", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "b3b9342e7d35a8697aad24a7939eebe31d3b279b543e19e837675b76cc55ed57", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7c7aeffe-b326-4210-a639-d01747eaf06e", "node_type": "1", "metadata": {}, "hash": "59da5a0f1ce662adbb0edb5ab768451d21cc7f543cd4ad9c0c38b16e704fdfc2", "class_name": "RelatedNodeInfo"}}, "hash": "640abf7ae3106bf7323c24b2200efdb4b1bf7b79ec10cc4c00cd0522617071f2", "text": "Make sure that \"Include template content\" is selected, as this will populate our API with placeholder information.\n\nAdd or edit content to the API using the GraphCMS project dashboard, but make sure that you don't change the schema since we will be relying on it to write our queries.\n\nNote that GraphCMS allows you to create a new project completely from scratch, however for our purposes we only want to have a working endpoint with placeholder content. If you are interested in diving deeper into GraphCMS, you can consult their documentation at https://graphcms.com/docs.\n\nOnce your project has been created, you can select the \"Settings\" tab at the bottom-left corner, and navigate to \"API Access\". Make sure to copy the endpoint URL (at the top of the page) and save it somewhere where you will be able to access it later. We'll be directing all our GraphQL queries to this URL, so it is useful to have it at hand.\n\nNote that your API endpoint should look something like the following:\n\nhttps://api-us-east-1.graphcms.com/v2/ckll20qnkffe101xr8m2a7m2h/master\n\nHowever, in the next code examples, we'll use <<<YOUR ENDPOINT HERE>>> to prevent you from accidentally using an example endpoint if you are following along. If you navigate straight to your endpoint within your browser, you will be presented with a GraphiQL Explorer that allows you to test and try out queries for your specific endpoint:\n\nAdding GraphQL to JavaScript\u200b\n\nLet's take a query built within our API endpoint GraphiQL explorer and place it in our JavaScript file. This allows us to request the above data directly from our browser:\n\nNote that the following example assumes familiarity with the native JavaScript Fetch API. If this is the first time you are encountering it, learn How to Use the JavaScript Fetch API to Get Data.\n\nconst\n\nQUERY\n\nquery {\n\nepisodes {\n\ntitle\n\nconst\n\nFETCH_OPTIONS\n\nmethod\n\n\"POST\"\n\nbody\n\nJSON\n\nstringify\n\nquery\n\nQUERY\n\nfetch\n\n\"<<<YOUR ENDPOINT HERE>>>\"\n\nFETCH_OPTIONS\n\nthen\n\nresponse\n\n=>\n\nresponse\n\njson\n\nthen\n\nconsole\n\nlog\n\nThe above should output something as follows to the browser console:\n\n\"data\"\n\n\"episodes\"\n\n\"title\"\n\n\"# Cras eu urna at ligula \u2013 tempus commodo\"\n\n\"title\"\n\n\"# Phasellus feugiat \u2013 non massa eu tincidunt\"\n\n\"title\"\n\n\"# Lorem ipsum dolor sit\"\n\nCustom GraphQL Function\u200b\n\nWe will be making several GraphQL queries from our website. For this purpose, it is helpful to create a basic abstraction (using a JavaScript function) that handles these requests in order to reduce boilerplate code. We can convert our JavaScript example above into a basic JavaScript function as follows:\n\nNote that the following section assumes familiarity with the async/await operators in JavaScript. If you are unfamiliar with them, have a look at the following guide on the Mozilla Developer Network.\n\nconst\n\ngqlQuery\n\nasync\n\nquery\n\n=>\n\nconst\n\nREQUEST_OPTIONS\n\nmethod\n\n\"POST\"\n\nbody\n\nJSON\n\nstringify\n\nquery\n\nconst\n\nresponse\n\nawait\n\nfetch\n\n\"<<<YOUR ENDPOINT HERE>>>\"\n\nREQUEST_OPTIONS\n\nif\n\nresponse\n\n||\n\nresponse\n\nok\n\nthrow\n\nnew\n\nError\n\n\"Query failed\"\n\nconst\n\ndata\n\nawait\n\nresponse\n\njson\n\nreturn\n\ndata\n\nThis allows us to pass a query to the function, which in return provides a response once the query resolves. We also include a check-in the function to determine whether the response succeeded (by checking if it returned a 200 status, by means of response.ok).\n\nThis means that we should be able to do the following:\n\nconst\n\nQUERY\n\nquery {\n\nepisodes {\n\ntitle\n\ngqlQuery\n\nQUERY\n\nthen\n\nconsole\n\nlog\n\nThis works, but it always returns an array of all the episodes from our entire database. If we only want the two most recent episodes, we can do the following in our query:\n\nquery\n\nepisodes\n\nfirst\n\ntitle\n\nHowever, this isn't very flexible, since it means that we'll need to create an entire new query each time we want get a specific number of episodes. Luckily, GraphQL lets us pass variables as part of the query. For example, if we have a look in our GraphiQL explorer, we can do the following (you might need to click on \"QUERY VARIABLES\" in the bottom-left corner to open it up):\n\nstrongly typed language we are required to declare what type of data\n\nIf you are not familiar with the concept of strongly typed languages, read the following guide by Glavio Copes.", "start_char_idx": 7375, "end_char_idx": 11638, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c7aeffe-b326-4210-a639-d01747eaf06e": {"__data__": {"id_": "7c7aeffe-b326-4210-a639-d01747eaf06e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "eb2fb3c8a5d4ca085a2fec05e82fb8c6504da4c3f173bdb226cc2250e99bd693", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "651cff8d-fc10-48e7-b61e-6074e79ee3d6", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "640abf7ae3106bf7323c24b2200efdb4b1bf7b79ec10cc4c00cd0522617071f2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c9caaf17-3217-43d9-b60c-ad6711492f44", "node_type": "1", "metadata": {}, "hash": "f1e22db8e63baa30abe5a13bccef75247fe95a6e1e4f774b17032c9a222d2e40", "class_name": "RelatedNodeInfo"}}, "hash": "59da5a0f1ce662adbb0edb5ab768451d21cc7f543cd4ad9c0c38b16e704fdfc2", "text": "If we only want the two most recent episodes, we can do the following in our query:\n\nquery\n\nepisodes\n\nfirst\n\ntitle\n\nHowever, this isn't very flexible, since it means that we'll need to create an entire new query each time we want get a specific number of episodes. Luckily, GraphQL lets us pass variables as part of the query. For example, if we have a look in our GraphiQL explorer, we can do the following (you might need to click on \"QUERY VARIABLES\" in the bottom-left corner to open it up):\n\nstrongly typed language we are required to declare what type of data\n\nIf you are not familiar with the concept of strongly typed languages, read the following guide by Glavio Copes.\n\nconst\n\ngqlQuery\n\nasync\n\nquery\n\nvariables\n\n=>\n\nconst\n\nREQUEST_OPTIONS\n\nmethod\n\n\"POST\"\n\nbody\n\nJSON\n\nstringify\n\nquery\n\nvariables\n\nconst\n\nresponse\n\nawait\n\nfetch\n\n\"<<<YOUR ENDPOINT HERE>>>\"\n\nREQUEST_OPTIONS\n\nif\n\nresponse\n\n||\n\nresponse\n\nok\n\nthrow\n\nnew\n\nError\n\n\"Query failed\"\n\nconst\n\ndata\n\nawait\n\nresponse\n\njson\n\nreturn\n\ndata\n\nThis means that we'll be able to do the following (which will respectively log the first, first-two and first-three episodes to the console):\n\nconst\n\nQUERY\n\nquery ($count: Int) {\n\nepisodes(first: $count) {\n\ntitle\n\ngqlQuery\n\nQUERY\n\ncount\n\nthen\n\nconsole\n\nlog\n\ngqlQuery\n\nQUERY\n\ncount\n\nthen\n\nconsole\n\nlog\n\ngqlQuery\n\nQUERY\n\ncount\n\nthen\n\nconsole\n\nlog\n\nDefining an Information Architecture\u200b\n\nWith our endpoint now set up, we need to start mapping out all the information we want to show on each page. In the world of user experience, we call this information architecture mapping.\n\nAs an example, consider the following basic outline, which we'll use as a reference when requesting data from the endpoint:\n\nGraphQL FM Website\n\n##\n\nEpisodes Page (Default Landing Page)\n\nThe first episode (for hero banner)\n\nUnique ID (This will be used as the URL when viewing the episode)\n\nEpisode name\n\nCover image URL\n\nAudio\n\nFile URL\n\nFile type (for example\n\n`.mp3`\n\n`.wav`\n\n, etc.)\n\nPrevious episodes (all episodes after the first one)\n\nUnique ID (This will be used as the URL when viewing the episode)\n\nPublished date\n\nEpisode name\n\nCover image URL\n\n##\n\nSingle Episode Page\n\nPrevious episode ID (if applicable)\n\nNext episode ID (if applicable)\n\nCurrent episode\n\nEpisode number\n\nPublished date\n\nEpisode name\n\nCover image URL\n\nShow notes\n\nList of topics associated with episode\n\nAudio\n\nFile URL\n\nFile type (for example\n\n`.mp3`\n\n`.wav`\n\n, etc.)\n\nList of guests\n\nName of each guest\n\nPhoto URL of each guest\n\nList of episode sponsors\n\nName of sponsoring company\n\nWebsite URL of sponsoring company\n\n##\n\nGuests Page\n\nList of guests\n\nName of each guest\n\nPhoto URL of each guest\n\nList of episodes that appeared on\n\nUnique ID (This will be used as the URL when viewing the episode)\n\nDate that each episode was published\n\nEpisode name for each episode\n\nCover image URL for each episode\n\n##\n\nTopics Page\n\nA list of all topics\n\nThe name of each topic\n\nAll episodes associated with a specific topic\n\nUnique ID if the episode (This will be used as the URL when viewing the episode)\n\nThe date that each episode was published\n\nThe name of each episode\n\nThe cover image URL of each episode\n\n##\n\nResources Page\n\nA list of all resources\n\nThe filename of each individual resource\n\nThe file type (for example\n\n`.mp3`\n\n`.wav`\n\n, etc.) of each resource\n\nThe URL where each individual resource can be downloaded\n\n##\n\nSponsors Page\n\nA list of all sponsors\n\nThe company name associated with each sponsorship\n\nAll the episodes that a specific company is sponsoring\n\nUnique ID if the episode (This will be used as the URL when viewing the episode)\n\nThe date that each episode was published\n\nThe name of each episode\n\nThe cover image URL of each episode\n\nLoading the Data\u200b\n\nWhile creating our information architecture, one thing immediately stands out: there are some specific data co-configurations that are called multiple times. Luckily, the GraphQL standardization allows for something called fragments. Fragments helps keep our queries DRY (a programming acronym for Don't Repeat Yourself). The most common co-configuration seems to be the data required to show a preview of a specific episode.", "start_char_idx": 10960, "end_char_idx": 15110, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c9caaf17-3217-43d9-b60c-ad6711492f44": {"__data__": {"id_": "c9caaf17-3217-43d9-b60c-ad6711492f44", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "eb2fb3c8a5d4ca085a2fec05e82fb8c6504da4c3f173bdb226cc2250e99bd693", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7c7aeffe-b326-4210-a639-d01747eaf06e", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "59da5a0f1ce662adbb0edb5ab768451d21cc7f543cd4ad9c0c38b16e704fdfc2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "75550e7a-fcc4-4afd-9d80-6c7369b3a556", "node_type": "1", "metadata": {}, "hash": "2dc769c39b14f489c02dd28882baebf2abdd56924cdb36ce8f75cd8dd46a630a", "class_name": "RelatedNodeInfo"}}, "hash": "f1e22db8e63baa30abe5a13bccef75247fe95a6e1e4f774b17032c9a222d2e40", "text": "of each resource\n\nThe URL where each individual resource can be downloaded\n\n##\n\nSponsors Page\n\nA list of all sponsors\n\nThe company name associated with each sponsorship\n\nAll the episodes that a specific company is sponsoring\n\nUnique ID if the episode (This will be used as the URL when viewing the episode)\n\nThe date that each episode was published\n\nThe name of each episode\n\nThe cover image URL of each episode\n\nLoading the Data\u200b\n\nWhile creating our information architecture, one thing immediately stands out: there are some specific data co-configurations that are called multiple times. Luckily, the GraphQL standardization allows for something called fragments. Fragments helps keep our queries DRY (a programming acronym for Don't Repeat Yourself). The most common co-configuration seems to be the data required to show a preview of a specific episode.\n\nWe can wrap this in a GraphQL fragment as follows (very similar to how we would create a query itself in JavaScript):\n\nconst\n\nEPISODE_PREVIEW_FRAGMENT\n\nfragment EpisodePreview on Episode {\n\nid\n\ndate: publishedAt\n\ntitle\n\nimage {\n\nurl\n\nWe can then use it in a specific query as follows (by using JavaScript string interpolation):\n\nconst\n\nGUESTS_PAGE_QUERY\n\nquery\n\npeoples\n\nfullName\n\nphoto\n\nurl\n\nepisodes\n\nappearedOn\n\n...\n\nEpisodePreview\n\nEPISODE_PREVIEW_FRAGMENT\n\nIt is common practice to place fragments after the query expression instead of declaring them before the query, because the query should first and foremost be expressive. We should rather include fragments as footnotes for reference. Using our information architecture and the fragment declared above, we can replace all the content in our JavaScript file with the following:\n\nconst\n\nEPISODE_PREVIEW_FRAGMENT\n\nfragment EpisodePreview on Episode {\n\nid\n\ndate: publishedAt\n\ntitle\n\nimage {\n\nurl\n\nconst\n\nEPISODES_PAGE_QUERY\n\nquery {\n\nfirst: episodes(first: 1) {\n\nid\n\ntitle\n\nimage {\n\nurl\n\naudio: audioFile {\n\nurl\n\nmime: mimeType\n\nprevious: episodes(skip: 1) {\n\n...EpisodePreview,\n\n${\n\nEPISODE_PREVIEW_FRAGMENT\n\nconst\n\nSINGLE_EPISODE_PAGE_QUERY\n\nquery($id: ID) {\n\nepisode(where: { id: $id }) {\n\nnumber: episodeNumber\n\ndate: publishedAt\n\ntitle\n\ndescription\n\nnotes: showNotes\n\naudio: audioFile {\n\nurl\n\nmime: mimeType\n\nimage {\n\nurl\n\nguests {\n\nfullName\n\nphoto {\n\nurl\n\ntags {\n\nname\n\nsponsors {\n\ncompany {\n\nname\n\nwebsite\n\nconst\n\nSINGLE_EPISODE_NEIGHBORS_QUERY\n\nquery($previous: Int, $next: Int) {\n\nprevious: episode(where: { episodeNumber: $previous }) { id }\n\nnext: episode(where: { episodeNumber: $next }) { id }\n\nconst\n\nGUESTS_PAGE_QUERY\n\nquery {\n\npeoples {\n\nfullName\n\nphoto {\n\nurl\n\nepisodes: appearedOn {\n\n...EpisodePreview\n\n${\n\nEPISODE_PREVIEW_FRAGMENT\n\nconst\n\nTOPICS_PAGE_QUERY\n\nquery {\n\ntags {\n\nname\n\nepisodes {\n\n...EpisodePreview\n\n${\n\nEPISODE_PREVIEW_FRAGMENT\n\nconst\n\nRESOURCES_PAGE_QUERY\n\nquery {\n\nassets {\n\nfileName\n\nmimeType\n\nurl\n\n${\n\nEPISODE_PREVIEW_FRAGMENT\n\nconst\n\nSPONSORS_PAGE_QUERY\n\nquery {\n\nsponsorships {\n\ncompany {\n\nname\n\nepisodes {\n\n...EpisodePreview\n\n${\n\nEPISODE_PREVIEW_FRAGMENT\n\nconst\n\ngqlQuery\n\nasync\n\nquery\n\nvariables\n\n=>\n\nconst\n\nresponse\n\nawait\n\nfetch\n\n\"https://api-us-east-1.graphcms.com/v2/ckll20qnkffe101xr8m2a7m2h/master\"\n\nmethod\n\n\"POST\"\n\nbody\n\nJSON\n\nstringify\n\nquery\n\nvariables\n\nif\n\nresponse\n\n||\n\nresponse\n\nok\n\nthrow\n\nnew\n\nError\n\n\"Query failed\"\n\nconst\n\ndata\n\nawait\n\nresponse\n\njson\n\nreturn\n\ndata\n\nconst\n\ngetData\n\nasync\n\n=>\n\nconst\n\nepisodes\n\nawait\n\ngqlQuery\n\nEPISODES_PAGE_QUERY\n\nconst\n\nguests\n\nawait\n\ngqlQuery\n\nGUESTS_PAGE_QUERY\n\nconst\n\ntopics\n\nawait\n\ngqlQuery\n\nTOPICS_PAGE_QUERY\n\nconst\n\nsponsors\n\nawait\n\ngqlQuery\n\nSPONSORS_PAGE_QUERY\n\nconst\n\nid\n\nepisodes\n\nfirst\n\nconst\n\nsingleEpisode\n\nawait\n\ngqlQuery\n\nSINGLE_EPISODE_PAGE_QUERY\n\nid\n\nconst\n\nnumber\n\nsingleEpisode\n\nepisode\n\nconst\n\nsingleEpisodeNeighbhors\n\nawait\n\ngqlQuery\n\nSINGLE_EPISODE_NEIGHBORS_QUERY\n\nprevious\n\nnumber\n\nnext\n\nnumber\n\nconsole\n\nlog\n\nepisodes\n\nguests\n\ntopics\n\nsponsors\n\nsingleEpisode\n\nsingleEpisodeNeighbhors\n\ngetData\n\nIf you run the above, you'll get one big object in your browser console.", "start_char_idx": 14253, "end_char_idx": 18249, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "75550e7a-fcc4-4afd-9d80-6c7369b3a556": {"__data__": {"id_": "75550e7a-fcc4-4afd-9d80-6c7369b3a556", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "eb2fb3c8a5d4ca085a2fec05e82fb8c6504da4c3f173bdb226cc2250e99bd693", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c9caaf17-3217-43d9-b60c-ad6711492f44", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}, "hash": "f1e22db8e63baa30abe5a13bccef75247fe95a6e1e4f774b17032c9a222d2e40", "class_name": "RelatedNodeInfo"}}, "hash": "2dc769c39b14f489c02dd28882baebf2abdd56924cdb36ce8f75cd8dd46a630a", "text": "This object contains all the data that we'll be using in our website:\n\nHaving the data in our browser console is not enough. We need to do some additional work in order to structure it in HTML and CSS, to be consumed directly by users. In part 2, we'll walk through doing this, turning our data into a fully functional website.\n\n< Previous: CRM app with Node.js, Replit, and MongoDB\n\nNext: GraphQL Part 2: Creating a web application >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nCreating your own project with Replit\n\nOur GraphQL Goals For This GuideWhat is GraphQL?GraphQL as an alternative to REST\"Hello World\" in GraphQLUsing a GraphQL Explorer\n\nCreating an APIGraphQL as a ServiceAdding GraphQL to JavaScriptCustom GraphQL FunctionDefining an Information ArchitectureLoading the Data", "start_char_idx": 18250, "end_char_idx": 19043, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"1c4c4105-e3b3-4259-ae47-6e4fb671c1e2": {"node_ids": ["d0800f40-4b02-45b3-9990-8b7c5845815d", "48a8f33c-cb80-4b57-8053-80162b35f980", "651cff8d-fc10-48e7-b61e-6074e79ee3d6", "7c7aeffe-b326-4210-a639-d01747eaf06e", "c9caaf17-3217-43d9-b60c-ad6711492f44", "75550e7a-fcc4-4afd-9d80-6c7369b3a556"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/nodejs/graphql-project-part-1.html"}}}, "docstore/metadata": {"d0800f40-4b02-45b3-9990-8b7c5845815d": {"doc_hash": "94c239369bfcb9695f64c9d29d56fc2a820eae69e1921ca067dde120a3eef302", "ref_doc_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2"}, "48a8f33c-cb80-4b57-8053-80162b35f980": {"doc_hash": "b3b9342e7d35a8697aad24a7939eebe31d3b279b543e19e837675b76cc55ed57", "ref_doc_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2"}, "651cff8d-fc10-48e7-b61e-6074e79ee3d6": {"doc_hash": "640abf7ae3106bf7323c24b2200efdb4b1bf7b79ec10cc4c00cd0522617071f2", "ref_doc_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2"}, "7c7aeffe-b326-4210-a639-d01747eaf06e": {"doc_hash": "59da5a0f1ce662adbb0edb5ab768451d21cc7f543cd4ad9c0c38b16e704fdfc2", "ref_doc_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2"}, "c9caaf17-3217-43d9-b60c-ad6711492f44": {"doc_hash": "f1e22db8e63baa30abe5a13bccef75247fe95a6e1e4f774b17032c9a222d2e40", "ref_doc_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2"}, "75550e7a-fcc4-4afd-9d80-6c7369b3a556": {"doc_hash": "2dc769c39b14f489c02dd28882baebf2abdd56924cdb36ce8f75cd8dd46a630a", "ref_doc_id": "1c4c4105-e3b3-4259-ae47-6e4fb671c1e2"}}}