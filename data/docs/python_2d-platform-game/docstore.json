{"docstore/data": {"a6303aeb-7720-4b5d-9e11-7c6b2c7d9370": {"__data__": {"id_": "a6303aeb-7720-4b5d-9e11-7c6b2c7d9370", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62be5535-85b4-41cd-bd37-59d3b95c8502", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "4040fd2603ef8f343f8ba917a04ac01f151a68ea19c02128f07084a9e6821407", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cfc99e8e-9c82-4c2e-ad59-183ca8e025a0", "node_type": "1", "metadata": {}, "hash": "aac9d7fcca1c74d6bad4219ca0f367cc111acfcb9eb676435b4023f1775ca49a", "class_name": "RelatedNodeInfo"}}, "hash": "7681784dc6b0a21ff6df5b63a3e7219a3c7b7a945bdf73c58538354e64667a34", "text": "__init__\n\nself\n\nimage\n\nstartx\n\nstarty\n\nsuper\n\n__init__\n\nself\n\nimage\n\npygame\n\nimage\n\nload\n\nimage\n\nself\n\nrect\n\nself\n\nimage\n\nget_rect\n\nself\n\nrect\n\ncenter\n\nstartx\n\nstarty\n\ndef\n\nupdate\n\nself\n\npass\n\ndef\n\ndraw\n\nself\n\nscreen\n\nscreen\n\nblit\n\nself\n\nimage\n\nself\n\nrect\n\ndef\n\nmain\n\nAs this class will be the parent for all other objects in our game, we're keeping it quite simple. It has three methods:\n\n__init__, which will create the sprite with a given image and a PyGame rectangle based on that image. This rectangle will initially be placed at the position specified by startx and starty. The sprite's rectangle is what PyGame will use for sprite movement and collision detection.\n\nupdate, which we'll use in child classes to handle events, such as key presses, gravity and collisions.\n\ndraw, which we use to draw the sprite. We do this by blitting it onto the screen.\n\nNow we can create our Player and Box objects as child classes of Sprite:\n\nclass\n\nSprite\n\npygame\n\nsprite\n\nSprite\n\n# ...\n\nclass\n\nPlayer\n\nSprite\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\nsuper\n\n__init__\n\n\"p1_front.png\"\n\nstartx\n\nstarty\n\nclass\n\nBox\n\nSprite\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\nsuper\n\n__init__\n\n\"boxAlt.png\"\n\nstartx\n\nstarty\n\ndef\n\nmain\n\nWe'll add more code to the player later, but first let's draw these sprites on the screen.\n\nDrawing the sprites\u200b\n\nLet's go back to our main function and create our sprites. We'll start with the player:\n\ndef\n\nmain\n\npygame\n\ninit\n\nscreen\n\npygame\n\ndisplay\n\nset_mode\n\nWIDTH\n\nHEIGHT\n\nclock\n\npygame\n\ntime\n\nClock\n\nplayer\n\nPlayer\n\n100\n\n200\n\nThen we need to put boxes under the player's feet. As we will be placing multiple sprites, we'll create a PyGame sprite group to put them in.\n\nplayer\n\nPlayer\n\n100\n\n200\n\nboxes\n\npygame\n\nsprite\n\nGroup\n\nOur box sprites are 70 pixels wide, and we need to span over the screen width of 400 pixels. We can do this in a for loop using Python's range:\n\nplayer\n\nPlayer\n\n100\n\n200\n\nboxes\n\npygame\n\nsprite\n\nGroup\n\nfor\n\nbx\n\nin\n\nrange\n\n400\n\n70\n\nboxes\n\nadd\n\nBox\n\nbx\n\n300\n\nNow we need to go back to the game loop and add some code to make things happen. First, we'll have PyGame put new events on the event queue, and then we'll call the player's update function. This function will handle the events generated by pygame.event.pump().\n\nwhile\n\nTrue\n\npygame\n\nevent\n\npump\n\nplayer\n\nupdate\n\n# ...\n\nFor a more complex game, we would want to loop through a number of sprites and call each one's update method, but for now just doing this with the player is sufficient. Our boxes won't have any dynamic behavior, so there's no need to call their update methods.\n\nIn contrast to update, we need all our sprites to draw themselves. After drawing the background, we'll add a call to the player's draw method. To draw the boxes, we can call PyGame's Group.draw on our boxes group.\n\nwhile\n\nTrue\n\npygame\n\nevent\n\npump\n\nplayer\n\nupdate\n\n# Draw loop\n\nscreen\n\nfill\n\nBACKGROUND\n\nplayer\n\ndraw\n\nscreen\n\nboxes\n\ndraw\n\nscreen\n\npygame\n\ndisplay\n\nflip\n\nclock\n\ntick\n\n60\n\nOur game loop is now set up to update and draw every sprite in the game in each cycle of the game loop. If you run the game now, you should see both the player and the line of boxes on the screen.\n\nNext, we're going to add some user interaction.\n\nMaking the Player Walk\u200b\n\nLet's return to the Player object and make it mobile. We'll move the player using pygame.Rect.move_ip, which moves a given rectangle by a given vector. This will be wrapped in a move method, to simplify our code. Create this method now:\n\nclass\n\nPlayer\n\nSprite\n\n# ...\n\ndef\n\nmove\n\nself\n\nself\n\nrect\n\nmove_ip\n\nNow that we have a way to move the player, it's time to add an update method so that this movement can be triggered by key presses.", "start_char_idx": 0, "end_char_idx": 3670, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cfc99e8e-9c82-4c2e-ad59-183ca8e025a0": {"__data__": {"id_": "cfc99e8e-9c82-4c2e-ad59-183ca8e025a0", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62be5535-85b4-41cd-bd37-59d3b95c8502", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "4040fd2603ef8f343f8ba917a04ac01f151a68ea19c02128f07084a9e6821407", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a6303aeb-7720-4b5d-9e11-7c6b2c7d9370", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "7681784dc6b0a21ff6df5b63a3e7219a3c7b7a945bdf73c58538354e64667a34", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c493cce-27fd-4e90-91bb-a37cefdadacd", "node_type": "1", "metadata": {}, "hash": "85a7c7428fac173952a4de7d33687944f527a3a06bb8b2f18f11db0ece506b3e", "class_name": "RelatedNodeInfo"}}, "hash": "aac9d7fcca1c74d6bad4219ca0f367cc111acfcb9eb676435b4023f1775ca49a", "text": "If you run the game now, you should see both the player and the line of boxes on the screen.\n\nNext, we're going to add some user interaction.\n\nMaking the Player Walk\u200b\n\nLet's return to the Player object and make it mobile. We'll move the player using pygame.Rect.move_ip, which moves a given rectangle by a given vector. This will be wrapped in a move method, to simplify our code. Create this method now:\n\nclass\n\nPlayer\n\nSprite\n\n# ...\n\ndef\n\nmove\n\nself\n\nself\n\nrect\n\nmove_ip\n\nNow that we have a way to move the player, it's time to add an update method so that this movement can be triggered by key presses. Add an empty update method now:\n\nclass\n\nPlayer\n\nSprite\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\nsuper\n\n__init__\n\n\"p1_front.png\"\n\nstartx\n\nstarty\n\ndef\n\nupdate\n\nself\n\npass\n\ndef\n\nmove\n\nself\n\nself\n\nrect\n\nmove_ip\n\nPyGame provides a couple of different ways to check the state of the keyboard. By default, its event queue collects KEY_DOWN and KEY_UP events when particular keys are pressed and released. Using a KEY_DOWN event to move the player seems like the logical thing to do, but because the event is only triggered in same update loop in which the key is first pressed, this would force us to rapidly tap an arrow key to keep moving in a single direction.\n\nWe need a way to move the player whenever an arrow key is held down, not just after it's pressed. So instead of relying on events, we will query the current status of all keyboard keys with pygame.key.get_pressed():\n\ndef\n\nupdate\n\nself\n\n# check keys\n\nkey\n\npygame\n\nkey\n\nget_pressed\n\nThis method returns a tuple of 0s and 1s showing the pressed status of each key on the keyboard. We can thus detect whether the left or right arrow key is currently pressed by indexing the tuple with PyGame's keyboard constants, like so:\n\ndef\n\nupdate\n\nself\n\n# check keys\n\nkey\n\npygame\n\nkey\n\nget_pressed\n\nif\n\nkey\n\npygame\n\nK_LEFT\n\nself\n\nmove\n\nelif\n\nkey\n\npygame\n\nK_RIGHT\n\nself\n\nmove\n\nRun the game. You should now be able to move the player left and right, albeit very slowly. Let's speed things up and reduce our code's reliance on magic numbers at the same time by giving the player a speed variable.\n\nclass\n\nPlayer\n\nSprite\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\nsuper\n\n__init__\n\n\"p1_front.png\"\n\nstartx\n\nstarty\n\nself\n\nspeed\n\ndef\n\nupdate\n\nself\n\n# check keys\n\nkey\n\npygame\n\nkey\n\nget_pressed\n\nif\n\nkey\n\npygame\n\nK_LEFT\n\nself\n\nmove\n\nself\n\nspeed\n\nelif\n\nkey\n\npygame\n\nK_RIGHT\n\nself\n\nmove\n\nself\n\nspeed\n\nRight now the player glides from side to side, but we have already uploaded images for a walk cycle animation, so let's implement that now. First, we'll add some image loading code to our player's __init__ method:\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\nsuper\n\n__init__\n\n\"p1_front.png\"\n\nstartx\n\nstarty\n\nself\n\nstand_image\n\nself\n\nimage\n\nself\n\nwalk_cycle\n\npygame\n\nimage\n\nload\n\nf\"p1_walk\n\n0>2\n\n.png\"\n\nfor\n\nin\n\nrange\n\n12\n\nself\n\nanimation_index\n\nself\n\nfacing_left\n\nFalse\n\nself\n\nspeed\n\nstring formatting to get the correct filename format (\n\nNow let's implement the actual animation. Create a new method called walk_animation:\n\nclass\n\nPlayer\n\nSprite\n\n# ...\n\ndef\n\nwalk_animation\n\nself\n\nself\n\nimage\n\nself\n\nwalk_cycle\n\nself\n\nanimation_index\n\nif\n\nself\n\nfacing_left\n\nself\n\nimage\n\npygame\n\ntransform\n\nflip\n\nself\n\nimage\n\nTrue\n\nFalse\n\nif\n\nself\n\nanimation_index\n\nlen\n\nself\n\nwalk_cycle\n\nself\n\nanimation_index\n\n+=\n\nelse\n\nself\n\nanimation_index\n\nHere we're setting the player's current image to the frame of the walk cycle we're currently on. If the player is facing left, we use pygame.transform.flip to horizontally flip his sprite (the last two arguments are for horizontal and vertical flipping, respectively). Then we animate the player by incrementing the animation_index, unless the animation is in its penultimate frame, in which case we return to the start of the animation.", "start_char_idx": 3065, "end_char_idx": 6855, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c493cce-27fd-4e90-91bb-a37cefdadacd": {"__data__": {"id_": "5c493cce-27fd-4e90-91bb-a37cefdadacd", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62be5535-85b4-41cd-bd37-59d3b95c8502", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "4040fd2603ef8f343f8ba917a04ac01f151a68ea19c02128f07084a9e6821407", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cfc99e8e-9c82-4c2e-ad59-183ca8e025a0", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "aac9d7fcca1c74d6bad4219ca0f367cc111acfcb9eb676435b4023f1775ca49a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "faab8e88-49e4-487d-8273-1022d19936cc", "node_type": "1", "metadata": {}, "hash": "40b013c9c4ad5fc8b00681f2d769616a79db9754ec8a9d65c836fd190bc831cd", "class_name": "RelatedNodeInfo"}}, "hash": "85a7c7428fac173952a4de7d33687944f527a3a06bb8b2f18f11db0ece506b3e", "text": "Create a new method called walk_animation:\n\nclass\n\nPlayer\n\nSprite\n\n# ...\n\ndef\n\nwalk_animation\n\nself\n\nself\n\nimage\n\nself\n\nwalk_cycle\n\nself\n\nanimation_index\n\nif\n\nself\n\nfacing_left\n\nself\n\nimage\n\npygame\n\ntransform\n\nflip\n\nself\n\nimage\n\nTrue\n\nFalse\n\nif\n\nself\n\nanimation_index\n\nlen\n\nself\n\nwalk_cycle\n\nself\n\nanimation_index\n\n+=\n\nelse\n\nself\n\nanimation_index\n\nHere we're setting the player's current image to the frame of the walk cycle we're currently on. If the player is facing left, we use pygame.transform.flip to horizontally flip his sprite (the last two arguments are for horizontal and vertical flipping, respectively). Then we animate the player by incrementing the animation_index, unless the animation is in its penultimate frame, in which case we return to the start of the animation.\n\nLet's add this to our update method now:\n\ndef\n\nupdate\n\nself\n\n# ...\n\n# check keys\n\nkey\n\npygame\n\nkey\n\nget_pressed\n\nif\n\nkey\n\npygame\n\nK_LEFT\n\nself\n\nfacing_left\n\nTrue\n\nself\n\nwalk_animation\n\nself\n\nmove\n\nself\n\nspeed\n\nelif\n\nkey\n\npygame\n\nK_RIGHT\n\nself\n\nfacing_left\n\nFalse\n\nself\n\nwalk_animation\n\nself\n\nmove\n\nself\n\nspeed\n\nelse\n\nself\n\nimage\n\nself\n\nstand_image\n\nIf we're moving left or right, we set self.facing_left appropriately and call self.walk_animation. Otherwise, we set the player's image to self.stand_image.\n\nRun the game now to see the player's walk cycle in motion. After that, it's time to make him jump.\n\nMaking the Player Jump\u200b\n\nFor our player to be able to jump, we need to implement four things:\n\nUpward motion triggered by the up arrow key.\n\nGravity, to bring the player back down after reaching the top of his jump.\n\nCollision detection, so the player doesn't fall through the ground.\n\nA jumping animation.\n\nTriggering the jump\u200b\n\nTo simply make the player move up, we can just add another elif, like so:\n\ndef\n\nupdate\n\nself\n\n# ...\n\nif\n\nkey\n\npygame\n\nK_LEFT\n\nself\n\nfacing_left\n\nTrue\n\nself\n\nwalk_animation\n\nself\n\nmove\n\nself\n\nspeed\n\nelif\n\nkey\n\npygame\n\nK_RIGHT\n\nself\n\nfacing_left\n\nFalse\n\nself\n\nwalk_animation\n\nself\n\nmove\n\nself\n\nspeed\n\nelif\n\nkey\n\npygame\n\nK_UP\n\nself\n\nmove\n\nself\n\nspeed\n\nelse\n\nself\n\nimage\n\nself\n\nstand_image\n\nIf you try the game now, you should notice a couple of problems with this approach. Besides the lack of gravity, we can only jump straight up, and must release the left and right arrow keys before we may do so. Much of the gameplay in platformers is reliant on the player's ability to jump to the left or right, so this won't do. To fix this, we'll change our last elif to a separate if statement:\n\nif\n\nkey\n\npygame\n\nK_LEFT\n\nself\n\nfacing_left\n\nTrue\n\nself\n\nwalk_animation\n\nself\n\nmove\n\nself\n\nspeed\n\nelif\n\nkey\n\npygame\n\nK_RIGHT\n\nself\n\nfacing_left\n\nFalse\n\nself\n\nwalk_animation\n\nself\n\nmove\n\nself\n\nspeed\n\nelse\n\nself\n\nimage\n\nself\n\nstand_image\n\nif\n\nkey\n\npygame\n\nK_UP\n\nself\n\nmove\n\nself\n\nspeed\n\nWe also probably want to be able to jump at a different speed to our walking pace, so let's define another variable and use it.\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\n# ...\n\nself\n\nspeed\n\nself\n\njumpspeed\n\n20\n\ndef\n\nupdate\n\nself\n\n# ...\n\nif\n\nkey\n\npygame\n\nK_UP\n\nself\n\nmove\n\nself\n\njumpspeed\n\nThat's better, but now we really need some gravity!\n\nAdding gravity\u200b\n\nUp until now, we've had only a single operation manipulating our horizontal or vertical speed per update loop. With the addition of gravity, this will change, so we need to restructure our code to calculate our net horizontal and vertical movement before calling move.", "start_char_idx": 6070, "end_char_idx": 9487, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "faab8e88-49e4-487d-8273-1022d19936cc": {"__data__": {"id_": "faab8e88-49e4-487d-8273-1022d19936cc", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62be5535-85b4-41cd-bd37-59d3b95c8502", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "4040fd2603ef8f343f8ba917a04ac01f151a68ea19c02128f07084a9e6821407", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c493cce-27fd-4e90-91bb-a37cefdadacd", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "85a7c7428fac173952a4de7d33687944f527a3a06bb8b2f18f11db0ece506b3e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f1c9da16-5ea6-4792-b602-e23645d8f510", "node_type": "1", "metadata": {}, "hash": "8e92135c89cc981f1eb903a86b569d77a04bcdb9ff3deb6d372d4bc95f5ec0da", "class_name": "RelatedNodeInfo"}}, "hash": "40b013c9c4ad5fc8b00681f2d769616a79db9754ec8a9d65c836fd190bc831cd", "text": "def\n\n__init__\n\nself\n\nstartx\n\nstarty\n\n# ...\n\nself\n\nspeed\n\nself\n\njumpspeed\n\n20\n\ndef\n\nupdate\n\nself\n\n# ...\n\nif\n\nkey\n\npygame\n\nK_UP\n\nself\n\nmove\n\nself\n\njumpspeed\n\nThat's better, but now we really need some gravity!\n\nAdding gravity\u200b\n\nUp until now, we've had only a single operation manipulating our horizontal or vertical speed per update loop. With the addition of gravity, this will change, so we need to restructure our code to calculate our net horizontal and vertical movement before calling move. Let's change the update function like so:\n\ndef\n\nupdate\n\nself\n\nhsp\n\n# horizontal speed\n\nvsp\n\n# vertical speed\n\n# check keys\n\nkey\n\npygame\n\nkey\n\nget_pressed\n\nif\n\nkey\n\npygame\n\nK_LEFT\n\nself\n\nfacing_left\n\nTrue\n\nself\n\nwalk_animation\n\nhsp\n\nself\n\nspeed\n\nelif\n\nkey\n\npygame\n\nK_RIGHT\n\nself\n\nfacing_left\n\nFalse\n\nself\n\nwalk_animation\n\nhsp\n\nself\n\nspeed\n\nelse\n\nself\n\nimage\n\nself\n\nstand_image\n\nif\n\nkey\n\npygame\n\nK_UP\n\nvsp\n\nself\n\njumpspeed\n\n# movement\n\nself\n\nmove\n\nhsp\n\nvsp\n\nWe've added two variables, hsp and vsp, to represent our horizontal speed and vertical speed. Instead of calling move when each key is pressed, we work with these variables throughout the update method and then pass their final values into a single move call at the end.\n\nBut wait! It makes sense for horizontal speed to be set to 0 at the start of every update loop, because it is directly controlled by the player's key presses. When the left arrow is held down, the player moves left at a speed of 4 pixels per loop; when the left arrow is released, the player instantly stops. Vertical speed will be less controllable \u2013 while pressing the up arrow will initiate a jump, releasing it should not stop the player in mid-air. Therefore, vertical speed must persist between loops.\n\nWe can accomplish this by moving the vsp definition into __init__ and making it an instance variable.\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\n# ...\n\nself\n\nvsp\n\n# vertical speed\n\ndef\n\nupdate\n\nself\n\nhsp\n\n# horizontal speed\n\n# ...\n\nif\n\nkey\n\npygame\n\nK_UP\n\nself\n\nvsp\n\nself\n\njumpspeed\n\n# movement\n\nself\n\nmove\n\nhsp\n\nself\n\nvsp\n\nNow we can implement gravity. We'll do this by adding a small constant to the player's vertical speed (vsp) until it reaches terminal velocity.\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\n# ...\n\nself\n\ngravity\n\ndef\n\nupdate\n\nself\n\n# ...\n\nif\n\nkey\n\npygame\n\nK_UP\n\nself\n\nvsp\n\nself\n\njumpspeed\n\n# gravity\n\nif\n\nself\n\nvsp\n\n10\n\n# 9.8 rounded up\n\nself\n\nvsp\n\n+=\n\nself\n\ngravity\n\n# movement\n\nself\n\nmove\n\nhsp\n\nself\n\nvsp\n\nStart up the game now, and the player will fall straight down, through the ground and off the screen. Gravity's working, but we need somewhere for the player to land.\n\nAdding collision detection\u200b\n\nCollision detection is a key element of most graphical games. In PyGame, the bulk of collision detection involves checking whether rectangles intersect with each other. Luckily, PyGame provides a number of useful built-ins for doing this, so we won't have to think too much about the internal workings of collisions.\n\nLet's add some collision detection now, near the top of our update method. We'll create a variable called onground and set it to the result of pygame.sprite.spritecollideany().\n\ndef\n\nupdate\n\nself\n\nhsp\n\n# horizontal speed\n\nonground\n\npygame\n\nsprite\n\nspritecollideany\n\nself\n\nboxes\n\nThis PyGame method takes two arguments: a single sprite and a group of sprites. It returns whether the sprite given as the first argument, i.e. the player, has a collision with any of the sprites in the group given as the second argument, i.e. the boxes. So we'll know that the player is on a box when it returns True.", "start_char_idx": 8993, "end_char_idx": 12554, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f1c9da16-5ea6-4792-b602-e23645d8f510": {"__data__": {"id_": "f1c9da16-5ea6-4792-b602-e23645d8f510", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62be5535-85b4-41cd-bd37-59d3b95c8502", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "4040fd2603ef8f343f8ba917a04ac01f151a68ea19c02128f07084a9e6821407", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "faab8e88-49e4-487d-8273-1022d19936cc", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "40b013c9c4ad5fc8b00681f2d769616a79db9754ec8a9d65c836fd190bc831cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2ec0eb41-6b0e-424f-a04e-5ffd5359070a", "node_type": "1", "metadata": {}, "hash": "a9ab47c5cf4ec419ca2525401e4751cec72b42eb30a6cf32bae912d036654e48", "class_name": "RelatedNodeInfo"}}, "hash": "8e92135c89cc981f1eb903a86b569d77a04bcdb9ff3deb6d372d4bc95f5ec0da", "text": "In PyGame, the bulk of collision detection involves checking whether rectangles intersect with each other. Luckily, PyGame provides a number of useful built-ins for doing this, so we won't have to think too much about the internal workings of collisions.\n\nLet's add some collision detection now, near the top of our update method. We'll create a variable called onground and set it to the result of pygame.sprite.spritecollideany().\n\ndef\n\nupdate\n\nself\n\nhsp\n\n# horizontal speed\n\nonground\n\npygame\n\nsprite\n\nspritecollideany\n\nself\n\nboxes\n\nThis PyGame method takes two arguments: a single sprite and a group of sprites. It returns whether the sprite given as the first argument, i.e. the player, has a collision with any of the sprites in the group given as the second argument, i.e. the boxes. So we'll know that the player is on a box when it returns True.\n\nWe can pass the boxes group into the player's update method by making a couple of code changes:\n\ndef\n\nupdate\n\nself\n\nboxes\n\nhsp\n\n# horizontal speed\n\nonground\n\npygame\n\nsprite\n\nspritecollideany\n\nself\n\nboxes\n\n# ...\n\ndef\n\nmain\n\n# ...\n\nwhile\n\nTrue\n\npygame\n\nevent\n\npump\n\nplayer\n\nupdate\n\nboxes\n\nNow that we can tell whether the player is on the ground, we can prevent jumping in mid-air by adding a condition to our jump code:\n\ndef\n\nupdate\n\nself\n\nboxes\n\n# ...\n\nif\n\nkey\n\npygame\n\nK_UP\n\nand\n\nonground\n\nself\n\nvsp\n\nself\n\njumpspeed\n\nTo stop the player from falling through the ground, we'll add the following code to our gravity implementation:\n\ndef\n\nupdate\n\nself\n\nboxes\n\n# ...\n\n# gravity\n\nif\n\nself\n\nvsp\n\n10\n\nand\n\nnot\n\nonground\n\n# 9.8: rounded up\n\nself\n\nvsp\n\n+=\n\nself\n\ngravity\n\n# stop falling when the ground is reached\n\nif\n\nself\n\nvsp\n\nand\n\nonground\n\nself\n\nvsp\n\nAdding a jumping animation\u200b\n\nLastly, we'll use our last alien image (p1_jump.png) to give our player a jumping animation. First create self.jump_image in __init__:\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\nsuper\n\n__init__\n\n\"p1_front.png\"\n\nstartx\n\nstarty\n\nself\n\nstand_image\n\nself\n\nimage\n\nself\n\njump_image\n\npygame\n\nimage\n\nload\n\n\"p1_jump.png\"\n\n# ...\n\nThen create the following Player method:\n\ndef\n\njump_animation\n\nself\n\nself\n\nimage\n\nself\n\njump_image\n\nif\n\nself\n\nfacing_left\n\nself\n\nimage\n\npygame\n\ntransform\n\nflip\n\nself\n\nimage\n\nTrue\n\nFalse\n\nOur jump animation only has one frame, so the code is much simpler than what we used for our walking animation. To trigger this method when the player is in the air, alter the gravity implementation like so:\n\ndef\n\nupdate\n\nself\n\nboxes\n\n# ...\n\n# gravity\n\nif\n\nself\n\nvsp\n\n10\n\nand\n\nnot\n\nonground\n\n# 9.8 rounded up\n\nself\n\njump_animation\n\nself\n\nvsp\n\n+=\n\nself\n\ngravity\n\nRun the game, and you should be able to run and jump! Be careful not to fall off the edge.\n\nRefining the Game\u200b\n\nAt this point, we have our game working on a basic level, but it could use some refinements. First, the jumping is quite unresponsive to user input: pressing the up arrow for any length of time results in the same size jump. Second, our collision detection will only prevent the player from falling through the floor, not walking through walls or jumping through the ceiling.\n\nWe're going to iterate on our code to fix both of these shortcomings.\n\nMaking jumps variable\u200b\n\nIt would be nice if the player could control the height of their jump by holding the jump key down for different lengths of time. This is fairly simple to implement \u2013 we just need a way to reduce the speed of a jump if the player releases the jump key while the player is still moving up. Add the following code to the player's __init__ method.\n\nclass\n\nPlayer\n\nSprite\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\n# ...\n\nself\n\nmin_jumpspeed\n\nself\n\nprev_key\n\npygame\n\nkey\n\nget_pressed\n\nHere we've added a prev_key instance variable that will track the state of the keyboard in the previous update loop, and a min_jumpspeed variable, which will be the smallest jump we'll allow the player to do, by just tapping the jump key.", "start_char_idx": 11701, "end_char_idx": 15595, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ec0eb41-6b0e-424f-a04e-5ffd5359070a": {"__data__": {"id_": "2ec0eb41-6b0e-424f-a04e-5ffd5359070a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62be5535-85b4-41cd-bd37-59d3b95c8502", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "4040fd2603ef8f343f8ba917a04ac01f151a68ea19c02128f07084a9e6821407", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f1c9da16-5ea6-4792-b602-e23645d8f510", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "8e92135c89cc981f1eb903a86b569d77a04bcdb9ff3deb6d372d4bc95f5ec0da", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b621e3d7-b4b5-43cc-91ae-2a6702b5c23b", "node_type": "1", "metadata": {}, "hash": "e358f204cc22170e78c23d82c689ef3ac4edbd4d14f58b9943995672568ca616", "class_name": "RelatedNodeInfo"}}, "hash": "a9ab47c5cf4ec419ca2525401e4751cec72b42eb30a6cf32bae912d036654e48", "text": "We're going to iterate on our code to fix both of these shortcomings.\n\nMaking jumps variable\u200b\n\nIt would be nice if the player could control the height of their jump by holding the jump key down for different lengths of time. This is fairly simple to implement \u2013 we just need a way to reduce the speed of a jump if the player releases the jump key while the player is still moving up. Add the following code to the player's __init__ method.\n\nclass\n\nPlayer\n\nSprite\n\ndef\n\n__init__\n\nself\n\nstartx\n\nstarty\n\n# ...\n\nself\n\nmin_jumpspeed\n\nself\n\nprev_key\n\npygame\n\nkey\n\nget_pressed\n\nHere we've added a prev_key instance variable that will track the state of the keyboard in the previous update loop, and a min_jumpspeed variable, which will be the smallest jump we'll allow the player to do, by just tapping the jump key.\n\nNow let's add variable jumping to the update method, between the code that handles the up arrow key and the code that handles gravity:\n\ndef\n\nupdate\n\nself\n\nboxes\n\n# ...\n\nif\n\nkey\n\npygame\n\nK_UP\n\nand\n\nonground\n\nself\n\nvsp\n\nself\n\njumpspeed\n\n# variable height jumping\n\nif\n\nself\n\nprev_key\n\npygame\n\nK_UP\n\nand\n\nnot\n\nkey\n\npygame\n\nK_UP\n\nif\n\nself\n\nvsp\n\nself\n\nmin_jumpspeed\n\nself\n\nvsp\n\nself\n\nmin_jumpspeed\n\nself\n\nprev_key\n\nkey\n\n# gravity\n\nif\n\nself\n\nvsp\n\n10\n\n# 9.8 rounded up\n\nself\n\nvsp\n\n+=\n\nself\n\ngravity\n\nThe if statement we've just added will evaluate to True if the up arrow key was pressed in the previous loop but is not longer pressed, i.e. it has been released. When that happens, we cut off the player's jump by reducing its speed to the min_jumpspeed. We then set self.prev_key to the current keyboard state in preparation for the next loop.\n\nTry the game now, and you should notice a different height of jump when lightly tap the up arrow key versus when you hold it down. Play around with the value of min_jumpspeed and see what difference it makes.\n\nRefining collision detection\u200b\n\nAs mentioned above, the only collision detection we've implemented applies to the ground beneath the player's feet, so he will be able to walk through walls and jump through ceilings. See this for yourself by adding some boxes above and next to the player in the main method.\n\ndef\n\nmain\n\n# ...\n\nboxes\n\npygame\n\nsprite\n\ngroup\n\nfor\n\nbx\n\nin\n\nrange\n\n400\n\n70\n\nboxes\n\nadd\n\nBox\n\nbx\n\n300\n\nboxes\n\nadd\n\nBox\n\n330\n\n230\n\nboxes\n\nadd\n\nBox\n\n100\n\n70\n\nAnother issue that you may have already noticed is that the player sinks into the ground after some jumps \u2013 this results from the imprecision of our collision detection.\n\nWe're going to fix these problems by making a subtle change to how we deal with collisions with boxes. Rather than deciding that we're on the ground when the player sprite is in collision with a box, we'll check whether the player is 1 pixel above a collision with a box. We'll then apply the same principle for left, right and up, stopping the player just before a collision.\n\nFirst, let's give the player a check_collision method to make these checks:\n\nclass\n\nPlayer\n\nSprite\n\n# ...\n\ndef\n\ncheck_collision\n\nself\n\nboxes\n\nself\n\nrect\n\nmove_ip\n\ncollide\n\npygame\n\nsprite\n\nspritecollideany\n\nself\n\nboxes\n\nself\n\nrect\n\nmove_ip\n\nreturn\n\ncollide\n\nHere, we're moving the player by a specified amount, checking for a collision, and then moving the player back. This back and forth movement happens before the player is drawn to the screen, so the user won't notice anything.\n\nLet's change our onground check to use this method:\n\ndef\n\nupdate\n\nself\n\nboxes\n\nhsp\n\nonground\n\nself\n\ncheck_collision\n\nboxes\n\nRun the game now, and you may be able to notice a very slight difference in how the player stands on the ground from before.\n\nThis doesn't yet solve our horizontal and upward collisions problems, though. For that, we'll need to implement our new check_collision method directly into the player's move method.", "start_char_idx": 14786, "end_char_idx": 18574, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b621e3d7-b4b5-43cc-91ae-2a6702b5c23b": {"__data__": {"id_": "b621e3d7-b4b5-43cc-91ae-2a6702b5c23b", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "62be5535-85b4-41cd-bd37-59d3b95c8502", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "4040fd2603ef8f343f8ba917a04ac01f151a68ea19c02128f07084a9e6821407", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2ec0eb41-6b0e-424f-a04e-5ffd5359070a", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}, "hash": "a9ab47c5cf4ec419ca2525401e4751cec72b42eb30a6cf32bae912d036654e48", "class_name": "RelatedNodeInfo"}}, "hash": "e358f204cc22170e78c23d82c689ef3ac4edbd4d14f58b9943995672568ca616", "text": "This back and forth movement happens before the player is drawn to the screen, so the user won't notice anything.\n\nLet's change our onground check to use this method:\n\ndef\n\nupdate\n\nself\n\nboxes\n\nhsp\n\nonground\n\nself\n\ncheck_collision\n\nboxes\n\nRun the game now, and you may be able to notice a very slight difference in how the player stands on the ground from before.\n\nThis doesn't yet solve our horizontal and upward collisions problems, though. For that, we'll need to implement our new check_collision method directly into the player's move method. The first thing we'll need to do is prepare the x and y parameters for additional processing:\n\ndef\n\nmove\n\nself\n\ndx\n\ndy\n\nself\n\nrect\n\nmove_ip\n\ndx\n\ndy\n\ndef\n\nupdate\n\nself\n\nboxes\n\n# ...\n\n# movement\n\nself\n\nmove\n\nhsp\n\nself\n\nvsp\n\nboxes\n\ndef\n\nmove\n\nself\n\nboxes\n\ndx\n\ndy\n\nwhile\n\nself\n\ncheck_collision\n\ndy\n\nboxes\n\ndy\n\n=\n\nself\n\nrect\n\nmove_ip\n\ndx\n\ndy\n\nBut wait! This code will only work as intended if we're moving down and dy is positive. If dy is negative, this will just move us further into a collision, not away from it. To fix this, we'll need to import numpy at the top of our file, so we can use numpy.sign.\n\nimport\n\npygame\n\nnumpy\n\n# ...\n\nnumpy.sign takes an integer and returns 1 if it's positive, -1 if it's negative, and 0 if it's 0. This is exactly the functionality we need!\n\ndef\n\nmove\n\nself\n\nboxes\n\ndx\n\ndy\n\nwhile\n\nself\n\ncheck_collision\n\ndy\n\nboxes\n\ndy\n\n=\n\nnumpy\n\nsign\n\ndy\n\nself\n\nrect\n\nmove_ip\n\ndx\n\ndy\n\nNow do the same for dx. As we've already figured out the appropriate dy for our movement, we'll include that in the collision check.\n\ndef\n\nmove\n\nself\n\nboxes\n\ndx\n\ndy\n\nwhile\n\nself\n\ncheck_collision\n\ndy\n\nboxes\n\ndy\n\n=\n\nnumpy\n\nsign\n\ndy\n\nwhile\n\nself\n\ncheck_collision\n\ndx\n\ndy\n\nboxes\n\ndx\n\n=\n\nnumpy\n\nsign\n\ndx\n\nself\n\nrect\n\nmove_ip\n\ndx\n\ndy\n\nRun the game. The player should now stop when he runs into a wall or jumps into a ceiling.\n\nWhere Next?\u200b\n\nIf you'd like to continue working on this game, you can find a large number of matching art assets here. Try implementing some of these features:\n\nMore jump refinements, such as jump grace time and input buffering.\n\nMoving platforms.\n\nSlopes.\n\nWater and swimming mechanics.\n\nHazards like spike pits and enemies who are also subject to gravity.\n\nDouble jumping.\n\nYou can find our game repl below:\n\n< Previous: Discord RPG bot with Python\n\nNext: Audio: create a media player >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting StartedSetting up the scaffoldingDrawing the sprites\n\nMaking the Player Walk\n\nMaking the Player JumpTriggering the jumpAdding gravityAdding collision detectionAdding a jumping animation\n\nRefining the GameMaking jumps variableRefining collision detection\n\nWhere Next?", "start_char_idx": 18027, "end_char_idx": 20710, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"62be5535-85b4-41cd-bd37-59d3b95c8502": {"node_ids": ["a6303aeb-7720-4b5d-9e11-7c6b2c7d9370", "cfc99e8e-9c82-4c2e-ad59-183ca8e025a0", "5c493cce-27fd-4e90-91bb-a37cefdadacd", "faab8e88-49e4-487d-8273-1022d19936cc", "f1c9da16-5ea6-4792-b602-e23645d8f510", "2ec0eb41-6b0e-424f-a04e-5ffd5359070a", "b621e3d7-b4b5-43cc-91ae-2a6702b5c23b"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/2d-platform-game.html"}}}, "docstore/metadata": {"a6303aeb-7720-4b5d-9e11-7c6b2c7d9370": {"doc_hash": "7681784dc6b0a21ff6df5b63a3e7219a3c7b7a945bdf73c58538354e64667a34", "ref_doc_id": "62be5535-85b4-41cd-bd37-59d3b95c8502"}, "cfc99e8e-9c82-4c2e-ad59-183ca8e025a0": {"doc_hash": "aac9d7fcca1c74d6bad4219ca0f367cc111acfcb9eb676435b4023f1775ca49a", "ref_doc_id": "62be5535-85b4-41cd-bd37-59d3b95c8502"}, "5c493cce-27fd-4e90-91bb-a37cefdadacd": {"doc_hash": "85a7c7428fac173952a4de7d33687944f527a3a06bb8b2f18f11db0ece506b3e", "ref_doc_id": "62be5535-85b4-41cd-bd37-59d3b95c8502"}, "faab8e88-49e4-487d-8273-1022d19936cc": {"doc_hash": "40b013c9c4ad5fc8b00681f2d769616a79db9754ec8a9d65c836fd190bc831cd", "ref_doc_id": "62be5535-85b4-41cd-bd37-59d3b95c8502"}, "f1c9da16-5ea6-4792-b602-e23645d8f510": {"doc_hash": "8e92135c89cc981f1eb903a86b569d77a04bcdb9ff3deb6d372d4bc95f5ec0da", "ref_doc_id": "62be5535-85b4-41cd-bd37-59d3b95c8502"}, "2ec0eb41-6b0e-424f-a04e-5ffd5359070a": {"doc_hash": "a9ab47c5cf4ec419ca2525401e4751cec72b42eb30a6cf32bae912d036654e48", "ref_doc_id": "62be5535-85b4-41cd-bd37-59d3b95c8502"}, "b621e3d7-b4b5-43cc-91ae-2a6702b5c23b": {"doc_hash": "e358f204cc22170e78c23d82c689ef3ac4edbd4d14f58b9943995672568ca616", "ref_doc_id": "62be5535-85b4-41cd-bd37-59d3b95c8502"}}}