{"docstore/data": {"52431303-98f3-4ab7-a588-0b920393d57e": {"__data__": {"id_": "52431303-98f3-4ab7-a588-0b920393d57e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35005b24-e309-4517-b837-29b950dc6a02", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "0d928e9a7275a2b713734684232cea31c4a9b343c6faa2ec09a5d2c2ee0cd0f5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "37176cb3-f568-4726-950d-ec042c5eae75", "node_type": "1", "metadata": {}, "hash": "ca044f69e07c5c7748abb065dc8754164245a46840707fb3d9cc17cd1cd5db29", "class_name": "RelatedNodeInfo"}}, "hash": "23ce3a9e84a4c6fcd2cf78753d3a110ee7b7759fb5ecfc52547bf06f830e2909", "text": "true\n\nfalse\n\nfalse\n\nfalse\n\ntrue\n\nlet\n\nrow3\n\nfalse\n\ntrue\n\nfalse\n\ntrue\n\nfalse\n\nlet\n\nrow4\n\ntrue\n\nfalse\n\ntrue\n\nfalse\n\ntrue\n\nThis is OK, but it would be nicer to have all the rows in a single construct, so we can easily manipulate and query it.\n\nOne solution is to use the array construct again. An array doesn't just need to be a list of single values, it can also be a list of arrays. So we can make an array for the grid, and each of its elements would be the row arrays:\n\nlet\n\ngrid\n\ntrue\n\ntrue\n\ntrue\n\nfalse\n\ntrue\n\ntrue\n\nfalse\n\nfalse\n\nfalse\n\ntrue\n\nfalse\n\ntrue\n\nfalse\n\ntrue\n\nfalse\n\ntrue\n\nfalse\n\ntrue\n\nfalse\n\ntrue\n\nNow this makes it easier to query the grid and manipulate it. For example, if we wanted to find out the value of the cell at row 2, column 3, we could do this:\n\nlet\n\nvalue\n\ngrid\n\nWe use [1] and [2] instead of [2] and [3] because arrays are zero-indexed. This means the first row is at index 0, and the first column is at index 0, so the first cell (1) is actually referenced as grid[0][0]\n\nWe can use the same notation when setting a cell value:\n\ngrid\n\ntrue\n\nImplementing the model\u200b\n\nNow that we've figured out how to model the grid, we can implement some functions to create and manipulate the grid.\n\nFirst, let's create a function to create a new grid. We'll call the grid a matrix in the code, as this is the mathematical term for it. Therefore our function is called createMatrix. It uses a global constant MATRIX_SIZE to determine the number of rows and columns of the matrix, and returns an array of arrays of the specified size, with all cells set to dead, or false. Add the code below to the main.js file:\n\nconst\n\nMATRIX_SIZE\n\n64\n\nfunction\n\ncreateMatrix\n\nconst\n\nmatrix\n\nnew\n\nArray\n\nMATRIX_SIZE\n\nfor\n\nvar\n\nmatrix\n\nlength\n\n++\n\nmatrix\n\nnew\n\nArray\n\nMATRIX_SIZE\n\nfill\n\nfalse\n\nreturn\n\nmatrix\n\nNote that we use the array constructor by calling new Array(MATRIX_SIZE) to create each array. The first call to the constructor creates the \"outer\" array, and then we use a for loop to repeatedly create the \"inner\", or row, arrays. To set the value of each cell in the row, we use the fill method on the row arrays. This method takes a single value, and sets all the values in the array to that value. We set all the values to false, or dead, to start.\n\nIn the Game of Life rules, there are multiple references to \"neighbor\" cells. Neighbors are any cells that touch a particular cell. For example, for the blue cell below, all the red cells are neighbors.\n\nIn particular, the rules refer to the number of \"live\" neighbors a cell has. A handy function to have would be one that finds all the neighbors of a particular cell, and counts how many of them are alive.\n\nNotice how each neighbor cell is one row or column away from the cell we are looking at. So if we create a function that looks at each cell one position away from the target cell and counts how many of those cells are alive, we can use this to find the number of neighbors a cell has.\n\nRecall that we can reference any cell in our matrix structure using the notation matrix[row_number][column_number]. So, noting that every neighbor is one position away, we can add or subtract one from the row and column numbers to find the neighbors.", "start_char_idx": 0, "end_char_idx": 3207, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "37176cb3-f568-4726-950d-ec042c5eae75": {"__data__": {"id_": "37176cb3-f568-4726-950d-ec042c5eae75", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35005b24-e309-4517-b837-29b950dc6a02", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "0d928e9a7275a2b713734684232cea31c4a9b343c6faa2ec09a5d2c2ee0cd0f5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "52431303-98f3-4ab7-a588-0b920393d57e", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "23ce3a9e84a4c6fcd2cf78753d3a110ee7b7759fb5ecfc52547bf06f830e2909", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b9d0a0c4-1526-4d8b-b465-7c4a2b77c0c1", "node_type": "1", "metadata": {}, "hash": "23fa27460929b232cf907950b0cb26c8487b2abc1e989697c4c3eafa09a3f5eb", "class_name": "RelatedNodeInfo"}}, "hash": "ca044f69e07c5c7748abb065dc8754164245a46840707fb3d9cc17cd1cd5db29", "text": "Neighbors are any cells that touch a particular cell. For example, for the blue cell below, all the red cells are neighbors.\n\nIn particular, the rules refer to the number of \"live\" neighbors a cell has. A handy function to have would be one that finds all the neighbors of a particular cell, and counts how many of them are alive.\n\nNotice how each neighbor cell is one row or column away from the cell we are looking at. So if we create a function that looks at each cell one position away from the target cell and counts how many of those cells are alive, we can use this to find the number of neighbors a cell has.\n\nRecall that we can reference any cell in our matrix structure using the notation matrix[row_number][column_number]. So, noting that every neighbor is one position away, we can add or subtract one from the row and column numbers to find the neighbors. A few examples:\n\nThe immediate left neighbor would be: matrix[row_number][column_number - 1]\n\nThe immediate right neighbor would be: matrix[row_number][column_number + 1]\n\nThe immediate top neighbor would be: matrix[row_number - 1][column_number]\n\nThe immediate bottom neighbor would be: matrix[row_number + 1][column_number]\n\nThe immediate top left neighbor would be: matrix[row_number - 1][column_number - 1]\n\nSo, if we have the target cell coordinates, x and y, we can use the following code to find the number of neighbors:\n\nfunction\n\nneighbors\n\nmatrix\n\nlet\n\ncount\n\nfor\n\nvar\n\n<=\n\n++\n\nfor\n\nvar\n\n<=\n\n++\n\nif\n\n===\n\n&&\n\n===\n\n// this is the cell itself, do nothing\n\ncontinue\n\nlet\n\ncurrentX\n\nlet\n\ncurrentY\n\nif\n\ncurrentX\n\n||\n\ncurrentX\n\n>=\n\nMATRIX_SIZE\n\n||\n\ncurrentY\n\n||\n\ncurrentY\n\n>=\n\nMATRIX_SIZE\n\n// this is an edge cell, do nothing\n\ncontinue\n\nelse\n\nif\n\nmatrix\n\ncurrentX\n\ncurrentY\n\n===\n\ntrue\n\n// the neighbor is alive, count it\n\ncount\n\n++\n\nreturn\n\ncount\n\nNotice that we use for loops to sweep from -1 to 1, which represents left to right and up to down. We use a conditional to check if the current cell is the target cell. We know it's the target cell if both of the sweep values are 0. If it is the target cell, we don't count it as a neighbor. We also check if the current cell is outside the grid (<0 || >=sMATRIX_SIZE), in which case we don't count it as a neighbor. Finally, if we have a valid neighbor cell, we check if it is alive, by testing if its value is true. If it is, we increment the count of \"living\" neighbors.\n\nImplementing the rules\u200b\n\nNow that we have a representation, and a way to query the model for the number of neighbors a cell has, we can implement the rules of the Game of Life.\n\nRecall that the rules of the game of life are:\n\nIf a cell is alive and has less than two live neighbors, it dies.\n\nIf a cell is alive and has more than three live neighbors, it dies.\n\nIf a cell is alive and has two or three live neighbors, it lives on to the next generation.\n\nIf a cell is dead and has exactly three live neighbors, it becomes a live cell.\n\nThe rules are applied across all cells in the matrix with each generation. To avoid having a partially updated matrix, with cells in the next generation that are not yet updated, we can create a new, blank matrix. Then we can iterate over each cell in the current generation's matrix, apply the rules to each cell, and set the value of the cell in the next generation's matrix according to the result of the rules.", "start_char_idx": 2339, "end_char_idx": 5685, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b9d0a0c4-1526-4d8b-b465-7c4a2b77c0c1": {"__data__": {"id_": "b9d0a0c4-1526-4d8b-b465-7c4a2b77c0c1", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35005b24-e309-4517-b837-29b950dc6a02", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "0d928e9a7275a2b713734684232cea31c4a9b343c6faa2ec09a5d2c2ee0cd0f5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "37176cb3-f568-4726-950d-ec042c5eae75", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "ca044f69e07c5c7748abb065dc8754164245a46840707fb3d9cc17cd1cd5db29", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5b459fde-676e-4dd8-ab32-e0b4fe7521c7", "node_type": "1", "metadata": {}, "hash": "8f2246b8fce7c1d77d3f2a3e1b846b5db6de31b892239a808d79f0b45959f009", "class_name": "RelatedNodeInfo"}}, "hash": "23fa27460929b232cf907950b0cb26c8487b2abc1e989697c4c3eafa09a3f5eb", "text": "Recall that the rules of the game of life are:\n\nIf a cell is alive and has less than two live neighbors, it dies.\n\nIf a cell is alive and has more than three live neighbors, it dies.\n\nIf a cell is alive and has two or three live neighbors, it lives on to the next generation.\n\nIf a cell is dead and has exactly three live neighbors, it becomes a live cell.\n\nThe rules are applied across all cells in the matrix with each generation. To avoid having a partially updated matrix, with cells in the next generation that are not yet updated, we can create a new, blank matrix. Then we can iterate over each cell in the current generation's matrix, apply the rules to each cell, and set the value of the cell in the next generation's matrix according to the result of the rules.\n\nLet's start with some pseudo-code to find the outline of this strategy:\n\ncreate nextMatrix\n\nfor\n\neach row\n\nin\n\nmatrix\n\nfor\n\neach column\n\nin\n\nrow\n\nget\n\nalive neighbors\n\nof\n\ncell at matrix\n\nrow\n\ncolumn\n\nif\n\ncell is alive\n\nif\n\ncell  has less than two live neighbors\n\nset\n\ncell to dead\n\nin\n\nnextMatrix\n\nrow\n\ncolumn\n\nif\n\ncell has more than three live neighbors\n\nset\n\ncell to dead\n\nin\n\nnextMatrix\n\nrow\n\ncolumn\n\nif\n\ncell has two or three live neighbors\n\nset\n\ncell to alive\n\nin\n\nnextMatrix\n\nrow\n\ncolumn\n\nif\n\ncell is dead\n\nif\n\ncell has exactly three live neighbors\n\nset\n\ncell to alive\n\nin\n\nnextMatrix\n\nrow\n\ncolumn\n\nreturn\n\nnextMatrix\n\nTranslating to JavaScript, and using our matrix functions, we will write the following function:\n\nfunction\n\nnextGeneration\n\nmatrix\n\nconst\n\nnextMatrix\n\ncreateMatrix\n\nfor\n\nvar\n\nmatrix\n\nlength\n\n++\n\nfor\n\nvar\n\nmatrix\n\nlength\n\n++\n\nconst\n\ncellNeighbors\n\nneighbors\n\nmatrix\n\nif\n\nmatrix\n\n===\n\ntrue\n\nif\n\ncellNeighbors\n\n===\n\n||\n\ncellNeighbors\n\n===\n\nnextMatrix\n\ntrue\n\nelse\n\nnextMatrix\n\nfalse\n\nif\n\nmatrix\n\n===\n\nfalse\n\nif\n\ncellNeighbors\n\n===\n\nnextMatrix\n\ntrue\n\nelse\n\nnextMatrix\n\nfalse\n\nreturn\n\nnextMatrix\n\nUpdating each generation\u200b\n\nWe have a model, and we have the rules. We now need a way to regularly update the model with the rules to create one generation of the simulation after the other.\n\nKaboom has two key events to help us with this:\n\nonUpdate\n\nonDraw\n\nThese two event handlers are called on every frame of the game. The onUpdate event is called first, and the onDraw event second. Drawing to the screen can only happen in the onDraw event handler.\n\nThis allows us to create a new generation using onUpdate, and then draw this update to the screen using onDraw.\n\nA new frame is typically created 60 times per second, normally expressed as 60 frames per second (FPS). This means that we can create a new generation every 16.67 milliseconds (1s/60fps = 16.67 milliseconds). At times, we might want to slow this down so that we can see the patterns evolving while we watch. To control the interval between each generation, we can measure the time between updates and only create a new generation if the time between updates is greater than a preset threshold.\n\nWith Kaboom, all drawing, controls, and event handlers must be contained within a scene. We only need one scene for our game. Let's create a scene called game, containing the core onUpdate function, and some of the variables the game will need:\n\nscene\n\n\"game\"\n\n=>\n\nlet\n\npause\n\ntrue\n\nlet\n\nupdateInterval\n\n0.5\n\nlet\n\ngeneration\n\nlet\n\ntimeFromLastUpdate\n\nlet\n\nmatrix\n\ncreateMatrix\n\nonUpdate\n\n=>\n\nif\n\npause\n\nreturn\n\ntimeFromLastUpdate\n\n+=\n\ndt\n\nif\n\ntimeFromLastUpdate\n\nupdateInterval\n\nreturn\n\ntimeFromLastUpdate\n\ngeneration\n\n++\n\nmatrix\n\nnextGeneration\n\nmatrix\n\nonDraw\n\n=>\n\n// todo: draw the world\n\ngo\n\n\"game\"\n\nWe've created a new scene called \"game\" here. In the code for the scene, we have a few variables which control various parameters of the simulation:\n\npause, a Boolean which indicates if the simulation should be paused, that is, not updated.\n\nupdateInterval, the time in seconds to wait between each generation update.\n\ngeneration, a counter to track how many generations have been run.\n\ntimeFromLastUpdate, an accumulator tracking the time in seconds since the last generation was updated.\n\nmatrix, the model of the current generation.\n\nFollowing these variables, we have a handler for the onUpdate event.", "start_char_idx": 4913, "end_char_idx": 9076, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5b459fde-676e-4dd8-ab32-e0b4fe7521c7": {"__data__": {"id_": "5b459fde-676e-4dd8-ab32-e0b4fe7521c7", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35005b24-e309-4517-b837-29b950dc6a02", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "0d928e9a7275a2b713734684232cea31c4a9b343c6faa2ec09a5d2c2ee0cd0f5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b9d0a0c4-1526-4d8b-b465-7c4a2b77c0c1", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "23fa27460929b232cf907950b0cb26c8487b2abc1e989697c4c3eafa09a3f5eb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "98b343ca-70cc-44ef-b3d3-df64c232586c", "node_type": "1", "metadata": {}, "hash": "7656245e4d07b627bbddc4b9f8af5aedd8b0acd0abf0a6189ca863d869c1eeee", "class_name": "RelatedNodeInfo"}}, "hash": "8f2246b8fce7c1d77d3f2a3e1b846b5db6de31b892239a808d79f0b45959f009", "text": "In the code for the scene, we have a few variables which control various parameters of the simulation:\n\npause, a Boolean which indicates if the simulation should be paused, that is, not updated.\n\nupdateInterval, the time in seconds to wait between each generation update.\n\ngeneration, a counter to track how many generations have been run.\n\ntimeFromLastUpdate, an accumulator tracking the time in seconds since the last generation was updated.\n\nmatrix, the model of the current generation.\n\nFollowing these variables, we have a handler for the onUpdate event. Kaboom calls this handler up to 60 times per second.\n\nFirst up in our handler function, we check if the game is paused. If so, we return immediately without making any changes.\n\ndt, which returns the time since the\n\nIf enough time has elapsed from the last generation update and it is time to update to the next generation, we first reset the timeFromLastUpdate accumulator to 0. Then we update our generation counter, and replace the current generation matrix with next generation calculated by the nextGeneration function we created earlier.\n\nWe have put a placeholder handler for the onDraw event for now. We'll get to that in the next section.\n\nTo start the whole game off, we use the go function, which switches between scenes.\n\nCreating the UI\u200b\n\nWe now need to create a UI to visualize and interact with the game.\n\nSome things that would be useful are:\n\nVisualizing the game\n\nSetting or clearing a cell\n\nRunning and pausing the game\n\nSetting the speed of the game\n\nResetting the game\n\nVisualization\u200b\n\nTo visualize the game, we can use some of lower level Kaboom draw functions. These allow us to draw shapes directly to the canvas. The shapes are not rich game objects like those created through Kaboom's add function, they are merely bitmaps on the drawing canvas. For this game, we don't need the advanced capabilities of Kaboom game objects, like gravity, collision detection, moving, and so on. That would just slow down our renders.\n\nLet's start off by adding in labels for the game state, speed, and generation number. Add the following code to the game scene:\n\nconst\n\npauseText\n\nadd\n\ntext\n\n\"Paused\"\n\nsize\n\n16\n\nfont\n\n\"sink\"\n\npos\n\n650\n\n40\n\norigin\n\n\"left\"\n\nlayer\n\n\"ui\"\n\nconst\n\nspeedText\n\nadd\n\ntext\n\n\"dt: 50ms\"\n\nsize\n\n16\n\nfont\n\n\"sink\"\n\npos\n\n650\n\n60\n\norigin\n\n\"left\"\n\nlayer\n\n\"ui\"\n\nconst\n\ngenerationText\n\nadd\n\ntext\n\n\"Generation: 0\"\n\nsize\n\n16\n\nfont\n\n\"sink\"\n\npos\n\n650\n\n80\n\norigin\n\n\"left\"\n\nlayer\n\n\"ui\"\n\nWe've added some default text in here - it will soon be updated to real values in code we will add to the onDraw handler:\n\nonDraw\n\n=>\n\nspeedText\n\ntext\n\ndt:\n\n${\n\nupdateInterval\n\n100\n\ntoFixed\n\nms\n\npauseText\n\ntext\n\npause\n\n\"Paused\"\n\n\"Running\"\n\ngenerationText\n\ntext\n\nGeneration:\n\n${\n\ngeneration\n\nThis update to the onDraw handler sets the text of the text labels to the variable values at that frame. Notice we use the JavaScript template literal for strings. This enables us to insert calculation and code directly into the strings using the ${} placeholder notation.\n\nNow let's draw each of the cells in the matrix. We'll create a helper function for this. Add the following code to the game scene:\n\nconst\n\nCELL_SIZE\n\n10\n\nfunction\n\ndrawCell\n\nrow\n\ncol\n\ndrawRect\n\nwidth\n\nCELL_SIZE\n\nheight\n\nCELL_SIZE\n\npos\n\nvec2\n\nrow\n\nCELL_SIZE\n\ncol\n\nCELL_SIZE\n\ncolor\n\nrgb\n\n100\n\n149\n\n237\n\nfill\n\ntrue\n\nvec2 is Kaboom's two-dimensional vector. The color is set to a classic bluish color (Google \"cornflower blue\"). We use the\n\nWe need one other helper function to draw the grid over the cells, so we can more easily see individual cells. Add the following code to the game scene:\n\nfunction\n\ndrawGridLines\n\nfor\n\nvar\n\n<=\n\nMATRIX_SIZE\n\n++\n\ndrawLine\n\np1\n\nvec2\n\nCELL_SIZE\n\np2\n\nvec2\n\nCELL_SIZE\n\nMATRIX_SIZE\n\nCELL_SIZE\n\nwidth\n\ncolor\n\nrgb\n\n218\n\n165\n\n32\n\ndrawLine\n\np1\n\nvec2\n\nCELL_SIZE\n\np2\n\nvec2\n\nMATRIX_SIZE\n\nCELL_SIZE\n\nCELL_SIZE\n\nwidth\n\ncolor\n\nrgb\n\n218\n\n165\n\n32\n\ndrawLine function to draw the grid lines. We set up a loop to draw\n\nvec2. The\n\nNow we can place and draw a cell on the screen.", "start_char_idx": 8517, "end_char_idx": 12539, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "98b343ca-70cc-44ef-b3d3-df64c232586c": {"__data__": {"id_": "98b343ca-70cc-44ef-b3d3-df64c232586c", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35005b24-e309-4517-b837-29b950dc6a02", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "0d928e9a7275a2b713734684232cea31c4a9b343c6faa2ec09a5d2c2ee0cd0f5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5b459fde-676e-4dd8-ab32-e0b4fe7521c7", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "8f2246b8fce7c1d77d3f2a3e1b846b5db6de31b892239a808d79f0b45959f009", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7a31be6a-d881-4f9a-b5bf-9abcb570ff23", "node_type": "1", "metadata": {}, "hash": "2011b4cd1b334ee84e0c7f13b3fcfe22e5c8cb0cef290a179dc2e8574fb8e5f3", "class_name": "RelatedNodeInfo"}}, "hash": "7656245e4d07b627bbddc4b9f8af5aedd8b0acd0abf0a6189ca863d869c1eeee", "text": "The color is set to a classic bluish color (Google \"cornflower blue\"). We use the\n\nWe need one other helper function to draw the grid over the cells, so we can more easily see individual cells. Add the following code to the game scene:\n\nfunction\n\ndrawGridLines\n\nfor\n\nvar\n\n<=\n\nMATRIX_SIZE\n\n++\n\ndrawLine\n\np1\n\nvec2\n\nCELL_SIZE\n\np2\n\nvec2\n\nCELL_SIZE\n\nMATRIX_SIZE\n\nCELL_SIZE\n\nwidth\n\ncolor\n\nrgb\n\n218\n\n165\n\n32\n\ndrawLine\n\np1\n\nvec2\n\nCELL_SIZE\n\np2\n\nvec2\n\nMATRIX_SIZE\n\nCELL_SIZE\n\nCELL_SIZE\n\nwidth\n\ncolor\n\nrgb\n\n218\n\n165\n\n32\n\ndrawLine function to draw the grid lines. We set up a loop to draw\n\nvec2. The\n\nNow we can place and draw a cell on the screen. Let's go back to the onDraw handler to loop through the matrix and call out to the drawCell and drawGridLines functions. Update the onDraw handler like this:\n\nonDraw\n\n=>\n\nspeedText\n\ntext\n\ndt:\n\n${\n\nupdateInterval\n\n100\n\ntoFixed\n\nms\n\npauseText\n\ntext\n\npause\n\n\"Paused\"\n\n\"Running\"\n\ngenerationText\n\ntext\n\nGeneration:\n\n${\n\ngeneration\n\n// run through the matrix and draw the cells that are alive\n\nfor\n\nvar\n\nMATRIX_SIZE\n\n++\n\nfor\n\nvar\n\nMATRIX_SIZE\n\n++\n\nif\n\nmatrix\n\n===\n\ntrue\n\ndrawCell\n\ndrawGridLines\n\nHere we add looping through all rows and columns to get each cell. If the cell value is true (the cell is alive), we draw it to the canvas. Then, once we are done with the cell, we draw the grid lines to help us see each individual cell.\n\nSetting or clearing a cell\u200b\n\nWe can draw the game, but we need some way to set the starting patterns. We can use the mouse to click on cells to set them as alive or dead. Kaboom has the function onMousePress that lets us attach a handler whenever the mouse buttons are clicked. We can also filter depending on if the left or right button is clicked. Add the following code to the game scene:\n\nonMousePress\n\n\"left\"\n\npos\n\n=>\n\nconst\n\nrow\n\nMath\n\nfloor\n\npos\n\nCELL_SIZE\n\nconst\n\ncol\n\nMath\n\nfloor\n\npos\n\nCELL_SIZE\n\nif\n\nrow\n\n||\n\ncol\n\n||\n\nrow\n\n>=\n\nMATRIX_SIZE\n\n||\n\ncol\n\n>=\n\nMATRIX_SIZE\n\nreturn\n\nmatrix\n\nrow\n\ncol\n\ntrue\n\nonMousePress\n\n\"right\"\n\npos\n\n=>\n\nconst\n\nrow\n\nMath\n\nfloor\n\npos\n\nCELL_SIZE\n\nconst\n\ncol\n\nMath\n\nfloor\n\npos\n\nCELL_SIZE\n\nif\n\nrow\n\n||\n\ncol\n\n||\n\nrow\n\n>=\n\nMATRIX_SIZE\n\n||\n\ncol\n\n>=\n\nMATRIX_SIZE\n\nreturn\n\nmatrix\n\nrow\n\ncol\n\nfalse\n\nOur onMousePress function takes the mouse button to filter by as a first parameter. The second parameter is the event handler function. In the event handler, we convert the screen pos from pixels to rows and columns in our matrix by dividing the screen pixel position by the CELL_SIZE in pixels.\n\nWe do a check to make sure the row and column is not outside the bounds of the matrix, if the player clicked outside of the grid for example.\n\nThen, for the left click handler, we update the state of the clicked cell to true, or alive. For the right click handler, we update the state of the clicked cell to false, or dead.\n\nGreat, now we can set cells!\n\nRunning and pausing the game\u200b\n\nNow we can model the game, see it, and set states. Let's add a control to start and pause the simulation.\n\nWe can use Kaboom's onKeyPress function to attach a handler whenever a key is pressed. Add the following code to the game scene:\n\nonKeyPress\n\n\"space\"\n\n=>\n\npause\n\npause\n\nThis fires whenever the spacebar is pressed. It toggles the pause variable using the Boolean NOT ! operator to the opposite of its current value. Recall the pause flag is used in the onUpdate handler we added earlier.\n\nSetting the speed of the game\u200b\n\nWe might want to speed up or slow down the simulation. We'll use the up and down arrow keys to change the updateInterval value that is checked in the onUpdate handler to determine if it is time to create the next generation.", "start_char_idx": 11902, "end_char_idx": 15528, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a31be6a-d881-4f9a-b5bf-9abcb570ff23": {"__data__": {"id_": "7a31be6a-d881-4f9a-b5bf-9abcb570ff23", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35005b24-e309-4517-b837-29b950dc6a02", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "0d928e9a7275a2b713734684232cea31c4a9b343c6faa2ec09a5d2c2ee0cd0f5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "98b343ca-70cc-44ef-b3d3-df64c232586c", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "7656245e4d07b627bbddc4b9f8af5aedd8b0acd0abf0a6189ca863d869c1eeee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2edde056-6a05-41f2-abdf-e03a780123fb", "node_type": "1", "metadata": {}, "hash": "d5805a924bff13066361871ea4bebcf46c29761e1d1ebc74feea066a74931f45", "class_name": "RelatedNodeInfo"}}, "hash": "2011b4cd1b334ee84e0c7f13b3fcfe22e5c8cb0cef290a179dc2e8574fb8e5f3", "text": "Great, now we can set cells!\n\nRunning and pausing the game\u200b\n\nNow we can model the game, see it, and set states. Let's add a control to start and pause the simulation.\n\nWe can use Kaboom's onKeyPress function to attach a handler whenever a key is pressed. Add the following code to the game scene:\n\nonKeyPress\n\n\"space\"\n\n=>\n\npause\n\npause\n\nThis fires whenever the spacebar is pressed. It toggles the pause variable using the Boolean NOT ! operator to the opposite of its current value. Recall the pause flag is used in the onUpdate handler we added earlier.\n\nSetting the speed of the game\u200b\n\nWe might want to speed up or slow down the simulation. We'll use the up and down arrow keys to change the updateInterval value that is checked in the onUpdate handler to determine if it is time to create the next generation. Add the following code to the game scene:\n\nonKeyDown\n\n\"down\"\n\n=>\n\nupdateInterval\n\n+=\n\n0.01\n\nonKeyDown\n\n\"up\"\n\n=>\n\nupdateInterval\n\n=\n\n0.01\n\nupdateInterval\n\nMath\n\nmax\n\n0.0\n\nupdateInterval\n\nHere we either add or subtract 0.01 seconds to the interval. Note that in the up key handler, which makes the interval between updates shorter, therefore increasing the speed of the simulation, we make sure that our interval cannot go negative. A negative time interval would make no sense, unless we accidentally invent time travel.\n\nResetting the game\u200b\n\nThe last control we need to add in is one to completely reset the simulation, clearing out all cells if we want to start fresh. We'll listen for the \"r\" key being pressed. If the \"r\" is pressed, we'll create a new blank matrix, and reset the generation counter. Add the following to the game scene:\n\nonKeyPress\n\n\"r\"\n\n=>\n\nmatrix\n\ncreateMatrix\n\nupdateInterval\n\n0.5\n\ngeneration\n\nRunning the game\u200b\n\nNow that we've finished building the game, let's give it a go!\n\nWe'll start off with some basic patterns that oscillate between two or more states. Using the left mouse button, click on cells to fill them with the following starting patterns.\n\nAfter you enter them, press the space bar to start the simulation. You should see something like this:\n\nTry using the up and down arrow keys to speed up or slow down the simulation.\n\nNow let's try some patterns that move and are a bit more lifelike. This one is called a glider:\n\nCreate it somewhere near the top left of your grid (you can press space to stop the previous simulation, and r to reset the game).\n\nAfter entering the glider pattern, press space to start the simulation. You should see it move across the screen like this:\n\nPretty cool! Let's try some spaceships now:\n\nThis should start flying across the screen:\n\nHere's a more random one. It's called \"die hard\", and goes through 130 generations with random patterns before dying out. Create it near the center of the grid, as it needs a bit of space:\n\nIt looks a bit like a wild fireworks show when it runs:\n\nThere are also patterns that can create other patterns. These type of patterns are known as guns. Here is Gosper's glider gun, the first that was discovered. It creates gliders. Try this pattern out:\n\n![](https://docimg.replit.com/images/tutorials/45-game-of-life/glider-gun-start.png\"\nalt=\"glider gun starting pattern\"\nstyle={{ width: \"80%\" }}\n/>\n\nWhen you run it, you should see it emit gliders! Guns are some of the coolest patterns you can create.\n\nNext steps\u200b\n\nThere are many, many patterns that have been discovered for Conway's Game of Life, and many more still being discovered today. Perhaps you could discover some! Take at look the Wikipedia article for more info on Conway's Game of Life and some patterns. The Game of Life even has its own wiki.\n\nAlso try Google searching for \"Conway Game of Life patterns\". There is a myriad of sites out there listing patterns to try.\n\nAn interesting interview with John Conway was done a few years back. Sadly, John Conway died in 2020, but his game will last forever.\n\nYou can find the code for this tutorial here:\n\n< Previous: Tic-tac-toe with Kaboom.js & WebSockets\n\nNext: Kaboom editor >\n\nWas this helpful?", "start_char_idx": 14716, "end_char_idx": 18744, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2edde056-6a05-41f2-abdf-e03a780123fb": {"__data__": {"id_": "2edde056-6a05-41f2-abdf-e03a780123fb", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35005b24-e309-4517-b837-29b950dc6a02", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "0d928e9a7275a2b713734684232cea31c4a9b343c6faa2ec09a5d2c2ee0cd0f5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7a31be6a-d881-4f9a-b5bf-9abcb570ff23", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}, "hash": "2011b4cd1b334ee84e0c7f13b3fcfe22e5c8cb0cef290a179dc2e8574fb8e5f3", "class_name": "RelatedNodeInfo"}}, "hash": "d5805a924bff13066361871ea4bebcf46c29761e1d1ebc74feea066a74931f45", "text": "Guns are some of the coolest patterns you can create.\n\nNext steps\u200b\n\nThere are many, many patterns that have been discovered for Conway's Game of Life, and many more still being discovered today. Perhaps you could discover some! Take at look the Wikipedia article for more info on Conway's Game of Life and some patterns. The Game of Life even has its own wiki.\n\nAlso try Google searching for \"Conway Game of Life patterns\". There is a myriad of sites out there listing patterns to try.\n\nAn interesting interview with John Conway was done a few years back. Sadly, John Conway died in 2020, but his game will last forever.\n\nYou can find the code for this tutorial here:\n\n< Previous: Tic-tac-toe with Kaboom.js & WebSockets\n\nNext: Kaboom editor >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting started on Replit\n\nSetting up Kaboom\n\nDesigning the model\n\nImplementing the model\n\nImplementing the rules\n\nUpdating each generation\n\nCreating the UIVisualizationSetting or clearing a cellRunning and pausing the gameSetting the speed of the gameResetting the game\n\nRunning the game\n\nNext steps", "start_char_idx": 17982, "end_char_idx": 19076, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"35005b24-e309-4517-b837-29b950dc6a02": {"node_ids": ["52431303-98f3-4ab7-a588-0b920393d57e", "37176cb3-f568-4726-950d-ec042c5eae75", "b9d0a0c4-1526-4d8b-b465-7c4a2b77c0c1", "5b459fde-676e-4dd8-ab32-e0b4fe7521c7", "98b343ca-70cc-44ef-b3d3-df64c232586c", "7a31be6a-d881-4f9a-b5bf-9abcb570ff23", "2edde056-6a05-41f2-abdf-e03a780123fb"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/game-of-life-kaboom.html"}}}, "docstore/metadata": {"52431303-98f3-4ab7-a588-0b920393d57e": {"doc_hash": "23ce3a9e84a4c6fcd2cf78753d3a110ee7b7759fb5ecfc52547bf06f830e2909", "ref_doc_id": "35005b24-e309-4517-b837-29b950dc6a02"}, "37176cb3-f568-4726-950d-ec042c5eae75": {"doc_hash": "ca044f69e07c5c7748abb065dc8754164245a46840707fb3d9cc17cd1cd5db29", "ref_doc_id": "35005b24-e309-4517-b837-29b950dc6a02"}, "b9d0a0c4-1526-4d8b-b465-7c4a2b77c0c1": {"doc_hash": "23fa27460929b232cf907950b0cb26c8487b2abc1e989697c4c3eafa09a3f5eb", "ref_doc_id": "35005b24-e309-4517-b837-29b950dc6a02"}, "5b459fde-676e-4dd8-ab32-e0b4fe7521c7": {"doc_hash": "8f2246b8fce7c1d77d3f2a3e1b846b5db6de31b892239a808d79f0b45959f009", "ref_doc_id": "35005b24-e309-4517-b837-29b950dc6a02"}, "98b343ca-70cc-44ef-b3d3-df64c232586c": {"doc_hash": "7656245e4d07b627bbddc4b9f8af5aedd8b0acd0abf0a6189ca863d869c1eeee", "ref_doc_id": "35005b24-e309-4517-b837-29b950dc6a02"}, "7a31be6a-d881-4f9a-b5bf-9abcb570ff23": {"doc_hash": "2011b4cd1b334ee84e0c7f13b3fcfe22e5c8cb0cef290a179dc2e8574fb8e5f3", "ref_doc_id": "35005b24-e309-4517-b837-29b950dc6a02"}, "2edde056-6a05-41f2-abdf-e03a780123fb": {"doc_hash": "d5805a924bff13066361871ea4bebcf46c29761e1d1ebc74feea066a74931f45", "ref_doc_id": "35005b24-e309-4517-b837-29b950dc6a02"}}}