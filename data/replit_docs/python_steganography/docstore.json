{"docstore/data": {"a8bb0fe8-3266-4411-8368-005bd702bd53": {"__data__": {"id_": "a8bb0fe8-3266-4411-8368-005bd702bd53", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/steganography.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cbd0d3ff-e4ea-4642-a6ce-079892113224", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/steganography.html"}, "hash": "b31ab2705158ad60f9b444c370a636e21f4f0c025975ffb7815d1fbd8722b9d1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "189ab658-6c5d-41d9-9b7f-bfa6f7a9243e", "node_type": "1", "metadata": {}, "hash": "6d933e0ebad4615cd30d93a3c2cc3b9f961b93bacdba6e801409b532f36e2258", "class_name": "RelatedNodeInfo"}}, "hash": "24f4798092d4d682e08f6ea6c05993a8091d7e986f30342ed5b2c4982ed3d2a0", "text": "bytes_\n\nbase64\n\nencodebytes\n\nb64\n\nbytestring\n\n\"\"\n\njoin\n\n\"{:08b}\"\n\nformat\n\nfor\n\nin\n\nbytes_\n\nbytestring\n\n+=\n\nENDOFMESSAGE\n\nreturn\n\nbytestring\n\nNow that we can handle some basic text encoding, let's look at images.\n\nGetting pixels from an image\u200b\n\nFind a PNG image somewhere - either one you've taken yourself or from a site like unsplash. You can use any online JPG to PNG converter if you only have .jpg files available.\n\nUpload your PNG file by clicking on the three dot menu in the repl sidebar, in the top right corner of the files pane to the left, and selecting upload file or by simply dragging and dropping your file within the files pane.\n\nWe're going to write a function that extracts the raw pixel data from this image file. Add an import to the top of the file.\n\nimport\n\npng\n\nAnd then add a new function to the bottom of main.py:\n\ndef\n\nget_pixels_from_image\n\nfname\n\nimg\n\npng\n\nReader\n\nfname\n\nread\n\npixels\n\nimg\n\nreturn\n\npixels\n\nThe read() method returns a 4\u2011tuple consisting of:\n\nwidth: Width of PNG image in pixels\n\nheight: Height of PNG image in pixels\n\nrows: A sequence or iterator for the row data\n\ninfo: An info dictionary containing some meta data\n\nWe are primarily interested in the third item, \"rows\", which is an iterator containing all the pixels of the image, row by row. If you're not familiar with Python generators take a look at this guide, but they are essentially memory-efficient lists.\n\nEncoding the image with the message\u200b\n\nNow that we have the encoded message and pixels of the image ready we can combine them to form our secret encoded image.\n\nAdd the following function to the bottom of the main.py file. This function takes in the outputs from the previous functions (our raw pixels and our message encoded as a binary string), and combines them.\n\ndef\n\nencode_pixels_with_message\n\npixels\n\nbytestring\n\n'''modifies pixels to encode the contents from bytestring'''\n\nenc_pixels\n\nstring_i\n\nfor\n\nrow\n\nin\n\npixels\n\nenc_row\n\nfor\n\nchar\n\nin\n\nenumerate\n\nrow\n\nif\n\nstring_i\n\n>=\n\nlen\n\nbytestring\n\npixel\n\nrow\n\nelse\n\nif\n\nrow\n\n!=\n\nint\n\nbytestring\n\nstring_i\n\nif\n\nrow\n\n==\n\npixel\n\nelse\n\npixel\n\nrow\n\nelse\n\npixel\n\nrow\n\nenc_row\n\nappend\n\npixel\n\nstring_i\n\n+=\n\nenc_pixels\n\nappend\n\nenc_row\n\nreturn\n\nenc_pixels\n\nThis is the most complicated part of our project, but most of the code is there to handle edge cases. The important insight is that we want to control whether each pixel has an odd value (representing a 1 in our binary string) or an even one (to represent a 0). By chance, half of the pixel values will already have the correct value.\n\nWe simply loop through the binary string and the pixel and 'bump' each value that isn't correct by one. That is, we subtract 1 from the value if we need to change it from odd to even or vice versa. We don't want any negative numbers, so if we need to change any of the 0 values, we add 1 instead.\n\nWriting our modified pixels back to an image\u200b\n\nWe now have all the image data, including the encoded message but it is still just a list of pixels. Let's add a function that will compile our pixels back into a PNG image.\n\nAdd the following function to the bottom of the main.py file.\n\ndef\n\nwrite_pixels_to_image\n\npixels\n\nfname\n\npng\n\nfrom_array\n\npixels\n\n'RGB'\n\nsave\n\nfname\n\nThe above function takes the array pixels and uses the png module to write these to a brand new .png file.\n\nPlay around with these functions to make sure you understand how they work. Before we write some wrapper code to actually use these, we're going to do everything backwards so that we can also extract hidden messages from previously encoded PNG files.\n\nDecoding messages from image files\u200b\n\nFirst we need a function that can turn a binary string back into readable text. As before, we'll go via base64 for better compatibility. Add the following function to the bottom of the main.py file.\n\ndef\n\ndecode_message_from_bytestring\n\nbytestring\n\nbytestring\n\nbytestring\n\nsplit\n\nENDOFMESSAGE\n\nmessage\n\nint\n\nbytestring\n\nto_bytes\n\nlen\n\nbytestring\n\n//\n\nbyteorder\n\n'big'\n\nmessage\n\nbase64\n\ndecodebytes\n\nmessage\n\ndecode\n\n\"utf8\"\n\nreturn\n\nmessage\n\nRemember how we added a special ENDOFMESSAGE delimiter above?", "start_char_idx": 0, "end_char_idx": 4120, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "189ab658-6c5d-41d9-9b7f-bfa6f7a9243e": {"__data__": {"id_": "189ab658-6c5d-41d9-9b7f-bfa6f7a9243e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/steganography.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cbd0d3ff-e4ea-4642-a6ce-079892113224", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/steganography.html"}, "hash": "b31ab2705158ad60f9b444c370a636e21f4f0c025975ffb7815d1fbd8722b9d1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a8bb0fe8-3266-4411-8368-005bd702bd53", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/steganography.html"}, "hash": "24f4798092d4d682e08f6ea6c05993a8091d7e986f30342ed5b2c4982ed3d2a0", "class_name": "RelatedNodeInfo"}}, "hash": "6d933e0ebad4615cd30d93a3c2cc3b9f961b93bacdba6e801409b532f36e2258", "text": "Play around with these functions to make sure you understand how they work. Before we write some wrapper code to actually use these, we're going to do everything backwards so that we can also extract hidden messages from previously encoded PNG files.\n\nDecoding messages from image files\u200b\n\nFirst we need a function that can turn a binary string back into readable text. As before, we'll go via base64 for better compatibility. Add the following function to the bottom of the main.py file.\n\ndef\n\ndecode_message_from_bytestring\n\nbytestring\n\nbytestring\n\nbytestring\n\nsplit\n\nENDOFMESSAGE\n\nmessage\n\nint\n\nbytestring\n\nto_bytes\n\nlen\n\nbytestring\n\n//\n\nbyteorder\n\n'big'\n\nmessage\n\nbase64\n\ndecodebytes\n\nmessage\n\ndecode\n\n\"utf8\"\n\nreturn\n\nmessage\n\nRemember how we added a special ENDOFMESSAGE delimiter above? Here we first split our string on that so we don't look for text in random data (pixels from the unmodified part of the image) and then go backwards through our encoding pipe: first to base64 and then to text.\n\nWe also need a way to extract the bytestring from an image. Add the following function to main.py to do this.\n\ndef\n\ndecode_pixels\n\npixels\n\nbytestring\n\nfor\n\nrow\n\nin\n\npixels\n\nfor\n\nin\n\nrow\n\nbytestring\n\nappend\n\nstr\n\nbytestring\n\n''\n\njoin\n\nbytestring\n\nmessage\n\ndecode_message_from_bytestring\n\nbytestring\n\nreturn\n\nmessage\n\nOnce again, this is just the reverse of what we did before. We grab the remainder of each value to get 1 for each odd value and 0 for each even one and keep them in a string. We then call our decode function to get the plaintext.\n\nThat's it for our encoding and decoding functions; next we'll put everything together in our main() function.\n\nAdding a command line wrapper script\u200b\n\nAt this point, we could create a web application with a UI for people to add text to their images. Given the fact that people who want to do steganography probably won't trust a web application with their data, we'll rather create a command line application that people can run on their own machines.\n\nAdd the following to the top of your main.py file, right below the imports.\n\nPROMPT\n\n\"\"\"\n\nWelcome to basic steganography. Please choose:\n\n1. To encode a message into an image\n\n2. To decode an image into a message\n\nq. To exit\n\n\"\"\"\n\nNow let's write the main() function that puts it all together. Add the following to the end of the main.py file.\n\ndef\n\nmain\n\nprint\n\nPROMPT\n\nuser_inp\n\n\"\"\n\nwhile\n\nuser_inp\n\nnot\n\nin\n\n\"1\"\n\n\"2\"\n\n\"q\"\n\nuser_inp\n\ninput\n\n\"Your choice: \"\n\nif\n\nuser_inp\n\n==\n\n\"1\"\n\nin_image\n\ninput\n\n\"Please enter filename of existing PNG image: \"\n\nin_message\n\ninput\n\n\"Please enter the message to encode: \"\n\nprint\n\n\"-ENCODING-\"\n\npixels\n\nget_pixels_from_image\n\nin_image\n\nbytestring\n\nencode_message_as_bytestring\n\nin_message\n\nepixels\n\nencode_pixels_with_message\n\npixels\n\nbytestring\n\nwrite_pixels_to_image\n\nepixels\n\nin_image\n\n\"-enc.png\"\n\nelif\n\nuser_inp\n\n==\n\n\"2\"\n\nin_image\n\ninput\n\n\"Please enter the filename of an existing PNG image: \"\n\nprint\n\n\"-DECODING-\"\n\npixels\n\nget_pixels_from_image\n\nin_image\n\nprint\n\ndecode_pixels\n\npixels\n\nif\n\n__name__\n\n==\n\n\"__main__\"\n\nmain\n\nThe main() function above creates a prompt flow for the user to interact with the program. Depending on the input from the user, the program will call the relevant functions in order to either encode or decode a message. We also included a q for the user to close the program.\n\nWhere next?\u200b\n\nIf you have followed along you'll have your own repl to expand; if not you can fork our repl and work from there or test it out below.\n\n< Previous: Static site generator\n\nNext: Technical challenge site with replit.web >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nA quick background on steganography\n\nCreating the project on Replit\n\nEncoding a text message as a binary string\n\nAdding an 'end of message' delimiter\n\nGetting pixels from an image\n\nEncoding the image with the messageWriting our modified pixels back to an image\n\nDecoding messages from image files\n\nAdding a command line wrapper script\n\nWhere next?", "start_char_idx": 3329, "end_char_idx": 7301, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"cbd0d3ff-e4ea-4642-a6ce-079892113224": {"node_ids": ["a8bb0fe8-3266-4411-8368-005bd702bd53", "189ab658-6c5d-41d9-9b7f-bfa6f7a9243e"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/steganography.html"}}}, "docstore/metadata": {"a8bb0fe8-3266-4411-8368-005bd702bd53": {"doc_hash": "24f4798092d4d682e08f6ea6c05993a8091d7e986f30342ed5b2c4982ed3d2a0", "ref_doc_id": "cbd0d3ff-e4ea-4642-a6ce-079892113224"}, "189ab658-6c5d-41d9-9b7f-bfa6f7a9243e": {"doc_hash": "6d933e0ebad4615cd30d93a3c2cc3b9f961b93bacdba6e801409b532f36e2258", "ref_doc_id": "cbd0d3ff-e4ea-4642-a6ce-079892113224"}}}