{"docstore/data": {"e474b248-8481-41b4-8354-fdea251d5ca5": {"__data__": {"id_": "e474b248-8481-41b4-8354-fdea251d5ca5", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3bc030ae-db9a-437b-a305-be1ab7a076df", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "2311c6849e69c73f9b1d637c0769fb0c7da2b177dd79198e155dd035ab686e93", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d26a959d-85fb-4087-8d45-e2c4ee92aa39", "node_type": "1", "metadata": {}, "hash": "b7a61c5f346776d25c410222c4ac144474f4cc880f053b1afce506653d3866e8", "class_name": "RelatedNodeInfo"}}, "hash": "32a4e4551a4282253f894f81f07a524ad853d4e7cb57d2c7b4e1f37b5bbaf95c", "text": "First, we import the Python libraries we'll need, including discord.py and its commands extension. Next we retrieve the value of the DISCORD_TOKEN environment variable, which we set in our repl's secrets tab above. Then we instantiate a Bot object. We'll use this object to listen for Discord events and respond to them.\n\nThe first event we're interested in is on_ready(), which will trigger when our bot logs onto Discord (the @bot.event decorator ensures this). All this event will do is print a message to our repl's console, telling us that the bot has connected.\n\nNote that we've prepended async to the function definition \u2013 this makes our on_ready() function into a coroutine. Coroutines are largely similar to functions, but may not execute immediately, and must be invoked with the await keyword. Using coroutines makes our program asynchronous, which means it can continue executing code while waiting for the results of a long-running function, usually one that depends on input or output. If you've used JavaScript before, you'll recognize this style of programming.\n\nThe final line in our file starts the bot, providing DISCORD_TOKEN to authenticate it. Run your repl now to see it in action. Once it's started, return to your Discord server. You should see that your bot user is now online.\n\nCreating server roles\u200b\n\nBefore we write our bot's main logic, we need to create some roles for it to assign. Our Discord server is for programming discussion, so we'll create roles for a few different programming languages: Python, JavaScript, Rust, Go, and C++. For the sake of simplicity, we'll use all-lowercase for our role names. Feel free to add other languages.\n\nYou can add roles by doing the following:\n\nRight-click on your server's icon in the leftmost panel.\n\nFrom the menu that appears, select Server Settings, and then Roles.\n\nClick Create Role.\n\nEnter a role name (for example, \"python\") and choose a color.\n\nClick Back.\n\nRepeat steps 3\u20135 until all the roles are created.\n\nYour role list should now look something like this:\n\nThe order in which roles are listed is the role hierarchy. Users who have permission to manage roles will only be able to manage roles lower than their highest role on this list. Ensure that the WelcomeBot role is at the top, or it won't be able to assign users to any of the other roles, even with Administrator privileges.\n\nAt present, all these roles will do is change the color of users' names and the list they appear in on the right sidebar. To make them a bit more meaningful, we can create some private channels. Only users with a given role will be able to use these channels.\n\nTo add private channels for your server's roles, do the following:\n\nClick on the + next to Text Channels.\n\nType a channel name (e.g. \"python\") under Channel Name.\n\nEnable the Private Channel toggle.\n\nClick Create Channel.\n\nSelect the role that matches your channel's name.\n\nRepeat for all roles.\n\nAs the server owner, you'll be able to see these channels regardless of your assigned roles, but normal members will not.\n\nMessaging users\u200b\n\nNow that our roles are configured, let's write some bot logic. We'll start with a function to DM users with a welcome message. Return to your repl and enter the following code just below the line where you defined bot:\n\nasync\n\ndef\n\ndm_about_roles\n\nmember\n\nprint\n\nf\"DMing\n\nmember\n\nname\n\n...\"\n\nawait\n\nmember\n\nsend\n\nf\"\"\"Hi\n\nmember\n\nname\n\n, welcome to\n\nmember\n\nguild\n\nname\n\nWhich of these languages do you use:\n\nPython (\ud83d\udc0d)\n\nJavaScript (\ud83d\udd78\ufe0f)\n\nRust (\ud83e\udd80)\n\nGo (\ud83d\udc39)\n\nC++ (\ud83d\udc09)\n\nReply to this message with one or more of the language names or emojis above so I can assign you the right roles on our server.\n\n\"\"\"\n\nThis simple function takes a member object and sends it a private message. Note the use of await when running the coroutine member.send().\n\nWe need to run this function when one of two things happens: a new member joins the server, or an existing member types the command !roles in a channel. The second one will allow us to test the bot without constantly leaving and rejoining the server, and let users change their minds about what programming languages they want to discuss.\n\nTo handle the first event, add this code below the definition of on_ready:\n\n@bot\n\nevent\n\nasync\n\ndef\n\non_member_join\n\nmember\n\nawait\n\ndm_about_roles\n\nmember\n\nThe on_member_join() callback supplies a member object we can use to call dm_about_roles().\n\nFor the second event, we'll need a bit more code.", "start_char_idx": 0, "end_char_idx": 4446, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d26a959d-85fb-4087-8d45-e2c4ee92aa39": {"__data__": {"id_": "d26a959d-85fb-4087-8d45-e2c4ee92aa39", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3bc030ae-db9a-437b-a305-be1ab7a076df", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "2311c6849e69c73f9b1d637c0769fb0c7da2b177dd79198e155dd035ab686e93", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e474b248-8481-41b4-8354-fdea251d5ca5", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "32a4e4551a4282253f894f81f07a524ad853d4e7cb57d2c7b4e1f37b5bbaf95c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2e3625e1-aad3-4905-8a88-aa0edb96b9d6", "node_type": "1", "metadata": {}, "hash": "4ed5d5aa5ca873123ab5c83f0f060f5df0d9fb6b953c3b8cfc17f418f3f7bd01", "class_name": "RelatedNodeInfo"}}, "hash": "b7a61c5f346776d25c410222c4ac144474f4cc880f053b1afce506653d3866e8", "text": "This simple function takes a member object and sends it a private message. Note the use of await when running the coroutine member.send().\n\nWe need to run this function when one of two things happens: a new member joins the server, or an existing member types the command !roles in a channel. The second one will allow us to test the bot without constantly leaving and rejoining the server, and let users change their minds about what programming languages they want to discuss.\n\nTo handle the first event, add this code below the definition of on_ready:\n\n@bot\n\nevent\n\nasync\n\ndef\n\non_member_join\n\nmember\n\nawait\n\ndm_about_roles\n\nmember\n\nThe on_member_join() callback supplies a member object we can use to call dm_about_roles().\n\nFor the second event, we'll need a bit more code. While we could use discord.py's bot commands framework to handle our !roles command, we will also need to deal with general message content later on, and doing both in different functions doesn't work well. So instead, we'll put everything to do with message contents in a single on_message() event. If our bot were just responding to commands, using @bot.command handlers would be preferable.\n\nAdd the following code below the definition of on_member_join():\n\n@bot\n\nevent\n\nasync\n\ndef\n\non_message\n\nmessage\n\nprint\n\n\"Saw a message...\"\n\nif\n\nmessage\n\nauthor\n\n==\n\nbot\n\nuser\n\nreturn\n\n# prevent responding to self\n\n# Respond to commands\n\nif\n\nmessage\n\ncontent\n\nstartswith\n\n\"!roles\"\n\nawait\n\ndm_about_roles\n\nmessage\n\nauthor\n\nFirst, we print a message to the repl console to note that we've seen a message. We then check if the message's author is the bot itself. If it is, we terminate the function, to avoid infinite loops. Following that, we check if the message's content starts with !roles, and if so we invoke dm_amount_roles(), passing in the message's author.\n\nStop and rerun your repl now. If you receive a CloudFlare error, type kill 1 in your repl's shell and try again. Once your repl's running, return to your Discord server and type \"!roles\" into the general chat. You should receive a DM from your bot.\n\nAssigning roles from replies\u200b\n\nOur bot can DM users, but it won't do anything when users reply to it. Before we can add that logic, we need to implement a small hack to allow our bot to take actions on our server based on the contents of direct messages.\n\nThe Discord bot framework is designed with the assumption that bots are generic and will be added to many different servers. Bots do not have a home server, and there's no easy way for them to trace a process flow that moves from a server to private messages like the one we're building here. Therefore, our bot won't automatically know which server to use for role assignment when that user replies to its DM.\n\nWe could work out which server to use through the user's mutual_guilds property, but it is not always reliable due to caching. Note that Discord servers were previously known as \"guilds\" and this terminology persists in areas of the API.\n\nAs we don't plan to add this bot to more than one server at a time, we'll solve the problem by hardcoding the server ID in our bot logic. But first, we need to retrieve our server's ID. The easiest way to do this is to add another command to our bot's vocabulary. Expand the if statement at the bottom of on_message() to include the following elif:\n\nelif\n\nmessage\n\ncontent\n\nstartswith\n\n\"!serverid\"\n\nawait\n\nmessage\n\nchannel\n\nsend\n\nmessage\n\nchannel\n\nguild\n\nid\n\nRerun your repl and return to your Discord server. Type \"!serverid\" into the chat, and you should get a reply from your bot containing a long string of digits. Copy that string to your clipboard.\n\nGo to the top of main.py. Underneath DISCORD_TOKEN, add the following line:\n\nSERVER_ID\n\nPaste the contents of your clipboard after the equals sign. Now we can retrieve our server's ID from this variable.\n\nOnce that's done, return to the definition of on_message(). We're going to add another if statement to deal with the contents of user replies in DMs.", "start_char_idx": 3668, "end_char_idx": 7672, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2e3625e1-aad3-4905-8a88-aa0edb96b9d6": {"__data__": {"id_": "2e3625e1-aad3-4905-8a88-aa0edb96b9d6", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3bc030ae-db9a-437b-a305-be1ab7a076df", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "2311c6849e69c73f9b1d637c0769fb0c7da2b177dd79198e155dd035ab686e93", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d26a959d-85fb-4087-8d45-e2c4ee92aa39", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "b7a61c5f346776d25c410222c4ac144474f4cc880f053b1afce506653d3866e8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6d0bc4f2-5c2b-40d7-88ec-72b2f33730ec", "node_type": "1", "metadata": {}, "hash": "282981952b9f964ee286bc64807d9bc04130d73598ed56c5cb9b7fff25387394", "class_name": "RelatedNodeInfo"}}, "hash": "4ed5d5aa5ca873123ab5c83f0f060f5df0d9fb6b953c3b8cfc17f418f3f7bd01", "text": "The easiest way to do this is to add another command to our bot's vocabulary. Expand the if statement at the bottom of on_message() to include the following elif:\n\nelif\n\nmessage\n\ncontent\n\nstartswith\n\n\"!serverid\"\n\nawait\n\nmessage\n\nchannel\n\nsend\n\nmessage\n\nchannel\n\nguild\n\nid\n\nRerun your repl and return to your Discord server. Type \"!serverid\" into the chat, and you should get a reply from your bot containing a long string of digits. Copy that string to your clipboard.\n\nGo to the top of main.py. Underneath DISCORD_TOKEN, add the following line:\n\nSERVER_ID\n\nPaste the contents of your clipboard after the equals sign. Now we can retrieve our server's ID from this variable.\n\nOnce that's done, return to the definition of on_message(). We're going to add another if statement to deal with the contents of user replies in DMs. Edit the function body so that it matches the below:\n\n@bot\n\nevent\n\nasync\n\ndef\n\non_message\n\nmessage\n\nprint\n\n\"Saw a message...\"\n\nif\n\nmessage\n\nauthor\n\n==\n\nbot\n\nuser\n\nreturn\n\n# prevent responding to self\n\n# NEW CODE BELOW\n\n# Assign roles from DM\n\nif\n\nisinstance\n\nmessage\n\nchannel\n\ndiscord\n\nchannel\n\nDMChannel\n\nawait\n\nassign_roles\n\nmessage\n\nreturn\n\n# NEW CODE ABOVE\n\n# Respond to commands\n\nif\n\nmessage\n\ncontent\n\nstartswith\n\n\"!roles\"\n\nawait\n\ndm_about_roles\n\nmessage\n\nauthor\n\nelif\n\nmessage\n\ncontent\n\nstartswith\n\n\"!serverid\"\n\nawait\n\nmessage\n\nchannel\n\nsend\n\nmessage\n\nchannel\n\nguild\n\nid\n\nThis new if statement will check whether the message that triggered the event was in a DM channel, and if so, will run assign_roles() and then exit. Now we need to define assign_roles(). Add the following code above the definition of on_message():\n\nasync\n\ndef\n\nassign_roles\n\nmessage\n\nprint\n\n\"Assigning roles...\"\n\nlanguages\n\nset\n\nre\n\nfindall\n\n\"python|javascript|rust|go|c\\+\\+\"\n\nmessage\n\ncontent\n\nre\n\nIGNORECASE\n\nWe can find the languages mentioned in the user replies using regular expressions: re.findall() will return a list of strings that match our expression. This way, whether the user replies with \"Please add me to the Python and Go groups\" or just \"python go\", we'll be able to assign them the right role.\n\nWe convert the list into a set in order to remove duplicates.\n\nThe next thing we need to do is deal with emoji responses. Add the following code to the bottom of the assign_roles() function:\n\nlanguage_emojis\n\nset\n\nre\n\nfindall\n\n\"\\U0001F40D|\\U0001F578|\\U0001F980|\\U0001F439|\\U0001F409\"\n\nmessage\n\ncontent\n\n# https://unicode.org/emoji/charts/full-emoji-list.html\n\n# Convert emojis to names\n\nfor\n\nemoji\n\nin\n\nlanguage_emojis\n\n\"\\U0001F40D\"\n\nlambda\n\nlanguages\n\nadd\n\n\"python\"\n\n\"\\U0001F578\"\n\nlambda\n\nlanguages\n\nadd\n\n\"javascript\"\n\n\"\\U0001F980\"\n\nlambda\n\nlanguages\n\nadd\n\n\"rust\"\n\n\"\\U0001F439\"\n\nlambda\n\nlanguages\n\nadd\n\n\"go\"\n\n\"\\U0001F409\"\n\nlambda\n\nlanguages\n\nadd\n\n\"c++\"\n\nemoji\n\nIn the first line, we do the same regex matching we did with the language names, but using emoji Unicode values instead of standard text. You can find a list of emojis with their codes on Unicode.org. Note that the + in this list's code should be replaced with 000 in your Python code: for example, U+1F40D becomes U0001F40D.\n\nOnce we've got our set of emoji matches in language_emojis, we loop through it and use a dictionary to add the correct name to our languages set. This dictionary has strings as values and lambda functions as keys. Finally, [emoji]() will select the lambda function for the provided key and execute it, adding a value to languages. This is similar to the switch-case syntax you may have seen in other programming languages.\n\nWe now have a full list of languages our users may wish to discuss. Add the following code below the for loop:\n\nif\n\nlanguages\n\nserver\n\nbot\n\nget_guild\n\nSERVER_ID\n\nroles\n\ndiscord\n\nutils\n\nget\n\nserver\n\nroles\n\nname\n\nlanguage\n\nlower\n\nfor\n\nlanguage\n\nin\n\nlanguages\n\nmember\n\nawait\n\nserver\n\nfetch_member\n\nmessage\n\nauthor\n\nid\n\nThis code first checks that the languages set contains values.", "start_char_idx": 6848, "end_char_idx": 10757, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6d0bc4f2-5c2b-40d7-88ec-72b2f33730ec": {"__data__": {"id_": "6d0bc4f2-5c2b-40d7-88ec-72b2f33730ec", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3bc030ae-db9a-437b-a305-be1ab7a076df", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "2311c6849e69c73f9b1d637c0769fb0c7da2b177dd79198e155dd035ab686e93", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2e3625e1-aad3-4905-8a88-aa0edb96b9d6", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "4ed5d5aa5ca873123ab5c83f0f060f5df0d9fb6b953c3b8cfc17f418f3f7bd01", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d98602d6-9eb7-4ccb-b6dd-830feef765e7", "node_type": "1", "metadata": {}, "hash": "cb18593078634dce1a819fbe08920639c8419b55953810ac1c3e1f0ab58875ee", "class_name": "RelatedNodeInfo"}}, "hash": "282981952b9f964ee286bc64807d9bc04130d73598ed56c5cb9b7fff25387394", "text": "Once we've got our set of emoji matches in language_emojis, we loop through it and use a dictionary to add the correct name to our languages set. This dictionary has strings as values and lambda functions as keys. Finally, [emoji]() will select the lambda function for the provided key and execute it, adding a value to languages. This is similar to the switch-case syntax you may have seen in other programming languages.\n\nWe now have a full list of languages our users may wish to discuss. Add the following code below the for loop:\n\nif\n\nlanguages\n\nserver\n\nbot\n\nget_guild\n\nSERVER_ID\n\nroles\n\ndiscord\n\nutils\n\nget\n\nserver\n\nroles\n\nname\n\nlanguage\n\nlower\n\nfor\n\nlanguage\n\nin\n\nlanguages\n\nmember\n\nawait\n\nserver\n\nfetch_member\n\nmessage\n\nauthor\n\nid\n\nThis code first checks that the languages set contains values. If so, we use get_guild() to retrieve a Guild object corresponding to our server's ID (remember, guild means server).\n\nWe then use a list comprehension and discord.py's get() function to construct a list of all the roles corresponding to languages in our list. Note that we've used the lower() to ensure all of our strings are in lowercase.\n\nFinally, we retrieve the member object corresponding to the user who sent us the message and our server.\n\nWe now have everything we need to assign roles. Add the following code to the bottom of the if statement, within the body of the if statement:\n\ntry\n\nawait\n\nmember\n\nadd_roles\n\nroles\n\nreason\n\n\"Roles assigned by WelcomeBot.\"\n\nexcept\n\nException\n\nas\n\nprint\n\nawait\n\nmessage\n\nchannel\n\nsend\n\n\"Error assigning roles.\"\n\nelse\n\nawait\n\nmessage\n\nchannel\n\nsend\n\nf\"\"\"You've been assigned the following role\n\n\"s\"\n\nif\n\nlen\n\nlanguages\n\nelse\n\n\"\"\n\non\n\nserver\n\nname\n\n', '\n\njoin\n\nlanguages\n\n.\"\"\"\n\nunpack our\n\nOur operation is wrapped in a try-except-else block. If adding roles fails, we'll print the resulting error to our repl's console and send a generic error message to the user. If it succeeds, we'll send a message to the user informing them of their new roles, making extensive use of string interpolation.\n\nFinally, we need to deal with the case where no languages were found in the user's message. Add an else: block onto the bottom of the if languages: block as below:\n\nelse\n\nawait\n\nmessage\n\nchannel\n\nsend\n\n\"No supported languages were found in your message.\"\n\nRerun your repl and return to your Discord server. Open the DM channel with your bot and try sending it one or more language names or emojis. You should receive the expected roles. You can check this by clicking on your name in the right-hand panel on your Discord server \u2013 your roles will be listed in the box that appears.\n\nRemoving roles\u200b\n\nOur code currently does not allow users to remove roles from themselves. While we could do this manually as the server owner, we've built this bot to avoid having to do that sort of thing, so let's expand our code to allow for role removal.\n\nTo keep things simple, we'll remove any roles mentioned by the user which they already have. So if a user with the \"python\" role writes \"c++ python\", we'll add the \"c++\" role and remove the \"python\" role.\n\nLet's make some changes. Find the if languages: block in your assign_roles() function and change the code above try: to match the below:\n\nif\n\nlanguages\n\nserver\n\nbot\n\nget_guild\n\nSERVER_ID\n\n# <-- RENAMED VARIABLE + LIST CHANGED TO SET\n\nnew_roles\n\nset\n\ndiscord\n\nutils\n\nget\n\nserver\n\nroles\n\nname\n\nlanguage\n\nlower\n\nfor\n\nlanguage\n\nin\n\nlanguages\n\nmember\n\nawait\n\nserver\n\nfetch_member\n\nmessage\n\nauthor\n\nid\n\n# NEW CODE BELOW\n\ncurrent_roles\n\nset\n\nmember\n\nroles\n\nWe replace the list of roles with a set of new roles. We also create a set of roles the user current holds. Given these two sets, we can figure out which roles to add and which to remove using set operations. Add the following code below the definition of current_roles:\n\nroles_to_add\n\nnew_roles\n\ndifference\n\ncurrent_roles\n\nroles_to_remove\n\nnew_roles\n\nintersection\n\ncurrent_roles\n\nThe roles to add will be roles that are in new_roles but not in current_roles, i.e. the difference of the sets. The roles to remove will be roles that are in both sets, i.e. their intersection.\n\nNow we need to replace the try-except-else block with the code below:\n\ntry\n\nawait\n\nmember\n\nadd_roles\n\nroles_to_add\n\nreason\n\n\"Roles assigned by WelcomeBot.\"", "start_char_idx": 9955, "end_char_idx": 14227, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d98602d6-9eb7-4ccb-b6dd-830feef765e7": {"__data__": {"id_": "d98602d6-9eb7-4ccb-b6dd-830feef765e7", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3bc030ae-db9a-437b-a305-be1ab7a076df", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "2311c6849e69c73f9b1d637c0769fb0c7da2b177dd79198e155dd035ab686e93", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6d0bc4f2-5c2b-40d7-88ec-72b2f33730ec", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}, "hash": "282981952b9f964ee286bc64807d9bc04130d73598ed56c5cb9b7fff25387394", "class_name": "RelatedNodeInfo"}}, "hash": "cb18593078634dce1a819fbe08920639c8419b55953810ac1c3e1f0ab58875ee", "text": "We also create a set of roles the user current holds. Given these two sets, we can figure out which roles to add and which to remove using set operations. Add the following code below the definition of current_roles:\n\nroles_to_add\n\nnew_roles\n\ndifference\n\ncurrent_roles\n\nroles_to_remove\n\nnew_roles\n\nintersection\n\ncurrent_roles\n\nThe roles to add will be roles that are in new_roles but not in current_roles, i.e. the difference of the sets. The roles to remove will be roles that are in both sets, i.e. their intersection.\n\nNow we need to replace the try-except-else block with the code below:\n\ntry\n\nawait\n\nmember\n\nadd_roles\n\nroles_to_add\n\nreason\n\n\"Roles assigned by WelcomeBot.\"\n\nawait\n\nmember\n\nremove_roles\n\nroles_to_remove\n\nreason\n\n\"Roles revoked by WelcomeBot.\"\n\nexcept\n\nException\n\nas\n\nprint\n\nawait\n\nmessage\n\nchannel\n\nsend\n\n\"Error assigning/removing roles.\"\n\nelse\n\nif\n\nroles_to_add\n\nawait\n\nmessage\n\nchannel\n\nsend\n\nf\"You've been assigned the following role\n\n's'\n\nif\n\nlen\n\nroles_to_add\n\nelse\n\n''\n\non\n\nserver\n\nname\n\n', '\n\njoin\n\nrole\n\nname\n\nfor\n\nrole\n\nin\n\nroles_to_add\n\nif\n\nroles_to_remove\n\nawait\n\nmessage\n\nchannel\n\nsend\n\nf\"You've lost the following role\n\n's'\n\nif\n\nlen\n\nroles_to_remove\n\nelse\n\n''\n\non\n\nserver\n\nname\n\n', '\n\njoin\n\nrole\n\nname\n\nfor\n\nrole\n\nin\n\nroles_to_remove\n\nThis code follows the same general logic as our original block, but can remove roles as well as add them.\n\nFinally, we need to update the bot's original DM to reflect this new functionality. Find the dm_about_roles() function and amend it as follows:\n\nasync\n\ndef\n\ndm_about_roles\n\nmember\n\nprint\n\nf\"DMing\n\nmember\n\nname\n\n...\"\n\nawait\n\nmember\n\nsend\n\nf\"\"\"Hi\n\nmember\n\nname\n\n, welcome to\n\nmember\n\nguild\n\nname\n\nWhich of these languages do you use:\n\nPython (\ud83d\udc0d)\n\nJavaScript (\ud83d\udd78\ufe0f)\n\nRust (\ud83e\udd80)\n\nGo (\ud83d\udc39)\n\nC++ (\ud83d\udc09)\n\nReply to this message with one or more of the language names or emojis above so I can assign you the right roles on our server.\n\nReply with the name or emoji of a language you're currently using and want to stop and I'll remove that role for you.\n\n\"\"\"\n\nRerun your repl and test it out. You should be able to add and remove roles from yourself. Try inviting some of your friends to your Discord server, and have them use the bot as well. They should receive DMs as soon as they join.\n\nWhere next?\u200b\n\nWe've created a simple Discord server welcome bot. There's a lot of scope for additional functionality. Here are some ideas for expansion:\n\nInclude more complex logic for role assignment. For example, you could have some roles that require users to have been members of the server for a certain amount of time.\n\nHave your bot automatically assign additional user roles based on behavior. For example, you could give a role to users who react to messages with the most emojis.\n\nAdd additional commands. For example, you might want to have a command that searches Stack Overflow, allowing members to ask programming questions from the chat.\n\nDiscord bot code can be hosted on Replit permanently, but you'll need to use a Deployment repl to keep it running 24/7.\n\nYou can find our repl below:\n\n< Previous: Data science\n\nNext: Building an internal organization tool >\n\nWas this helpful?\n\nLast updated on Nov 2, 2023\n\nGetting started\n\nCreating a Discord application\n\nWriting the Discord bot code\n\nCreating server roles\n\nMessaging users\n\nAssigning roles from replies\n\nRemoving roles\n\nWhere next?", "start_char_idx": 13550, "end_char_idx": 16902, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"3bc030ae-db9a-437b-a305-be1ab7a076df": {"node_ids": ["e474b248-8481-41b4-8354-fdea251d5ca5", "d26a959d-85fb-4087-8d45-e2c4ee92aa39", "2e3625e1-aad3-4905-8a88-aa0edb96b9d6", "6d0bc4f2-5c2b-40d7-88ec-72b2f33730ec", "d98602d6-9eb7-4ccb-b6dd-830feef765e7"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-role-bot.html"}}}, "docstore/metadata": {"e474b248-8481-41b4-8354-fdea251d5ca5": {"doc_hash": "32a4e4551a4282253f894f81f07a524ad853d4e7cb57d2c7b4e1f37b5bbaf95c", "ref_doc_id": "3bc030ae-db9a-437b-a305-be1ab7a076df"}, "d26a959d-85fb-4087-8d45-e2c4ee92aa39": {"doc_hash": "b7a61c5f346776d25c410222c4ac144474f4cc880f053b1afce506653d3866e8", "ref_doc_id": "3bc030ae-db9a-437b-a305-be1ab7a076df"}, "2e3625e1-aad3-4905-8a88-aa0edb96b9d6": {"doc_hash": "4ed5d5aa5ca873123ab5c83f0f060f5df0d9fb6b953c3b8cfc17f418f3f7bd01", "ref_doc_id": "3bc030ae-db9a-437b-a305-be1ab7a076df"}, "6d0bc4f2-5c2b-40d7-88ec-72b2f33730ec": {"doc_hash": "282981952b9f964ee286bc64807d9bc04130d73598ed56c5cb9b7fff25387394", "ref_doc_id": "3bc030ae-db9a-437b-a305-be1ab7a076df"}, "d98602d6-9eb7-4ccb-b6dd-830feef765e7": {"doc_hash": "cb18593078634dce1a819fbe08920639c8419b55953810ac1c3e1f0ab58875ee", "ref_doc_id": "3bc030ae-db9a-437b-a305-be1ab7a076df"}}}