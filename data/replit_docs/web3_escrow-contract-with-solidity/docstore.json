{"docstore/data": {"5d784a90-a0bb-4ed0-98f8-62865eefe723": {"__data__": {"id_": "5d784a90-a0bb-4ed0-98f8-62865eefe723", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "31918b49-a93e-4df0-824e-7e1770e71b27", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "1bb90448a5d6e4bb9c6f43c7506ecbcba7e7bf9e5820bf8824dfd397e984adf8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "211db2a9-452f-48b9-a736-f9cb80fa4756", "node_type": "1", "metadata": {}, "hash": "af7706a1397ae65e4fc82e0431c14ebb555c932ddbcfda664d75f57ef270a99d", "class_name": "RelatedNodeInfo"}}, "hash": "cf0cd02cc3af4fcbb9ef8bacacaf1bf7bae82830a9c7afe8613ebd1c51ef8cdb", "text": "Finally, onlyOwner refers to a modifier defined in Ownable. Modifiers are generally used to restrict functions for purposes of access control or state logic. This modifier will ensure that only the owner of the NFT contract is allowed to mint NFTs.\n\nNow that we've read and understood the function definition, let's add the function body:\n\nfunction mint(address _recipient, uint256 _amount, uint256 _matureTime) public onlyOwner returns (uint256) {\n\n_mint(_recipient, tokenCounter);\n\n// set values\n\namount[tokenCounter] = _amount;\n\nmatureTime[tokenCounter] = _matureTime;\n\n// increment counter\n\ntokenCounter++;\n\nreturn tokenCounter - 1; // return ID\n\nHere we use ERC721's internal _mint() function to mint a new token to the recipient with the current value of tokenCounter as its ID. We then set the amount and matureTime mappings for our new token. Finally, we increment tokenCounter and return the ID of our token.\n\nNext, we need to make a function that will return the details of a given token. Add the following code below the body of the mint() function:\n\nfunction tokenDetails(uint256 _tokenId) public view returns (uint256, uint256) {\n\nrequire(_exists(_tokenId), \"EscrowNFT: Query for nonexistent token\");\n\nreturn (amount[_tokenId], matureTime[_tokenId]);\n\nWe declare this as a view function. This declaration asserts that the function does not modify state, and thus its invocation does not need to be recorded on-chain. This means it will be callable for free.\n\nOur function body starts with a require statement. This is an error-handling function in Solidity: if the condition in the first argument is not met, the current transaction will revert (undoing all previous actions) and the error message in the second argument will be displayed.\n\nIf invoked with an existing token ID, this function will return two uint256 values, the amount and matureTime for that ID. Note the syntax for multiple return.\n\nWe're almost done with our NFT contract! Before we move on, we need to add a few boilerplate functions. Add the following code below the body of your tokenDetails() function:\n\nfunction contractAddress() public view returns (address) {\n\nreturn address(this);\n\nfunction _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override(ERC721, ERC721Enumerable) { }\n\nfunction supportsInterface(bytes4 _interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) { }\n\nOur first function will return the contract's address. This will make it easier to work with in the Replit web interface.\n\nThe last two functions resolve ambiguities introduced by Solidity's multiple inheritance. Because we're using two different ERC-721 extensions, the base ERC721 contract is inherited twice with different functions added and overridden. To resolve the compiler's confusion, we specify that the versions of _beforeTokenTransfer() and supportsInterface() provided by ERC721Enumerable should be preferred.\n\nEscrow contract\u200b\n\nNow we need to create our Escrow contract, which will act as an interface for creating and redeeming escrows. Add the following contract block to the bottom of contract.sol, below the EscrowNFT contract:\n\ncontract Escrow is Ownable {\n\nEscrowNFT public escrowNFT;\n\nbool public initialized = false;\n\nevent Escrowed(address _from, address _to, uint256 _amount, uint256 _matureTime);\n\nevent Redeemed(address _recipient, uint256 _amount);\n\nevent Initialized(address _escrowNft);\n\nThis contract inherits from Ownable. We define two state variables:\n\nescrowNFT: This is the instance of the EscrowNFT contract that our Escrow contract will use.\n\ninitialized: This variable will help us to implement the initializable design pattern.\n\nWe also define a number of events. Events provide a user-friendly form of logging on the blockchain and are commonly used by dApps (decentralized apps -- i.e. web frontends for smart contracts). It's considered best practice to emit events whenever a state change is made, so we've defined events for our contract's three state-changing actions:\n\nCreation of escrow NFTs.\n\nRedeeming of escrowed funds.\n\nInitialization of the contract.\n\nLet's implement initialization now. Add the following code below your event definitions:\n\nmodifier isInitialized() {\n\nrequire(initialized, \"Contract is not yet initialized\");\n\n_;\n\nfunction initialize(address _escrowNftAddress) external onlyOwner {\n\nrequire(!initialized, \"Contract already initialized.", "start_char_idx": 0, "end_char_idx": 4427, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "211db2a9-452f-48b9-a736-f9cb80fa4756": {"__data__": {"id_": "211db2a9-452f-48b9-a736-f9cb80fa4756", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "31918b49-a93e-4df0-824e-7e1770e71b27", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "1bb90448a5d6e4bb9c6f43c7506ecbcba7e7bf9e5820bf8824dfd397e984adf8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5d784a90-a0bb-4ed0-98f8-62865eefe723", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "cf0cd02cc3af4fcbb9ef8bacacaf1bf7bae82830a9c7afe8613ebd1c51ef8cdb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "896f70e9-0afa-429e-92a7-c8e1ccd8fa6f", "node_type": "1", "metadata": {}, "hash": "6cfa9b4f35a8fd922c19fd728a291c79680b53646f2070be1f4f960a59e5960f", "class_name": "RelatedNodeInfo"}}, "hash": "af7706a1397ae65e4fc82e0431c14ebb555c932ddbcfda664d75f57ef270a99d", "text": "We define two state variables:\n\nescrowNFT: This is the instance of the EscrowNFT contract that our Escrow contract will use.\n\ninitialized: This variable will help us to implement the initializable design pattern.\n\nWe also define a number of events. Events provide a user-friendly form of logging on the blockchain and are commonly used by dApps (decentralized apps -- i.e. web frontends for smart contracts). It's considered best practice to emit events whenever a state change is made, so we've defined events for our contract's three state-changing actions:\n\nCreation of escrow NFTs.\n\nRedeeming of escrowed funds.\n\nInitialization of the contract.\n\nLet's implement initialization now. Add the following code below your event definitions:\n\nmodifier isInitialized() {\n\nrequire(initialized, \"Contract is not yet initialized\");\n\n_;\n\nfunction initialize(address _escrowNftAddress) external onlyOwner {\n\nrequire(!initialized, \"Contract already initialized.\");\n\nescrowNFT = EscrowNFT(_escrowNftAddress);\n\ninitialized = true;\n\nemit Initialized(_escrowNftAddress);\n\nHere we define a custom modifier, isInitialized, which will revert if initialized is false. If initialized is true, the function we apply this modifier to will execute at _.\n\nNext, we define our initialize() function, which takes a single argument: the address of the EscrowNFT contract to use. We've given this function external visibility, so it can only be called by an external user, and applied the onlyOwner modifier, so only the contract's owner can initialize it.\n\nIn the function body, we ensure that the contract is not already initialized, and then we initialize our escrowNFT state variable, set initialized to true, and emit an event.\n\nNow we need a function that allows us to create escrow NFTs. Add the following code below the initialize function:\n\nfunction escrowEth(address _recipient, uint256 _duration) external payable isInitialized {\n\nrequire(_recipient != address(0), \"Cannot escrow to zero address.\");\n\nrequire(msg.value > 0, \"Cannot escrow 0 ETH.\");\n\nuint256 amount = msg.value;\n\nuint256 matureTime = block.timestamp + _duration;\n\nescrowNFT.mint(_recipient, amount, matureTime);\n\nemit Escrowed(msg.sender,\n\n_recipient,\n\namount,\n\nmatureTime);\n\nOur escrowEth function is payable, which means it can receive Ether, and it uses the isInitialized modifier. It takes a recipient address and an escrow duration, specified in seconds.\n\nIn the function body, we ensure that the recipient is not the zero address, to prevent users from accidentally minting NFTs without specifying the receiver, and that the amount of Ether to be escrowed (accessible from msg.value) is greater than zero.\n\nWe then set the amount and matureTime values for our NFT, using block.timestamp to get the current time (approximately). These values are provided to escrowNFT.mint, which will mint our NFT to the specified recipient.\n\nFinally, we emit an event, using msg.sender to retrieve the address of the user who called the function.\n\nNow that we can create escrow NFTs, we need a way for the recipient to redeem the funds in a matured NFT. Let's create a function for that now, below the definition of our escrowEth function:\n\nfunction redeemEthFromEscrow(uint256 _tokenId) external isInitialized {\n\nrequire(escrowNFT.ownerOf(_tokenId) == msg.sender, \"Must own token to claim underlying Eth\");\n\n(uint256 amount, uint256 matureTime) = escrowNFT.tokenDetails(_tokenId);\n\nrequire(matureTime <= block.timestamp, \"Escrow period not expired.\");\n\nescrowNFT.burn(_tokenId);\n\n(bool success, ) = msg.sender.call{value: amount}(\"\");\n\nrequire(success, \"Transfer failed.\");\n\nemit Redeemed(msg.sender, amount);\n\nOur redemption function first checks whether msg.sender is the owner of the token, to prevent users from attempting to redeem tokens they don't own. It then retrieves the amount and matureTime for the specified token ID, and checks whether the matureTime has passed.\n\nIf the token is owned by msg.sender and its matureTime has passed, it is burned using the burn() function from ERC721Burnable. This destroys the token, ensuring that it cannot be redeemed again.\n\nOnce the token is destroyed, we transfer its underlying Ether to msg.sender. As the creator of the escrow NFT originally paid this amount of Ether into the contract, it should still be available. There are a few different ways of sending Ether in Solidity -- using call is the best one.", "start_char_idx": 3476, "end_char_idx": 7878, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "896f70e9-0afa-429e-92a7-c8e1ccd8fa6f": {"__data__": {"id_": "896f70e9-0afa-429e-92a7-c8e1ccd8fa6f", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "31918b49-a93e-4df0-824e-7e1770e71b27", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "1bb90448a5d6e4bb9c6f43c7506ecbcba7e7bf9e5820bf8824dfd397e984adf8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "211db2a9-452f-48b9-a736-f9cb80fa4756", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "af7706a1397ae65e4fc82e0431c14ebb555c932ddbcfda664d75f57ef270a99d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e210013b-339e-4079-9221-1a61e12af887", "node_type": "1", "metadata": {}, "hash": "846d46a5335b52f83b94c429d6814be825c6836bee50ad014c16ffc1bf33ff74", "class_name": "RelatedNodeInfo"}}, "hash": "6cfa9b4f35a8fd922c19fd728a291c79680b53646f2070be1f4f960a59e5960f", "text": "\");\n\nescrowNFT.burn(_tokenId);\n\n(bool success, ) = msg.sender.call{value: amount}(\"\");\n\nrequire(success, \"Transfer failed.\");\n\nemit Redeemed(msg.sender, amount);\n\nOur redemption function first checks whether msg.sender is the owner of the token, to prevent users from attempting to redeem tokens they don't own. It then retrieves the amount and matureTime for the specified token ID, and checks whether the matureTime has passed.\n\nIf the token is owned by msg.sender and its matureTime has passed, it is burned using the burn() function from ERC721Burnable. This destroys the token, ensuring that it cannot be redeemed again.\n\nOnce the token is destroyed, we transfer its underlying Ether to msg.sender. As the creator of the escrow NFT originally paid this amount of Ether into the contract, it should still be available. There are a few different ways of sending Ether in Solidity -- using call is the best one. call returns two values, but we only want the first one, so we leave out the second variable declaration in our multiple return syntax.\n\nIf the Ether transfer fails, we revert, undoing the destruction of the token. Otherwise we emit an event to record the escrow redemption.\n\nOur contract now does the main things it needs to, but we can make some improvements. For example, rather than requiring users to specify the ID of the token they want to redeem, we can create a function that redeems all matured tokens in their possession. Let's do this now, by adding a new function beneath the definition of redeemEthFromEscrow:\n\nfunction redeemAllAvailableEth() external isInitialized {\n\nuint256 nftBalance = escrowNFT.balanceOf(msg.sender);\n\nrequire(nftBalance > 0, \"No escrow NFTs to redeem.\");\n\nuint256 totalAmount = 0;\n\nfor (uint256 i = 0; i < nftBalance; i++) {\n\nuint256 tokenId = escrowNFT.tokenOfOwnerByIndex(msg.sender, i);\n\n(uint256 amount, uint256 matureTime) = escrowNFT.tokenDetails(tokenId);\n\nif (matureTime <= block.timestamp) {\n\nescrowNFT.burn(tokenId);\n\ntotalAmount += amount;\n\nrequire(totalAmount > 0, \"No Ether to redeem.\");\n\n(bool success, ) = msg.sender.call{value: totalAmount}(\"\");\n\nrequire(success, \"Transfer failed.\");\n\nemit Redeemed(msg.sender, totalAmount);\n\nWe start by querying escrowNFT.balanceOf() to find out the number of escrow NFT tokens msg.sender owns. If they own none, we revert.\n\ntokenOfOwnerByIndex, a function defined in\n\nOnce the for loop has completed, we check whether totalAmount is greater than zero, and revert if it isn't. We then send the totalAmount in Ether to msg.sender. At this point, you may wonder why we didn't just loop through the user's NFTs and called redeem on each one, to avoid repeating code. While this would make our code simpler to read, it would lead to a lot of extra checks and transfers, which would make this function more expensive for users to call. When developing smart contracts, keeping the cost of each function invocation to a minimum is paramount.\n\nLet's add one more function before we deploy our contracts. You should recognize contractAddress() from EscrowNFT above. Add it below the definition of redeemAllAvailableEth().\n\nfunction contractAddress() public view returns (address) {\n\nreturn address(this);\n\nAnd with that, our code is complete!\n\nTesting our protocol\u200b\n\nNow that we've written our contracts, it's time to deploy them to the Replit testnet and test them out. We'll use our repl's web interface to do this.\n\nFirst, run your repl. Once all of the dependencies are installed, you should see the Replit Ethereum web interface in your repl's browser. It looks like this:\n\nConnect your MetaMask wallet to the web interface and switch to the Replit testnet. Then click the link to get 1 ETH for testing. Wait until 1 ETH shows up in your wallet balance on the top right of the page.\n\nNow you can deploy your contracts. Select \"Escrow\" from the drop-down box and click Deploy. Approve the MetaMask pop-up that appears. Then do the same with \"EscrowNFT\".\n\nOnce both of these contracts have been deployed, they will show up as expandable boxes below the drop-down box. Expand both and take a look at all the different functions available.\n\nBefore we can use either of these contracts, we need to do some setup. First, let's initialize Escrow.", "start_char_idx": 6965, "end_char_idx": 11205, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e210013b-339e-4079-9221-1a61e12af887": {"__data__": {"id_": "e210013b-339e-4079-9221-1a61e12af887", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "31918b49-a93e-4df0-824e-7e1770e71b27", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "1bb90448a5d6e4bb9c6f43c7506ecbcba7e7bf9e5820bf8824dfd397e984adf8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "896f70e9-0afa-429e-92a7-c8e1ccd8fa6f", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "6cfa9b4f35a8fd922c19fd728a291c79680b53646f2070be1f4f960a59e5960f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b249d472-c63b-4aee-96e2-4aaf2e1ef4cf", "node_type": "1", "metadata": {}, "hash": "f0161f8c26c929873cef6ea083dbe7b145601f3426e7e805e6d1d44a1b199c89", "class_name": "RelatedNodeInfo"}}, "hash": "846d46a5335b52f83b94c429d6814be825c6836bee50ad014c16ffc1bf33ff74", "text": "First, run your repl. Once all of the dependencies are installed, you should see the Replit Ethereum web interface in your repl's browser. It looks like this:\n\nConnect your MetaMask wallet to the web interface and switch to the Replit testnet. Then click the link to get 1 ETH for testing. Wait until 1 ETH shows up in your wallet balance on the top right of the page.\n\nNow you can deploy your contracts. Select \"Escrow\" from the drop-down box and click Deploy. Approve the MetaMask pop-up that appears. Then do the same with \"EscrowNFT\".\n\nOnce both of these contracts have been deployed, they will show up as expandable boxes below the drop-down box. Expand both and take a look at all the different functions available.\n\nBefore we can use either of these contracts, we need to do some setup. First, let's initialize Escrow.\n\nIn EscrowNFT, run the view function contractAddress. Click on the output to copy it to your clipboard.\n\nIn Escrow, find the initialize function. Paste the contents of your clipboard into the value for _escrowNftAddress.\n\nRun the initialize function and confirm the MetaMask pop-up that appears.\n\nLuckily, Ownable provides functionality for transferring ownership, so we can transfer EscrowNFT to Escrow in the following steps:\n\nIn Escrow, run the view function contractAddress. Click on the output to copy it to your clipboard.\n\nIn EscrowNFT, find the transferOwnership function. Paste the contents of your clipboard into the value for newOwner.\n\nRun the transferOwnership function and confirm the MetaMask pop-up that appears.\n\nNow Escrow owns EscrowNFT and our system will work. Let's test it out by doing the following:\n\nFind the escrowEth function in Escrow.\n\nSpecify your own address, a short duration and a small amount of Ether.\n\nRun the escrowEth function and approve the MetaMask pop-up that appears.\n\nIf you attempt to claim your escrowed Ether using either of the redemption functions in Escrow before the duration has passed, the transaction should fail with the expected error message. However, if you wait for the duration to pass and then call either of the redemption functions, the transaction will fail for a different reason.\n\nBoth redemption functions call EscrowNFT's burn() function to burn tokens. This is an access-controlled function, available only to the token owner and addresses approved by the token owner. If this weren't the case, anyone could burn any token just by calling the function.\n\nTo allow Escrow to burn our NFT, we need to give it approval. We can do this in the following steps:\n\nIn EscrowNFT, find the setApprovalForAll function.\n\nCopy the address from Escrow's contractAddress function output.\n\nPaste in the address as the value for operator and specify true as the value for approved.\n\nRun the setApprovalForAll function and confirm the MetaMask pop-up that appears.\n\nOnce approval is set, you should be able to successfully redeem the escrowed Ether from your mature tokens.\n\nSecurity and trust considerations for smart contract development\u200b\n\nWe've written our escrow system as a way to learn about Solidity development and interacting with smart contracts on the blockchain. To facilitate these outcomes, our contracts make use of a design that is partially insecure and would not be recommended in practice.\n\nA key part of earning user trust as a smart contract developer is to ensure that you have minimal control over the contracts you deploy. That's why, for example, we designed the initialize() function in Escrow to only be callable once. If a contract has a large number of privileged functions that make significant changes to its state and behavior, there is a risk that the owner -- or a hacker who manages to compromise the owner's wallet -- will use these functions to steal user funds.\n\nAn unscrupulous developer could create a malicious version of our escrow protocol by doing the following:\n\nAfter deploying EscrowNFT but before transferring its ownership, they could call mint() to create an Escrow token with an amount of 100.\n\nThey could then transfer EscrowNFT's ownership to Escrow, and wait for users to start paying Ether to Escrow in order to create tokens.\n\nOnce Escrow had a balance of 100 Ether or more, the developer could redeem their token, successfully stealing all user funds.\n\nRedemption of any subsequent escrow tokens would fail, as the Escrow contract would contain insufficient funds.\n\nWhile the evidence of all of this happening would be visible on the blockchain, through events, users may not want or easily be able to look at that information before using the protocol.\n\nAnother, less serious, consideration is that block.timestamp is not always accurate.", "start_char_idx": 10380, "end_char_idx": 15052, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b249d472-c63b-4aee-96e2-4aaf2e1ef4cf": {"__data__": {"id_": "b249d472-c63b-4aee-96e2-4aaf2e1ef4cf", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "31918b49-a93e-4df0-824e-7e1770e71b27", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "1bb90448a5d6e4bb9c6f43c7506ecbcba7e7bf9e5820bf8824dfd397e984adf8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e210013b-339e-4079-9221-1a61e12af887", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}, "hash": "846d46a5335b52f83b94c429d6814be825c6836bee50ad014c16ffc1bf33ff74", "class_name": "RelatedNodeInfo"}}, "hash": "f0161f8c26c929873cef6ea083dbe7b145601f3426e7e805e6d1d44a1b199c89", "text": "An unscrupulous developer could create a malicious version of our escrow protocol by doing the following:\n\nAfter deploying EscrowNFT but before transferring its ownership, they could call mint() to create an Escrow token with an amount of 100.\n\nThey could then transfer EscrowNFT's ownership to Escrow, and wait for users to start paying Ether to Escrow in order to create tokens.\n\nOnce Escrow had a balance of 100 Ether or more, the developer could redeem their token, successfully stealing all user funds.\n\nRedemption of any subsequent escrow tokens would fail, as the Escrow contract would contain insufficient funds.\n\nWhile the evidence of all of this happening would be visible on the blockchain, through events, users may not want or easily be able to look at that information before using the protocol.\n\nAnother, less serious, consideration is that block.timestamp is not always accurate. As this value is derived from when Ethereum miners report it, it can be manipulated slightly. This will have a negligible effect on escrow periods of multiple days, weeks or months, but could affect very short escrow periods quite significantly.\n\nWhat next?\u200b\n\nNow that you've got your feet wet with Solidity development, here are some ideas for further development:\n\nModify the architecture of the protocol to make it impossible to create a malicious version in the manner described above.\n\nCreate a view function in Escrow that tells the user how much Ether is available for redemption.\n\nDetermine whether the user has approved Escrow before attempting to burn tokens. Add a nice error message if they haven't.\n\nCreate an ERC-20 token and allow users to escrow it instead of Ether.\n\nSee if you can rewrite any of the contract functions to use less gas.\n\nYou can find our repl here:\n\n< Previous: Smart contract oracle with Solidity\n\nNext: HTML, CSS, and JS >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting startedSolidity replBrowser wallet\n\nIntroduction to smart contract development\n\nEscrow protocol design\n\nEscrow NFT\n\nEscrow contract\n\nTesting our protocol\n\nSecurity and trust considerations for smart contract development\n\nWhat next?", "start_char_idx": 14157, "end_char_idx": 16301, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"31918b49-a93e-4df0-824e-7e1770e71b27": {"node_ids": ["5d784a90-a0bb-4ed0-98f8-62865eefe723", "211db2a9-452f-48b9-a736-f9cb80fa4756", "896f70e9-0afa-429e-92a7-c8e1ccd8fa6f", "e210013b-339e-4079-9221-1a61e12af887", "b249d472-c63b-4aee-96e2-4aaf2e1ef4cf"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/escrow-contract-with-solidity.html"}}}, "docstore/metadata": {"5d784a90-a0bb-4ed0-98f8-62865eefe723": {"doc_hash": "cf0cd02cc3af4fcbb9ef8bacacaf1bf7bae82830a9c7afe8613ebd1c51ef8cdb", "ref_doc_id": "31918b49-a93e-4df0-824e-7e1770e71b27"}, "211db2a9-452f-48b9-a736-f9cb80fa4756": {"doc_hash": "af7706a1397ae65e4fc82e0431c14ebb555c932ddbcfda664d75f57ef270a99d", "ref_doc_id": "31918b49-a93e-4df0-824e-7e1770e71b27"}, "896f70e9-0afa-429e-92a7-c8e1ccd8fa6f": {"doc_hash": "6cfa9b4f35a8fd922c19fd728a291c79680b53646f2070be1f4f960a59e5960f", "ref_doc_id": "31918b49-a93e-4df0-824e-7e1770e71b27"}, "e210013b-339e-4079-9221-1a61e12af887": {"doc_hash": "846d46a5335b52f83b94c429d6814be825c6836bee50ad014c16ffc1bf33ff74", "ref_doc_id": "31918b49-a93e-4df0-824e-7e1770e71b27"}, "b249d472-c63b-4aee-96e2-4aaf2e1ef4cf": {"doc_hash": "f0161f8c26c929873cef6ea083dbe7b145601f3426e7e805e6d1d44a1b199c89", "ref_doc_id": "31918b49-a93e-4df0-824e-7e1770e71b27"}}}