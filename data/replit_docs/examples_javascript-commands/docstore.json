{"docstore/data": {"3d527eb1-50c8-44fc-aa24-42751d305c78": {"__data__": {"id_": "3d527eb1-50c8-44fc-aa24-42751d305c78", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/extensions/examples/javascript-commands.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e8a78102-01c3-4909-ad23-28299a5bbd1c", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/extensions/examples/javascript-commands.html"}, "hash": "23ae549f41260fb34d4df0fe92bfe389e3204f05335b09c33c0f5eac0ca46062", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c65a22e9-0962-4862-9e27-d056ed38be2e", "node_type": "1", "metadata": {}, "hash": "22c1472afd92ebaea30e28c2cf16eaedb3573137074864cce4703eca9d538946", "class_name": "RelatedNodeInfo"}}, "hash": "e2c82d1f188519b182eea150a704a67c102e705f773dd364d09a3ef4009463a8", "text": "res\n\ncontent\n\nreturn\n\nerror\n\nnull\n\nresult\n\npackageJsonObject\n\ncatch\n\nreturn\n\nerror\n\nnew\n\nError\n\n\"Failed to parse package.json: \"\n\nmessage\n\nresult\n\nnull\n\nasync\n\nfunction\n\ngetInstalledPackages\n\nconst\n\npackageJsonRes\n\nawait\n\ngetPackageJson\n\nif\n\npackageJsonRes\n\nerror\n\nreturn\n\npackageJsonRes\n\n// This returns an array of { name, version } objects\n\nconst\n\npackages\n\nObject\n\nentries\n\npackageJsonRes\n\nresult\n\ndependencies\n\nmap\n\nname\n\nversion\n\n=>\n\nname\n\nversion\n\nreturn\n\nerror\n\nnull\n\nresult\n\npackages\n\nArmed with these functions, we can build the uninstall subcommand. The subcommand returns a list of action commands, one per package.\n\nconst\n\nuninstallCommand\n\nlabel\n\n\"Uninstall\"\n\ndescription\n\n\"Uninstall npm packages\"\n\ncommands\n\nasync\n\n=>\n\nconst\n\npackagesRes\n\nawait\n\ngetInstalledPackages\n\nif\n\npackagesRes\n\nerror\n\nreturn\n\nnull\n\nreturn\n\npackagesRes\n\nresult\n\nmap\n\nname\n\nversion\n\n=>\n\nreturn\n\nlabel\n\nname\n\ndescription\n\nversion\n\nrun\n\nasync\n\n=>\n\nawait\n\nreplit\n\nexec\n\nexec\n\nnpm uninstall\n\n${\n\nname\n\nTo add this command to our root command, simply include uninstallCommand as one of the commands returned by the root command:\n\ncommands\n\nasync\n\n=>\n\n// This is where subcomands go:\n\nreturn\n\nuninstallCommand\n\nThis is what it looks like in our JavaScript command now:\n\nAs you can see, the uninstall command lists installed npm packages that you can uninstall\n\nBuilding \"Scripts\"\u200b\n\n\"Scripts\" is very similar to uninstall, except that we need to surface the output from the script. For this, we use an experimental API called execInShell.\n\nOther than that, we can reuse most of the code from \"Uninstall\"\n\nasync\n\nfunction\n\ngetScripts\n\nconst\n\npackageJsonRes\n\nawait\n\ngetPackageJson\n\nif\n\npackageJsonRes\n\nerror\n\nreturn\n\npackageJsonRes\n\n// This returns an array of { name, version } objects\n\nconst\n\nscripts\n\nObject\n\nentries\n\npackageJsonRes\n\nresult\n\nscripts\n\nmap\n\nname\n\ncmd\n\n=>\n\nname\n\ncmd\n\nreturn\n\nerror\n\nnull\n\nresult\n\nscripts\n\nconst\n\nscriptsCommand\n\nlabel\n\n\"Scripts\"\n\ndescription\n\n\"Run scripts in your package.json\"\n\ncommands\n\nasync\n\n=>\n\nconst\n\nscriptsRes\n\nawait\n\ngetScripts\n\nif\n\nscriptsRes\n\nerror\n\nreturn\n\nnull\n\nreturn\n\nscriptsRes\n\nresult\n\nmap\n\nname\n\ncmd\n\n=>\n\nreturn\n\nlabel\n\nname\n\ndescription\n\ncmd\n\nrun\n\nasync\n\n=>\n\nawait\n\nreplit\n\nexperimental\n\nexecInShell\n\nnpm run\n\n${\n\nname\n\nLet's add the scripts command to our root command!\n\ncommands\n\nasync\n\n=>\n\n// This is where subcomands go:\n\nreturn\n\nscriptsCommand\n\nuninstallCommand\n\nHere's our command!\n\nBuilding \"Install\"\u200b\n\n\"Install\" is somewhat different: we are pulling external data from the npm registry in response to the user typing in a search query. And we only want to explicitly trigger this search when the user has indicated that they want to search for npm packages to install\n\nasync\n\nfunction\n\ngetNpmPackages\n\nsearch\n\ntry\n\nconst\n\nres\n\nawait\n\nfetch\n\nhttps://registry.npmjs.org/-/v1/search?text=\n\n${\n\nsearch\n\nconst\n\njson\n\nawait\n\nres\n\njson\n\nreturn\n\nerror\n\nnull\n\nresult\n\njson\n\nobjects\n\ncatch\n\nreturn\n\nerror\n\nresult\n\nnull\n\nconst\n\ninstallCommand\n\nlabel\n\n\"Install\"\n\ndescription\n\n\"Install a package from npm\"\n\ncommands\n\nasync\n\nsearch\n\nactive\n\n=>\n\n// This makes sure we do not perform a search unless someone selects \"Install\"\n\nif\n\nactive\n\nreturn\n\nconst\n\npackagesRes\n\nawait\n\ngetNpmPackages\n\nif\n\npackagesRes\n\nerror\n\nreturn\n\nnull\n\nreturn\n\npackagesRes\n\nresult\n\nmap\n\npkg\n\n=>\n\nreturn\n\nlabel\n\npkg\n\npackage\n\nname\n\ndescription\n\npkg\n\npackage\n\ndescription\n\nrun\n\nasync\n\n=>\n\nawait\n\nreplit\n\nexperimental\n\nexecInShell\n\nnpm i\n\n${\n\npkg\n\npackage\n\nname\n\nNotice the search and active parameters?\n\nactive is true when users have selected the \"Install\" command (as opposed to the command system merely querying for subcommands in advance). We can check for it to make sure that we only query npm when we know that a user is interested in installing an extension.\n\nsearch returns what the user has typed into the command bar, which we use for searching the npm registry\n\nThis means that extensions can decide which scripts are directly accessible from the root CommandBar. For example, the scripts extension can let users search and trigger scripts immediately after opening the CommandBar:\n\nWe are ready to add \"Install\" to the root command!", "start_char_idx": 0, "end_char_idx": 4142, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c65a22e9-0962-4862-9e27-d056ed38be2e": {"__data__": {"id_": "c65a22e9-0962-4862-9e27-d056ed38be2e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/extensions/examples/javascript-commands.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e8a78102-01c3-4909-ad23-28299a5bbd1c", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/extensions/examples/javascript-commands.html"}, "hash": "23ae549f41260fb34d4df0fe92bfe389e3204f05335b09c33c0f5eac0ca46062", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3d527eb1-50c8-44fc-aa24-42751d305c78", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/extensions/examples/javascript-commands.html"}, "hash": "e2c82d1f188519b182eea150a704a67c102e705f773dd364d09a3ef4009463a8", "class_name": "RelatedNodeInfo"}}, "hash": "22c1472afd92ebaea30e28c2cf16eaedb3573137074864cce4703eca9d538946", "text": "active is true when users have selected the \"Install\" command (as opposed to the command system merely querying for subcommands in advance). We can check for it to make sure that we only query npm when we know that a user is interested in installing an extension.\n\nsearch returns what the user has typed into the command bar, which we use for searching the npm registry\n\nThis means that extensions can decide which scripts are directly accessible from the root CommandBar. For example, the scripts extension can let users search and trigger scripts immediately after opening the CommandBar:\n\nWe are ready to add \"Install\" to the root command! This is what our root command object looks like now:\n\nawait\n\nreplit\n\ncommands\n\nadd\n\nid\n\n\"js-commands\"\n\ncontributions\n\nreplit\n\nContributionType\n\nCommandBar\n\ncommand\n\nlabel\n\n\"JS\"\n\ndescription\n\n\"JavaScript Commands\"\n\ncommands\n\nasync\n\n=>\n\n// This is where subcomands go:\n\nreturn\n\ninstallCommand\n\nscriptsCommand\n\nuninstallCommand\n\nOpen the command bar, type in \"Install\", select your new command, and give it a try!\n\nExercises left to the reader\u200b\n\nWe built a basic version of the Javascript commands extension. This could be improved quite a bit:\n\nDid you notice that we only use npm in all the examples? JavaScript ecosystem has a plethora of package managers, including yarn, pnpm, and bun. How can we support all of them? And can we do it \"magically\" where someone using this extension doesn't have to manually select their package manager in our command? (Hint: it involves the lockfiles)\n\nWe can probably cache the npm registry fetch call, so when you backspace through any letters, the results for that search query appear instantly.\n\nWe can debounce npm search requests to prevent hitting npmjs.com excessively while you're typing out the package you're looking for.\n\nWhat happens if someone uses this command in a repl that isn't a Javascript project? We can probably check for the presence of package.json before showing the command. And maybe, if someone doesn't have a package.json yet, we can instead show a command to npm init their project!\n\nIf you just want to look at the solution, see the JavaScript commands extension on the store:\n\nHere's the link to the extension\n\nHere's a link to the extension's source repl\n\n< Previous: Snippet Manager\n\nNext: API Reference >\n\nWas this helpful?\n\nLast updated on Nov 13, 2023\n\nIntroduction\n\nSetting up your extension repl\n\nAdding a root command\n\nBuilding \"Uninstall\"\n\nBuilding \"Scripts\"\n\nBuilding \"Install\"\n\nExercises left to the reader", "start_char_idx": 3500, "end_char_idx": 6029, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"e8a78102-01c3-4909-ad23-28299a5bbd1c": {"node_ids": ["3d527eb1-50c8-44fc-aa24-42751d305c78", "c65a22e9-0962-4862-9e27-d056ed38be2e"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/extensions/examples/javascript-commands.html"}}}, "docstore/metadata": {"3d527eb1-50c8-44fc-aa24-42751d305c78": {"doc_hash": "e2c82d1f188519b182eea150a704a67c102e705f773dd364d09a3ef4009463a8", "ref_doc_id": "e8a78102-01c3-4909-ad23-28299a5bbd1c"}, "c65a22e9-0962-4862-9e27-d056ed38be2e": {"doc_hash": "22c1472afd92ebaea30e28c2cf16eaedb3573137074864cce4703eca9d538946", "ref_doc_id": "e8a78102-01c3-4909-ad23-28299a5bbd1c"}}}