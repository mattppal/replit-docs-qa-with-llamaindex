{"docstore/data": {"9ef58ea6-3fd2-4433-8ae1-ffb6ab55b763": {"__data__": {"id_": "9ef58ea6-3fd2-4433-8ae1-ffb6ab55b763", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6fb81baa-331a-40e2-9219-82c3c0fb42c8", "node_type": "1", "metadata": {}, "hash": "e5c0f4152757b7d7e2204b824e5674e9ddc97800ccea6c2cdda6990eb7e0234f", "class_name": "RelatedNodeInfo"}}, "hash": "48a821b0b2d77506a2e6bb6004b149369107cc6e2b90a430fb3e5d4577c8d21f", "text": "/    \\\n\n,--------.   ,------.\n\n|GiantRat|   |Dragon|\n\n|--------|   |------|\n\n`--------'   `------'\n\nLet's start by implementing our parent class, Actor. This class will define all of the attributes that characters and enemies have in common and implement a fight() method. Add the following code at the bottom of game.py:\n\n# Living creatures\n\nclass\n\nActor\n\ndef\n\n__init__\n\nself\n\nname\n\nhp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nself\n\nname\n\nname\n\nself\n\nhp\n\nhp\n\nself\n\nmax_hp\n\nmax_hp\n\nself\n\nattack\n\nattack\n\nself\n\ndefense\n\ndefense\n\nself\n\nxp\n\nxp\n\nself\n\ngold\n\ngold\n\ndef\n\nfight\n\nself\n\nother\n\ndefense\n\nmin\n\nother\n\ndefense\n\n19\n\n# cap defense value\n\nchance_to_hit\n\nrandom\n\nrandint\n\n20\n\ndefense\n\nif\n\nchance_to_hit\n\ndamage\n\nself\n\nattack\n\nelse\n\ndamage\n\nother\n\nhp\n\n=\n\ndamage\n\nreturn\n\nself\n\nattack\n\nother\n\nhp\n\n<=\n\n#(damage, fatal)\n\nOur __init__() method defines several variables per our game design specification above. Note that we've defined both hp and max_hp: these should be the same value when we first create a character or enemy class, but will diverge for characters and enemies we read from the database. Once we get into the game logic, we will be recreating instances of these classes from the database constantly.\n\nAlso note that self.xp will represent something slightly different in characters and enemies: For characters, it will be the cumulative experience points earned, whereas for enemies it will be the amount of XP rewarded to characters when the enemy is defeated. A more complex design might instead enable enemies to gain experience points and level up like player characters.\n\nThe damage done on a successful hit is determined by the Actor's attack attribute. The function returns a tuple of the amount of damage dealt by the attack and whether it was the fatal blow.\n\nOur Actor class is complete for now. Let's create a Character class that inherits from it and will represent players. Add the following code to the bottom of the game.py file:\n\nclass\n\nCharacter\n\nActor\n\nlevel_cap\n\n10\n\ndef\n\n__init__\n\nself\n\nname\n\nhp\n\nmax_hp\n\nattack\n\ndefense\n\nmana\n\nlevel\n\nxp\n\ngold\n\ninventory\n\nmode\n\nbattling\n\nuser_id\n\nsuper\n\n__init__\n\nname\n\nhp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nself\n\nmana\n\nmana\n\nself\n\nlevel\n\nlevel\n\nself\n\ninventory\n\ninventory\n\nself\n\nmode\n\nmode\n\nself\n\nbattling\n\nbattling\n\nself\n\nuser_id\n\nuser_id\n\nOur Character class has all the same attributes as Actor, plus some additional ones:\n\nmana represents the character's capacity for casting spells.\n\nlevel is the character's level. This will start at 1 and increase with every 10 XP the player earns.\n\ninventory is a list of items carried by the character.\n\nmode is the game mode we defined an enum for above. Two characters will be in different modes depending on their actions.\n\nbattling is a variable we'll use to store the enemy object that the character is currently fighting. This will be None outside of battle mode.\n\nuser_id is the Discord user ID of the user who created this character.\n\nAlso, note the class variable level_cap: this will be the highest possible value of level.\n\nWe'll come back to the Character class and use it to implement gameplay actions later, but first let's define the enemy classes, starting with Enemy.\n\nclass\n\nEnemy\n\nActor\n\ndef\n\n__init__\n\nself\n\nname\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nsuper\n\n__init__\n\nname\n\nmax_hp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nFor now, this is a straightforward subclass of Actor that uses the same value for hp and max_hp but doesn't define anything extra. We'll specify the actual stats of individual enemy types in the Enemy subclasses, of which we'll define ten.", "start_char_idx": 0, "end_char_idx": 3581, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6fb81baa-331a-40e2-9219-82c3c0fb42c8": {"__data__": {"id_": "6fb81baa-331a-40e2-9219-82c3c0fb42c8", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9ef58ea6-3fd2-4433-8ae1-ffb6ab55b763", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "48a821b0b2d77506a2e6bb6004b149369107cc6e2b90a430fb3e5d4577c8d21f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "90db1392-5889-4767-86a9-7a7458a5f7a0", "node_type": "1", "metadata": {}, "hash": "f729255f42aebb48d06cba547656864e95c4bb7bf67bb5989bea61adb85be11c", "class_name": "RelatedNodeInfo"}}, "hash": "e5c0f4152757b7d7e2204b824e5674e9ddc97800ccea6c2cdda6990eb7e0234f", "text": "battling is a variable we'll use to store the enemy object that the character is currently fighting. This will be None outside of battle mode.\n\nuser_id is the Discord user ID of the user who created this character.\n\nAlso, note the class variable level_cap: this will be the highest possible value of level.\n\nWe'll come back to the Character class and use it to implement gameplay actions later, but first let's define the enemy classes, starting with Enemy.\n\nclass\n\nEnemy\n\nActor\n\ndef\n\n__init__\n\nself\n\nname\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nsuper\n\n__init__\n\nname\n\nmax_hp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nFor now, this is a straightforward subclass of Actor that uses the same value for hp and max_hp but doesn't define anything extra. We'll specify the actual stats of individual enemy types in the Enemy subclasses, of which we'll define ten. Copy-paste the code below at the bottom of game.py to implement those classes:\n\nclass\n\nGiantRat\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83d\udc00 Giant Rat\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nGiantSpider\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83d\udd77\ufe0f Giant Spider\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nBat\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83e\udd87 Bat\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nCrocodile\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83d\udc0a Crocodile\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nWolf\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83d\udc3a Wolf\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nPoodle\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83d\udc29 Poodle\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nSnake\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83d\udc0d Snake\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nLion\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83e\udd81 Lion\"\n\n# HP, attack, defense, XP, gold\n\nclass\n\nDragon\n\nEnemy\n\nmin_level\n\ndef\n\n__init__\n\nself\n\nsuper\n\n__init__\n\n\"\ud83d\udc09 Dragon\"\n\n10\n\n# HP, attack, defense, XP, gold\n\nIn addition to providing names and hardcoded HP, attack, defense, XP, and gold values, we've implemented min_level as a class variable. This specifies the minimum level the player must be to face this enemy. By implementing this, we avoid having low-level players die instantly against too-powerful enemies and ensure that new enemies will show up as the player levels up, creating a sense of progression. Feel free to change any of these enemies, or add your own.\n\nSaving and loading from the database\u200b\n\nWe've now defined our player and enemy classes, though they don't do much. But before we implement any actual gameplay, we need a way to ensure that our characters and enemies maintain their state from one moment to the next. Presently, any Actor instances we create will disappear as soon as our repl finishes running or is stopped. We need to use our repl's database to ensure that players can keep the characters they create and that changes such as losing and gaining HP and leveling up will persist.\n\nThe most important objects in our game are the instances of Character. These objects store character stats, inventory, and even game mode and the enemy currently being fought. So as long as we can save and load the state of individual characters from our database, our game world will feel permanent. For now, we don't need to worry about storing anything else.\n\nReturn to the definition of Character and add the following save_to_db() method below the __init__() method:\n\nclass\n\nCharacter\n\nActor\n\n# ...\n\ndef\n\nsave_to_db\n\nself\n\ncharacter_dict\n\ndeepcopy\n\nvars\n\nself\n\nif\n\nself\n\nbattling\n\n!=\n\nNone\n\ncharacter_dict\n\n\"battling\"\n\ndeepcopy\n\nvars\n\nself\n\nbattling\n\ndb\n\n\"characters\"\n\nself\n\nuser_id\n\ncharacter_dict\n\nAt the top of game.py, we imported db from the replit Python library \u2013 this object provides an interface to our repl's database.", "start_char_idx": 2734, "end_char_idx": 6561, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "90db1392-5889-4767-86a9-7a7458a5f7a0": {"__data__": {"id_": "90db1392-5889-4767-86a9-7a7458a5f7a0", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6fb81baa-331a-40e2-9219-82c3c0fb42c8", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "e5c0f4152757b7d7e2204b824e5674e9ddc97800ccea6c2cdda6990eb7e0234f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "65868151-ec8b-4d45-8088-3b1957eff73a", "node_type": "1", "metadata": {}, "hash": "5925588a4f52cba6e8955ef05c3db1de21c6ee6907d6778e92e948ef7e548e41", "class_name": "RelatedNodeInfo"}}, "hash": "f729255f42aebb48d06cba547656864e95c4bb7bf67bb5989bea61adb85be11c", "text": "The most important objects in our game are the instances of Character. These objects store character stats, inventory, and even game mode and the enemy currently being fought. So as long as we can save and load the state of individual characters from our database, our game world will feel permanent. For now, we don't need to worry about storing anything else.\n\nReturn to the definition of Character and add the following save_to_db() method below the __init__() method:\n\nclass\n\nCharacter\n\nActor\n\n# ...\n\ndef\n\nsave_to_db\n\nself\n\ncharacter_dict\n\ndeepcopy\n\nvars\n\nself\n\nif\n\nself\n\nbattling\n\n!=\n\nNone\n\ncharacter_dict\n\n\"battling\"\n\ndeepcopy\n\nvars\n\nself\n\nbattling\n\ndb\n\n\"characters\"\n\nself\n\nuser_id\n\ncharacter_dict\n\nAt the top of game.py, we imported db from the replit Python library \u2013 this object provides an interface to our repl's database. The db object is designed to be used like a dictionary, so we can create keys and values as we would with any other dictionary. Our database layout will look like this:\n\n\"characters\": {\n\n\"123456789012345678\": {\n\n\"name\": \"Bob the Dwarf\"\n\n\"hp\": 10,\n\n...\n\n},\n\n\"823486788042375673\": {\n\n\"name\": \"Eric the Human\"\n\n\"hp\": 8,\n\n...\n\n},\n\n...\n\nThe vars() function is a Python built-in that returns the value of __dict__ for any class, module, or instance we pass to it. For most instances, this will be a dictionary containing that instance's attributes. In the case of our Character object, the dictionary will contain all of the attributes we defined in __init__. We use deepcopy() to make a full copy of this dictionary.\n\nAny attributes that contain strings, numbers, boolean values, or even lists or dictionaries can be easily and meaningfully stored in our repl's database. Attributes that reference instances of our custom classes cannot be usefully stored, as the referenced instance may not exist the next time the data is loaded. The deepcopy() operation alone does not solve this problem. Thus, we need to store the object referenced by battling as a dictionary of its attributes using vars(), just like we did for the Character instance.\n\nHowever, we have a slight problem: While we can store the attributes of the enemy, this way we're not storing its class. There are a few ways we could resolve this issue \u2013 the easiest one is to store the instance's class name as an attribute. Go to your Enemy class's __init__() method and add the following line:\n\nclass\n\nEnemy\n\nActor\n\ndef\n\n__init__\n\nself\n\nname\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nsuper\n\n__init__\n\nname\n\nmax_hp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\n# NEW LINE BELOW\n\nself\n\nenemy\n\nself\n\n__class__\n\n__name__\n\nThis new line will store the name of the class as a string, which we can write to the database.\n\nWe've now written all the code we'll need to save player characters to the database. Now we need a way to load them back into the game. Fortunately, we already have most of what we need to do this in our Character.__init__() method. A line of code like the following will initialize a new Character with details from our database:\n\nCharacter\n\n**\n\ndb\n\n\"characters\"\n\n\"123456789012345678\"\n\nThe only problem here is that the value of battling will be a dictionary rather than a subclass of Enemy. We can fix this by making some changes to Character.__init__(). Find the method and replace the line self.battling = battling with the new code below:\n\nclass\n\nCharacter\n\nActor\n\nlevel_cap\n\n10\n\ndef\n\n__init__\n\nself\n\nname\n\nhp\n\nmax_hp\n\nattack\n\ndefense\n\nmana\n\nlevel\n\nxp\n\ngold\n\ninventory\n\nmode\n\nbattling\n\nuser_id\n\nsuper\n\n__init__\n\nname\n\nhp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nself\n\nmana\n\nmana\n\nself\n\nlevel\n\nlevel\n\nself\n\ninventory\n\ninventory\n\nself\n\nmode\n\nmode\n\n# NEW CODE BELOW THIS LINE\n\nif\n\nbattling\n\n!=\n\nNone\n\nenemy_class\n\nstr_to_class\n\nbattling\n\n\"enemy\"\n\nself\n\nbattling\n\nenemy_class\n\nself\n\nbattling\n\nrehydrate\n\n**\n\nbattling\n\nelse\n\nself\n\nbattling\n\nNone\n\n# NEW CODE ABOVE THIS LINE\n\nself\n\nuser_id\n\nuser_id\n\nThis code converts the value of the enemy attribute we created above from a string into a class, initializes a copy of that class, and then calls rehydrate, unpacking the battling dictionary as its arguments.", "start_char_idx": 5728, "end_char_idx": 9821, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "65868151-ec8b-4d45-8088-3b1957eff73a": {"__data__": {"id_": "65868151-ec8b-4d45-8088-3b1957eff73a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "90db1392-5889-4767-86a9-7a7458a5f7a0", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "f729255f42aebb48d06cba547656864e95c4bb7bf67bb5989bea61adb85be11c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8ce1fec2-e2a4-4ca4-9c92-5809e0c103de", "node_type": "1", "metadata": {}, "hash": "86559b2054141c3ec0cd406a4a53bc76b52a6e60670f70a1c47edbda6c4c186d", "class_name": "RelatedNodeInfo"}}, "hash": "5925588a4f52cba6e8955ef05c3db1de21c6ee6907d6778e92e948ef7e548e41", "text": "We'll write both the str_to_class function and the Enemy.rehydrate() method shortly.\n\nThe str_to_class function will take a string and return the class with its name.\n\nThe rehydrate method will set all attributes of the instance to those provided. While we could do this with the __init__() method as we did with Character, this would force us to specify all our attribute values every time we initialize any subclass of Enemy, defeating the point of having subclasses in the first place.\n\nNavigate to the top of game.py and create the str_to_class function just below your imports, as below:\n\n# Helper functions\n\ndef\n\nstr_to_class\n\nclassname\n\nreturn\n\ngetattr\n\nsys\n\nmodules\n\n__name__\n\nclassname\n\nThis function uses the useful Python built-in getattr to retrieve the class corresponding to the string provided as classname. Note that this function will only work for the classes we define.\n\nNext, return to your Enemy class and create the rehydrate() method just below the __init__() method.\n\nclass\n\nEnemy\n\nActor\n\ndef\n\n__init__\n\nself\n\nname\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nsuper\n\n__init__\n\nname\n\nmax_hp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nself\n\nenemy\n\nself\n\n__class__\n\n__name__\n\n# NEW METHOD\n\ndef\n\nrehydrate\n\nself\n\nname\n\nhp\n\nmax_hp\n\nattack\n\ndefense\n\nxp\n\ngold\n\nenemy\n\nself\n\nname\n\nname\n\nself\n\nhp\n\nhp\n\nself\n\nmax_hp\n\nmax_hp\n\nself\n\nattack\n\nattack\n\nself\n\ndefense\n\ndefense\n\nself\n\nxp\n\nxp\n\nself\n\ngold\n\ngold\n\nNote that we're accepting enemy as an argument without using it. This is to prevent errors when unpacking the battling dictionary.\n\nWe will now be able to save characters to the database by calling save_to_db() and load characters from the database by passing a database entry to Character(). As our characters store information about the enemies they're fighting, this is all we need for a persistent game world.\n\nGame actions\u200b\n\nLet's implement the player actions from our design specification. We'll start with hunting, the action that enables characters to seek out enemies to fight. Add the following code to the class definition of Character:\n\ndef\n\nhunt\n\nself\n\n# Generate random enemy to fight\n\nwhile\n\nTrue\n\nenemy_type\n\nrandom\n\nchoice\n\nEnemy\n\n__subclasses__\n\nif\n\nenemy_type\n\nmin_level\n\n<=\n\nself\n\nlevel\n\nbreak\n\nenemy\n\nenemy_type\n\n# Enter battle mode\n\nself\n\nmode\n\nGameMode\n\nBATTLE\n\nself\n\nbattling\n\nenemy\n\n# Save changes to DB after state change\n\nself\n\nsave_to_db\n\nreturn\n\nenemy\n\nFirst, we use random.choice() to choose one of the subclasses of Enemy at random. This random selection will be repeated until we chose an enemy with a minimum level less than or equal to our player character's level.\n\nOnce the enemy is chosen, we initialize an instance of it, switch the game mode, and save a reference to it in battling. We then update the player object in the database and return the enemy object.\n\nWe will need to call save_to_db() at the end of every method that changes the character's state. This includes the fight() method defined in Actor. Add the following method to the Character class to accomplish this:\n\ndef\n\nfight\n\nself\n\nenemy\n\noutcome\n\nsuper\n\nfight\n\nenemy\n\n# Save changes to DB after state change\n\nself\n\nsave_to_db\n\nreturn\n\noutcome\n\nThis method will call Actor.fight(), store its result, update the database, and then return the result.\n\nNext, we'll define a flee() method for escaping from a battle the player character is unlikely to win. Add the following method at the bottom of Character:\n\ndef\n\nflee\n\nself\n\nenemy\n\nif\n\nrandom\n\nrandint\n\nself\n\ndefense\n\n# flee unscathed\n\ndamage\n\nelse\n\n# take damage\n\ndamage\n\nenemy\n\nattack\n\nself\n\nhp\n\n=\n\ndamage\n\n# Exit battle mode\n\nself\n\nbattling\n\nNone\n\nself\n\nmode\n\nGameMode\n\nADVENTURE\n\n# Save to DB after state change\n\nself\n\nsave_to_db\n\nreturn\n\ndamage\n\nself\n\nhp\n\n<=\n\n#(damage, killed)\n\nTo add some uncertainty to the flee action, as well as an additional use for the defense stat, we've implemented a random chance that the player will take a small amount of damage on fleeing. We then empty battling, change the game mode, save the state, and return a tuple of the action outcome, similar to the one returned in Actor.fight().\n\nNext, we'll need a method to call after an enemy is defeated, to give the player character their gold and XP.", "start_char_idx": 9822, "end_char_idx": 14012, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8ce1fec2-e2a4-4ca4-9c92-5809e0c103de": {"__data__": {"id_": "8ce1fec2-e2a4-4ca4-9c92-5809e0c103de", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "65868151-ec8b-4d45-8088-3b1957eff73a", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "5925588a4f52cba6e8955ef05c3db1de21c6ee6907d6778e92e948ef7e548e41", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b83b012d-ea1a-4d89-8b22-a63944e5a395", "node_type": "1", "metadata": {}, "hash": "49b7df8d00a2765d0187612e1bc2b32fff694373d45cfe9c25e838290f9998c9", "class_name": "RelatedNodeInfo"}}, "hash": "86559b2054141c3ec0cd406a4a53bc76b52a6e60670f70a1c47edbda6c4c186d", "text": "We then empty battling, change the game mode, save the state, and return a tuple of the action outcome, similar to the one returned in Actor.fight().\n\nNext, we'll need a method to call after an enemy is defeated, to give the player character their gold and XP. Add the following method definition:\n\ndef\n\ndefeat\n\nself\n\nenemy\n\nif\n\nself\n\nlevel\n\nself\n\nlevel_cap\n\n# no more XP after hitting level cap\n\nself\n\nxp\n\n+=\n\nenemy\n\nxp\n\nself\n\ngold\n\n+=\n\nenemy\n\ngold\n\n# loot enemy\n\n# Exit battle mode\n\nself\n\nbattling\n\nNone\n\nself\n\nmode\n\nGameMode\n\nADVENTURE\n\n# Check if ready to level up after earning XP\n\nready\n\nself\n\nready_to_level_up\n\n# Save to DB after state change\n\nself\n\nsave_to_db\n\nreturn\n\nenemy\n\nxp\n\nenemy\n\ngold\n\nready\n\nIf the player's level is below the cap, we add the enemy's XP onto their own. We then add the enemy's gold to their coin-purse, exit battle mode, and check if they've gained enough XP to level up (using a method we'll implement later). Finally, we save the character's state to the database and return a tuple of the results of this action.\n\nLet's define ready_to_level_up() next:\n\ndef\n\nready_to_level_up\n\nself\n\nif\n\nself\n\nlevel\n\n==\n\nself\n\nlevel_cap\n\n# zero values if we've ready the level cap\n\nreturn\n\nFalse\n\nxp_needed\n\nself\n\nlevel\n\n10\n\nreturn\n\nself\n\nxp\n\n>=\n\nxp_needed\n\nxp_needed\n\nself\n\nxp\n\n#(ready, XP needed)\n\nThis method merely checks whether the current XP is greater than or equal to ten times the character's level. Characters will need 10 XP to advance to level 2, 20 XP to advance to level 3, etc. The method returns a tuple containing a Boolean that indicates whether the character is ready to level up and the amount of XP still needed. As it does not change the character's state, we do not need a call to save_to_db.\n\nNow that we're increasing the player's XP and checking whether they're ready to level up, we need a method to level them up. Add the following method:\n\ndef\n\nlevel_up\n\nself\n\nincrease\n\nready\n\nself\n\nready_to_level_up\n\nif\n\nnot\n\nready\n\nreturn\n\nFalse\n\nself\n\nlevel\n\n# (not leveled up, current level)\n\nself\n\nlevel\n\n+=\n\n# increase level\n\nsetattr\n\nself\n\nincrease\n\ngetattr\n\nself\n\nincrease\n\n# increase chosen stat\n\nself\n\nhp\n\nself\n\nmax_hp\n\n#refill HP\n\n# Save to DB after state change\n\nself\n\nsave_to_db\n\nreturn\n\nTrue\n\nself\n\nlevel\n\n# (leveled up, new level)\n\nAfter ensuring that the player is ready to level up, we increase their level and use Python built-ins setattr and getattr to increment one of the character's stats. We reset their HP to the max value, save the state, and finally return the outcome of the action (a tuple indicating whether leveling up succeeded and what the character's new level is).\n\nThe last method we need is die(), which will be called when a character is defeated in battle. We could handle player death in a few different ways, but for the sake of simplicity, we'll just delete the character from the database.\n\ndef\n\ndie\n\nself\n\nplayer_id\n\nif\n\nself\n\nuser_id\n\nin\n\ndb\n\n\"characters\"\n\nkeys\n\ndel\n\ndb\n\n\"characters\"\n\nself\n\nuser_id\n\nThat's a wrap for our game's logic. Next, we'll integrate with Discord and make our game playable.\n\nCreating a Discord application\u200b\n\nDiscord will serve as the display layer for our game, allowing players to issue commands and see the results of those commands.\n\nOpen another browser tab and visit the Discord Developer Portal. Log in with your Discord account, or create one if you haven't already. Keep your repl open \u2013 we'll return to it soon.\n\nOnce you're logged in, create a new application. Give it a name like \"MyRPG\".\n\nDiscord applications can interact with Discord in several different ways, not all of which require bots, so creating one is optional. That said, we'll need one for this project. Let's create a bot.\n\nClick on Bot in the menu on the left-hand side of the page.\n\nClick Add Bot.\n\nGive your bot a username (such as \"RPGBot\").\n\nClick Reset Token and then Yes, do it!.\n\nCopy the token that appears just under your bot's username.\n\nThe token you just copied is required for the code in our repl to interface with Discord's API.", "start_char_idx": 13752, "end_char_idx": 17778, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b83b012d-ea1a-4d89-8b22-a63944e5a395": {"__data__": {"id_": "b83b012d-ea1a-4d89-8b22-a63944e5a395", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8ce1fec2-e2a4-4ca4-9c92-5809e0c103de", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "86559b2054141c3ec0cd406a4a53bc76b52a6e60670f70a1c47edbda6c4c186d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4dd6a042-8ca6-41dd-a9be-81ddada706ef", "node_type": "1", "metadata": {}, "hash": "b1855ed801de1437d7d8b45dd5ed2c7be3e332fdac4ca28d765e1a4816dcd683", "class_name": "RelatedNodeInfo"}}, "hash": "49b7df8d00a2765d0187612e1bc2b32fff694373d45cfe9c25e838290f9998c9", "text": "Open another browser tab and visit the Discord Developer Portal. Log in with your Discord account, or create one if you haven't already. Keep your repl open \u2013 we'll return to it soon.\n\nOnce you're logged in, create a new application. Give it a name like \"MyRPG\".\n\nDiscord applications can interact with Discord in several different ways, not all of which require bots, so creating one is optional. That said, we'll need one for this project. Let's create a bot.\n\nClick on Bot in the menu on the left-hand side of the page.\n\nClick Add Bot.\n\nGive your bot a username (such as \"RPGBot\").\n\nClick Reset Token and then Yes, do it!.\n\nCopy the token that appears just under your bot's username.\n\nThe token you just copied is required for the code in our repl to interface with Discord's API. Return to your repl and open the Secrets tab in the left sidebar. Create a new secret with DISCORD_TOKEN as its key and the token you copied as its value.\n\nOnce you've done that, return to the Discord developer panel. We need to finish setting up our bot.\n\nYou can leave the Public Bot option enabled or disable it, depending on whether you'd like other people to be able to find and install your bot on their server. Keep in mind that bots on 100 or more servers have to go through a special verification and approval process.\n\nNext, we need to configure access to privileged Gateway Intents. Depending on a bot's functionality, it will require access to different events and sources of data. Events involving users' actions and the content of their messages are considered more sensitive and need to be explicitly enabled.\n\nFor this bot to work, we'll need the Message Content Intent, which will allow our bot to see the content of users' messages. Toggle it to the on position and save changes when prompted.\n\nNow that we've created our application and its bot, we need to add it to a server. We'll walk you through creating a test server for this tutorial, but you can also use any server you've created in the past, as long as the other members won't get too annoyed about it becoming a bot testing ground. You can't use a server that you're just a normal user on, as adding bots requires special privileges.\n\nOpen Discord in your browser. You should already be logged in. Then click on the + icon in the leftmost panel to create a new server. Alternatively, open an existing server you own.\n\nIn a separate tab, return to the Discord Dev Portal and open your application. Then follow these steps to add your bot to your server:\n\nClick on OAuth2 in the left sidebar.\n\nIn the menu that appears under OAuth2, select URL Generator.\n\nUnder Scopes, mark the checkbox labelled bot.\n\nUnder Bot Permissions, mark the checkboxes labelled Read Messages/View Channels and Send Messages.\n\nScroll down and copy the URL under Generated URL.\n\nPaste the URL in your browser's navigation bar and hit enter.\n\nOn the page that appears, select your server from the drop-down box and click Continue.\n\nWhen prompted about permissions, click Authorize, and complete the CAPTCHA.\n\nReturn to your Discord server. You should see that your bot has just joined.\n\nNow that we've done the preparatory work, it's time to write some code. Return to your repl for the next section.\n\nWriting the Discord bot code\u200b\n\nWe'll be using discord.py to interface with Discord's API using Python. Open main.py in your repl and add the following code:\n\nimport\n\nos\n\ndiscord\n\nfrom\n\ndiscord\n\next\n\nimport\n\ncommands\n\nfrom\n\nreplit\n\nimport\n\ndb\n\nfrom\n\ngame\n\nimport\n\nDISCORD_TOKEN\n\nos\n\ngetenv\n\n\"DISCORD_TOKEN\"\n\nbot\n\ncommands\n\nBot\n\ncommand_prefix\n\n\"!\"\n\n@bot\n\nevent\n\nasync\n\ndef\n\non_ready\n\nprint\n\nf\"\n\nbot\n\nuser\n\nhas connected to Discord!\"\n\nbot\n\nrun\n\nDISCORD_TOKEN\n\nFirst, we import the Python libraries we'll need, including discord.py and its commands extension, as well as our database and the contents of game.py.\n\nBot object. We'll use this object to listen for Discord events and respond to them. For the most part, we'll be responding to\n\nHowever, the first event we're interested in is not a command. The on_ready() event will trigger when our bot logs onto Discord (the @bot.event decorator ensures this). All this event will do is print a message to our repl's console, telling us that the bot has connected.\n\nNote that we've prepended async to the function definition \u2013 this makes our on_ready() function into a coroutine.", "start_char_idx": 16995, "end_char_idx": 21358, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4dd6a042-8ca6-41dd-a9be-81ddada706ef": {"__data__": {"id_": "4dd6a042-8ca6-41dd-a9be-81ddada706ef", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b83b012d-ea1a-4d89-8b22-a63944e5a395", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "49b7df8d00a2765d0187612e1bc2b32fff694373d45cfe9c25e838290f9998c9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ad13d4f4-4841-4a67-97e4-230575a40c41", "node_type": "1", "metadata": {}, "hash": "f1a142db305950ca2c639733b6dbf3f653c373be1ce93d5a7d953148c3a8a125", "class_name": "RelatedNodeInfo"}}, "hash": "b1855ed801de1437d7d8b45dd5ed2c7be3e332fdac4ca28d765e1a4816dcd683", "text": "@bot\n\nevent\n\nasync\n\ndef\n\non_ready\n\nprint\n\nf\"\n\nbot\n\nuser\n\nhas connected to Discord!\"\n\nbot\n\nrun\n\nDISCORD_TOKEN\n\nFirst, we import the Python libraries we'll need, including discord.py and its commands extension, as well as our database and the contents of game.py.\n\nBot object. We'll use this object to listen for Discord events and respond to them. For the most part, we'll be responding to\n\nHowever, the first event we're interested in is not a command. The on_ready() event will trigger when our bot logs onto Discord (the @bot.event decorator ensures this). All this event will do is print a message to our repl's console, telling us that the bot has connected.\n\nNote that we've prepended async to the function definition \u2013 this makes our on_ready() function into a coroutine. Coroutines are largely similar to functions, but may not execute immediately, and must be invoked with the await keyword. Using coroutines makes our program asynchronous, which means it can continue executing code while waiting for the results of a long-running function, usually one that depends on input or output. If you've used JavaScript before, you'll recognize this style of programming.\n\nThe final line in our file starts the bot, providing DISCORD_TOKEN to authenticate it. Run your repl now to see it in action. Once it's started, return to your Discord server. You should see that your bot user is now online.\n\nHandling user commands\u200b\n\nNow we can start writing the handlers for our game's actions, such as !create, !hunt, and !fight.\n\nThe discord.py commands extension allows us to define command handlers using the @bot.command decorator. Without this, we'd have to manually parse the content of all user messages to determine whether a command has been issued, as was necessary for our role assignment bot tutorial.\n\nCharacter creation\u200b\n\nFirst, we'll implement our character creation command, !create. Add the following code to main.py below the definition of on_ready():\n\n# Commands\n\n@bot\n\ncommand\n\nname\n\n\"create\"\n\nhelp\n\n\"Create a character.\"\n\nasync\n\ndef\n\ncreate\n\nctx\n\nname\n\nNone\n\nuser_id\n\nctx\n\nmessage\n\nauthor\n\nid\n\n# if no name is specified, use the creator's nickname\n\nif\n\nnot\n\nname\n\nname\n\nctx\n\nmessage\n\nauthor\n\nname\n\nThe @bot.command decorator will ensure that our function is invoked when a user types a message starting with !create. We also use it to define some help text \u2013 the commands extension provides a default !help command, and each command we define can have two types of explanatory text:\n\nbrief: A short description of the command that will show alongside other defined commands when the user types !help.\n\nhelp: A longer description of the command that will show when the user types !help name_of_command.\n\nIn the absence of brief, the help text will be used in both cases, though it may be truncated for the output of !help.\n\nOur create function takes two parameters:\n\nctx: This is the invocation context, a special object containing information such as the user who called the command, the server it was called in, and the files attached to the calling message if any. All commands must take this parameter.\n\nname: This will be the name for the character we're creating and is an optional parameter.\n\nThe function body retrieves the Discord user ID of the user who issued the !create command. It then checks whether a name parameter was provided. If not, it sets name to the name of the user.\n\nNext, we'll create an instance of Character with some starter stats and save it to our repl's database. Add the following code to the body of create:\n\n# create characters dictionary if it does not exist\n\nif\n\n\"characters\"\n\nnot\n\nin\n\ndb\n\nkeys\n\ndb\n\n\"characters\"\n\n# only create a new character if the user does not already have one\n\nif\n\nuser_id\n\nnot\n\nin\n\ndb\n\n\"characters\"\n\nor\n\nnot\n\ndb\n\n\"characters\"\n\nuser_id\n\ncharacter\n\nCharacter\n\n**\n\n\"name\"\n\nname\n\n\"hp\"\n\n16\n\n\"max_hp\"\n\n16\n\n\"attack\"\n\n\"defense\"\n\n\"mana\"\n\n\"level\"\n\n\"xp\"\n\n\"gold\"\n\n\"inventory\"\n\n\"mode\"\n\nGameMode\n\nADVENTURE\n\n\"battling\"\n\nNone\n\n\"user_id\"\n\nuser_id\n\ncharacter\n\nsave_to_db\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"New level 1 character created:\n\nname\n\n. Enter `!status` to see your stats.\"\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"You have already created your character.\"\n\nAfter creating and saving a new character, or failing to do so, this code sends a reply to the message that invoked it.", "start_char_idx": 20581, "end_char_idx": 24914, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ad13d4f4-4841-4a67-97e4-230575a40c41": {"__data__": {"id_": "ad13d4f4-4841-4a67-97e4-230575a40c41", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4dd6a042-8ca6-41dd-a9be-81ddada706ef", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "b1855ed801de1437d7d8b45dd5ed2c7be3e332fdac4ca28d765e1a4816dcd683", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "233a2bfc-f469-424d-8e71-876733bcd323", "node_type": "1", "metadata": {}, "hash": "4d94d2187a6a1364087f2ab610873cd5626a877d479eddd5083217ed615197bf", "class_name": "RelatedNodeInfo"}}, "hash": "f1a142db305950ca2c639733b6dbf3f653c373be1ce93d5a7d953148c3a8a125", "text": "Enter `!status` to see your stats.\"\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"You have already created your character.\"\n\nAfter creating and saving a new character, or failing to do so, this code sends a reply to the message that invoked it. As our game logic primarily resides in the game.py file, constructing these commands will largely be a matter of constructing and sending replies informing the player of what's happened in the game world.\n\nCharacter status\u200b\n\nNext, we'll implement the !status command, which players will use to view their character's current statistics, inventory, and game mode. To convey this information compactly and attractively, we'll use an embed rather than a plain Discord message.\n\nEmbeds are usually used to provide link previews, but can also be constructed from scratch, providing a powerful tool for bots to display richly formatted information of any kind. This is what our embed will look like:\n\nAdd the following function below the definition create():\n\n@bot\n\ncommand\n\nname\n\n\"status\"\n\nhelp\n\n\"Get information about your character.\"\n\nasync\n\ndef\n\nstatus\n\nctx\n\ncharacter\n\nload_character\n\nctx\n\nmessage\n\nauthor\n\nid\n\nembed\n\nstatus_embed\n\nctx\n\ncharacter\n\nawait\n\nctx\n\nmessage\n\nreply\n\nembed\n\nembed\n\nThis function retrieves the player's character from the database, passes it and the current context to a function that will construct and return an embed, and then replies with the embed. We'll implement the two methods we've used just above the definition of on_ready(). Go there now.\n\nFirst, load_character(), which reads from the database and creates an instance of Character using the results:\n\n# Helper functions\n\ndef\n\nload_character\n\nuser_id\n\nreturn\n\nCharacter\n\n**\n\ndb\n\n\"characters\"\n\nstr\n\nuser_id\n\nSecond, status_embed():\n\nMODE_COLOR\n\nGameMode\n\nBATTLE\n\n0xDC143C\n\nGameMode\n\nADVENTURE\n\n0x005EB8\n\ndef\n\nstatus_embed\n\nctx\n\ncharacter\n\n# Current mode\n\nif\n\ncharacter\n\nmode\n\n==\n\nGameMode\n\nBATTLE\n\nmode_text\n\nf\"Currently battling a\n\ncharacter\n\nbattling\n\nname\n\n.\"\n\nelif\n\ncharacter\n\nmode\n\n==\n\nGameMode\n\nADVENTURE\n\nmode_text\n\n\"Currently adventuring.\"\n\n# Create embed with description as current mode\n\nembed\n\ndiscord\n\nEmbed\n\ntitle\n\nf\"\n\ncharacter\n\nname\n\nstatus\"\n\ndescription\n\nmode_text\n\ncolor\n\nMODE_COLOR\n\ncharacter\n\nmode\n\nembed\n\nset_author\n\nname\n\nctx\n\nauthor\n\ndisplay_name\n\nicon_url\n\nctx\n\nauthor\n\navatar_url\n\nJust above the function definition, we've created a dictionary that maps game modes to colors. We'll use this to change the color of the vertical bar on the left side of the embed.\n\nIn the function itself, we first check the game mode. This will determine the embed's description text, a paragraph that appears just below the embed's title. Once that's done, we create the embed with discord.Embed, setting the title, description, and color. We then use set_author() to include the calling user's name and profile picture at the top of the embed.\n\nNext, we will construct the embed's fields. You can think of these as individual text boxes, which will be displayed below the description. We'll start with a stats field:\n\n# Stats field\n\nxp_needed\n\ncharacter\n\nready_to_level_up\n\nembed\n\nadd_field\n\nname\n\n\"Stats\"\n\nvalue\n\nf\"\"\"\n\n**HP:**\n\ncharacter\n\nhp\n\ncharacter\n\nmax_hp\n\n**ATTACK:**\n\ncharacter\n\nattack\n\n**DEFENSE:**\n\ncharacter\n\ndefense\n\n**MANA:**\n\ncharacter\n\nmana\n\n**LEVEL:**\n\ncharacter\n\nlevel\n\n**XP:**\n\ncharacter\n\nxp\n\ncharacter\n\nxp\n\nxp_needed\n\n\"\"\"\n\ninline\n\nTrue\n\nWe've used add_field() to create a field with the title \"Stats\" that contains a listing of all the player's important stats. Note the call to character.ready_to_level_up(), so that we can show the player how much XP they need to advance to the next level. We've also set inline=True, which allows us to display fields as columns.\n\nOur next column will show the player's inventory:\n\n# Inventory field\n\ninventory_text\n\nf\"Gold:\n\ncharacter\n\ngold\n\n\\n\"\n\nif\n\ncharacter\n\ninventory\n\ninventory_text\n\n+=\n\n\"\\n\"\n\njoin\n\ncharacter\n\ninventory\n\nembed\n\nadd_field\n\nname\n\n\"Inventory\"\n\nvalue\n\ninventory_text\n\ninline\n\nTrue\n\nThere's currently no logic in our game to put items into characters' inventories, but you should see characters' gold increase as they defeat enemies.\n\nFinally, we'll return the embed.\n\nreturn\n\nembed\n\nRun your repl now, and then switch tabs to your Discord server. Create a character with !create and view its status with !status.", "start_char_idx": 24680, "end_char_idx": 28996, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "233a2bfc-f469-424d-8e71-876733bcd323": {"__data__": {"id_": "233a2bfc-f469-424d-8e71-876733bcd323", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ad13d4f4-4841-4a67-97e4-230575a40c41", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "f1a142db305950ca2c639733b6dbf3f653c373be1ce93d5a7d953148c3a8a125", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2595c591-67c4-4fab-a9be-649263bd2bd8", "node_type": "1", "metadata": {}, "hash": "3da0eb9783d553a9baa6e65b593d3ad446c3e53a3a5ce0d13c7349d2c8a3954d", "class_name": "RelatedNodeInfo"}}, "hash": "4d94d2187a6a1364087f2ab610873cd5626a877d479eddd5083217ed615197bf", "text": "Note the call to character.ready_to_level_up(), so that we can show the player how much XP they need to advance to the next level. We've also set inline=True, which allows us to display fields as columns.\n\nOur next column will show the player's inventory:\n\n# Inventory field\n\ninventory_text\n\nf\"Gold:\n\ncharacter\n\ngold\n\n\\n\"\n\nif\n\ncharacter\n\ninventory\n\ninventory_text\n\n+=\n\n\"\\n\"\n\njoin\n\ncharacter\n\ninventory\n\nembed\n\nadd_field\n\nname\n\n\"Inventory\"\n\nvalue\n\ninventory_text\n\ninline\n\nTrue\n\nThere's currently no logic in our game to put items into characters' inventories, but you should see characters' gold increase as they defeat enemies.\n\nFinally, we'll return the embed.\n\nreturn\n\nembed\n\nRun your repl now, and then switch tabs to your Discord server. Create a character with !create and view its status with !status.\n\nBattles\u200b\n\nNext, let's implement our battle commands, starting with !hunt. Add the following function definition below the body of status():\n\n@bot\n\ncommand\n\nname\n\n\"hunt\"\n\nhelp\n\n\"Look for an enemy to fight.\"\n\nasync\n\ndef\n\nhunt\n\nctx\n\ncharacter\n\nload_character\n\nctx\n\nmessage\n\nauthor\n\nid\n\nif\n\ncharacter\n\nmode\n\n!=\n\nGameMode\n\nADVENTURE\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Can only call this command outside of battle!\"\n\nreturn\n\nenemy\n\ncharacter\n\nhunt\n\n# Send reply\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"You encounter a\n\nenemy\n\nname\n\n. Do you `!fight` or `!flee`?\"\n\nThis function is fairly simple: We load the character, ensure they're not currently in a battle, call hunt() to generate a random enemy, and reply to the player with a message about what they're fighting and which commands they can use.\n\nNext, we'll implement !fight:\n\n@bot\n\ncommand\n\nname\n\n\"fight\"\n\nhelp\n\n\"Fight the current enemy.\"\n\nasync\n\ndef\n\nfight\n\nctx\n\ncharacter\n\nload_character\n\nctx\n\nmessage\n\nauthor\n\nid\n\nif\n\ncharacter\n\nmode\n\n!=\n\nGameMode\n\nBATTLE\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Can only call this command in battle!\"\n\nreturn\n\n# Simulate battle\n\nenemy\n\ncharacter\n\nbattling\n\n# Character attacks\n\ndamage\n\nkilled\n\ncharacter\n\nfight\n\nenemy\n\nif\n\ndamage\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nattacks\n\nenemy\n\nname\n\n, dealing\n\ndamage\n\ndamage!\"\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nswings at\n\nenemy\n\nname\n\n, but misses!\"\n\nHere we load the character, ensure they're currently in battle mode, and then have them fight the enemy, returning a message about the damage inflicted. We also account for the small chance that they will inflict no damage.\n\nNext, we need to check if the enemy was killed by the attack. Add the following code to the bottom of the function:\n\n# End battle in victory if enemy killed\n\nif\n\nkilled\n\nxp\n\ngold\n\nready_to_level_up\n\ncharacter\n\ndefeat\n\nenemy\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nvanquished the\n\nenemy\n\nname\n\n, earning\n\nxp\n\nXP and\n\ngold\n\nGOLD. HP:\n\ncharacter\n\nhp\n\ncharacter\n\nmax_hp\n\n.\"\n\nif\n\nready_to_level_up\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nhas earned enough XP to advance to level\n\ncharacter\n\nlevel\n\n. Enter `!levelup` with the stat (HP, ATTACK, DEFENSE) you would like to increase. e.g. `!levelup hp` or `!levelup attack`.\"\n\nreturn\n\nHere we call character.defeat() to handle the enemy's death and return appropriate replies. Again, we've already written all the game logic, so all this code needs to do is display it to the player. Once we've sent the reply, we return from the function.\n\nAfter the player character attacks, we need to have the enemy fight back. Add the following code below the if killed block:\n\n# Enemy attacks\n\ndamage\n\nkilled\n\nenemy\n\nfight\n\ncharacter\n\nif\n\ndamage\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\nenemy\n\nname\n\nattacks\n\ncharacter\n\nname\n\n, dealing\n\ndamage\n\ndamage!\"\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\nenemy\n\nname\n\ntries to attack\n\ncharacter\n\nname\n\n, but misses!\"\n\ncharacter\n\nsave_to_db\n\n#enemy.fight() does not save automatically\n\nThis is almost identical to the player's attack code, but with enemy.fight(character) instead of character.fight(enemy).", "start_char_idx": 28189, "end_char_idx": 32099, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2595c591-67c4-4fab-a9be-649263bd2bd8": {"__data__": {"id_": "2595c591-67c4-4fab-a9be-649263bd2bd8", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "233a2bfc-f469-424d-8e71-876733bcd323", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "4d94d2187a6a1364087f2ab610873cd5626a877d479eddd5083217ed615197bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "63a44666-6f12-4e8d-8ac3-515d4205cb9b", "node_type": "1", "metadata": {}, "hash": "03e6f8d3bc02544a2422a613e816aae682d8b5ea0f9736028cce08b2f313f544", "class_name": "RelatedNodeInfo"}}, "hash": "3da0eb9783d553a9baa6e65b593d3ad446c3e53a3a5ce0d13c7349d2c8a3954d", "text": "Again, we've already written all the game logic, so all this code needs to do is display it to the player. Once we've sent the reply, we return from the function.\n\nAfter the player character attacks, we need to have the enemy fight back. Add the following code below the if killed block:\n\n# Enemy attacks\n\ndamage\n\nkilled\n\nenemy\n\nfight\n\ncharacter\n\nif\n\ndamage\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\nenemy\n\nname\n\nattacks\n\ncharacter\n\nname\n\n, dealing\n\ndamage\n\ndamage!\"\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\nenemy\n\nname\n\ntries to attack\n\ncharacter\n\nname\n\n, but misses!\"\n\ncharacter\n\nsave_to_db\n\n#enemy.fight() does not save automatically\n\nThis is almost identical to the player's attack code, but with enemy.fight(character) instead of character.fight(enemy). But because enemy.fight() does not save to the database after changing the game state, we must do this manually.\n\nNext, we need some code to check whether the player character was killed in the attack. Add the following lines to your function:\n\n# End battle in death if character killed\n\nif\n\nkilled\n\ncharacter\n\ndie\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nwas defeated by a\n\nenemy\n\nname\n\nand is no more. Rest in peace, brave adventurer.\"\n\nreturn\n\nHere we delete the character from the database, send a message of condolences, and return from the function.\n\nThe last case we need to handle is the most common one, where neither the player nor their enemy has died. We'll deal with this by sending a final message to close out this round of fighting.\n\n# No deaths, battle continues\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"The battle rages on! Do you `!fight` or `!flee`?\"\n\nThat's it for !fight \u2013 now we need !flee! Add the following function below the one you just finished:\n\n@bot\n\ncommand\n\nname\n\n\"flee\"\n\nhelp\n\n\"Flee the current enemy.\"\n\nasync\n\ndef\n\nflee\n\nctx\n\ncharacter\n\nload_character\n\nctx\n\nmessage\n\nauthor\n\nid\n\nif\n\ncharacter\n\nmode\n\n!=\n\nGameMode\n\nBATTLE\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Can only call this command in battle!\"\n\nreturn\n\nenemy\n\ncharacter\n\nbattling\n\ndamage\n\nkilled\n\ncharacter\n\nflee\n\nenemy\n\nif\n\nkilled\n\ncharacter\n\ndie\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nwas killed fleeing the\n\nenemy\n\nname\n\n, and is no more. Rest in peace, brave adventurer.\"\n\nelif\n\ndamage\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nflees the\n\nenemy\n\nname\n\n, taking\n\ndamage\n\ndamage. HP:\n\ncharacter\n\nhp\n\ncharacter\n\nmax_hp\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nflees the\n\nenemy\n\nname\n\nwith their life but not their dignity intact. HP:\n\ncharacter\n\nhp\n\ncharacter\n\nmax_hp\n\nOnce again, this function loads the character, checks that the game mode is appropriate for the invoked command, and then invokes the appropriate method in Character. We finish off the function by providing for three possible outcomes of an attempt to flee: the character dies, the character flees taking damage, and the character flees unscathed.\n\nRerun your repl and try hunting, fighting, and fleeing.\n\nLeveling up\u200b\n\nNext, we need to implement !levelup. Add the following code below the definition of !flee:\n\n@bot\n\ncommand\n\nname\n\n\"levelup\"\n\nhelp\n\n\"Advance to the next level. Specify a stat to increase (HP, ATTACK, DEFENSE).\"\n\nasync\n\ndef\n\nlevelup\n\nctx\n\nincrease\n\ncharacter\n\nload_character\n\nctx\n\nmessage\n\nauthor\n\nid\n\nif\n\ncharacter\n\nmode\n\n!=\n\nGameMode\n\nADVENTURE\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Can only call this command outside of battle!\"\n\nreturn\n\nready\n\nxp_needed\n\ncharacter\n\nready_to_level_up\n\nif\n\nnot\n\nready\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"You need another\n\nxp_needed\n\nto advance to level\n\ncharacter\n\nlevel\n\nreturn\n\nif\n\nnot\n\nincrease\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Please specify a stat to increase (HP, ATTACK, DEFENSE)\"\n\nreturn\n\nThis function takes increase, which will be a string containing the stat to increase. After our standard character load and mode check, we do some error handling. First, we reject the command if the character does not have enough XP to level up, and then we reject the command if the player has not specified a stat to increase.", "start_char_idx": 31352, "end_char_idx": 35345, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "63a44666-6f12-4e8d-8ac3-515d4205cb9b": {"__data__": {"id_": "63a44666-6f12-4e8d-8ac3-515d4205cb9b", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2595c591-67c4-4fab-a9be-649263bd2bd8", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "3da0eb9783d553a9baa6e65b593d3ad446c3e53a3a5ce0d13c7349d2c8a3954d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a9ff8bac-49aa-4246-8ddd-bf212c7bdcd5", "node_type": "1", "metadata": {}, "hash": "ac923a2db990e486018fb5daa6fa5ac6dc6e1c598b17786b324ecf8732943b45", "class_name": "RelatedNodeInfo"}}, "hash": "03e6f8d3bc02544a2422a613e816aae682d8b5ea0f9736028cce08b2f313f544", "text": "return\n\nready\n\nxp_needed\n\ncharacter\n\nready_to_level_up\n\nif\n\nnot\n\nready\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"You need another\n\nxp_needed\n\nto advance to level\n\ncharacter\n\nlevel\n\nreturn\n\nif\n\nnot\n\nincrease\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Please specify a stat to increase (HP, ATTACK, DEFENSE)\"\n\nreturn\n\nThis function takes increase, which will be a string containing the stat to increase. After our standard character load and mode check, we do some error handling. First, we reject the command if the character does not have enough XP to level up, and then we reject the command if the player has not specified a stat to increase.\n\nNext, we need to parse the value of increase. Add the following code to your function:\n\nincrease\n\nincrease\n\nlower\n\nif\n\nincrease\n\n==\n\n\"hp\"\n\nor\n\nincrease\n\n==\n\n\"hitpoints\"\n\nor\n\nincrease\n\n==\n\n\"max_hp\"\n\nor\n\nincrease\n\n==\n\n\"maxhp\"\n\nincrease\n\n\"max_hp\"\n\nelif\n\nincrease\n\n==\n\n\"attack\"\n\nor\n\nincrease\n\n==\n\n\"att\"\n\nincrease\n\n\"attack\"\n\nelif\n\nincrease\n\n==\n\n\"defense\"\n\nor\n\nincrease\n\n==\n\n\"def\"\n\nor\n\nincrease\n\n==\n\n\"defence\"\n\nincrease\n\n\"defense\"\n\nWe're allowing players to increase their characters' HP, attack, or defense stats only. To make our game as user-friendly as possible, we accept a few different words for each of those stats.\n\nFinally, we call the character's level_up() method and report on its results:\n\nsuccess\n\nnew_level\n\ncharacter\n\nlevel_up\n\nincrease\n\nif\n\nsuccess\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nadvanced to level\n\nnew_level\n\n, gaining 1\n\nincrease\n\nupper\n\nreplace\n\n'_'\n\n' '\n\n.\"\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"\n\ncharacter\n\nname\n\nfailed to level up.\"\n\nRerun your repl and test this out. If you'd prefer to avoid grinding, edit your character creation code temporarily to increase the initial amount of XP.\n\nCharacter death\u200b\n\nThere's one more command in our design specification that we have not yet implemented: !die. Players will use this command if they want to start the game over with a new character. Add the following code to define it:\n\n@bot\n\ncommand\n\nname\n\n\"die\"\n\nhelp\n\n\"Destroy current character.\"\n\nasync\n\ndef\n\ndie\n\nctx\n\ncharacter\n\nload_character\n\nctx\n\nmessage\n\nauthor\n\nid\n\ncharacter\n\ndie\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"Character\n\ncharacter\n\nname\n\nis no more. Create a new one with `!create`.\"\n\nCharacter reset\u200b\n\nBefore we finish up, we're going to implement one last, special command: !reset. This command will delete a player's character and then immediately create a new character. Unlike the commands above, this will be a testing command, for use by the developer rather than players. Add the following code below the definition of die():\n\n@bot\n\ncommand\n\nname\n\n\"reset\"\n\nhelp\n\n\"[DEV] Destroy and recreate current character.\"\n\nasync\n\ndef\n\nreset\n\nctx\n\nuser_id\n\nstr\n\nctx\n\nmessage\n\nauthor\n\nid\n\nif\n\nuser_id\n\nin\n\ndb\n\n\"characters\"\n\nkeys\n\ndel\n\ndb\n\n\"characters\"\n\nuser_id\n\nawait\n\nctx\n\nmessage\n\nreply\n\nf\"Character deleted.\"\n\nawait\n\ncreate\n\nctx\n\nUnlike in die(), we're deleting from the database directly rather than using character.die() method. This is useful because further development of the game might cause errors in Character.__init__(), rendering the die() method temporarily unusable.\n\nWhere next?\u200b\n\nWe've created a text-based RPG that can be played on a Discord server, but our game is pretty barebones. We could expand it in a few different ways:\n\nImplement a magic system using the mana attribute.\n\nImplement an economy in which characters can buy and sell items, such as health potions.\n\nFlesh out the battle system, with multiple attack types, multiple enemies per battle, and the ability to use items that weaken enemies or temporarily strengthen characters.\n\nCreate a game world with different areas the player can travel to, containing different enemies.\n\nImplement NPCs the player can talk to and receive quests from.\n\nEnable player versus player combat.\n\nDiscord bot code can be hosted on Replit permanently, but you'll need to use a Deployments repl to keep it running 24/7.\n\nYou can find our repl below:\n\n< Previous: Discord meme maker bot with Python\n\nNext: 2D Platform Game with PyGame >\n\nWas this helpful?", "start_char_idx": 34725, "end_char_idx": 38797, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a9ff8bac-49aa-4246-8ddd-bf212c7bdcd5": {"__data__": {"id_": "a9ff8bac-49aa-4246-8ddd-bf212c7bdcd5", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "02896b9e4a34bdea9dd5e59a3806436c542dc65f2bc1e050cbe6d8f691fb9a26", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "63a44666-6f12-4e8d-8ac3-515d4205cb9b", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}, "hash": "03e6f8d3bc02544a2422a613e816aae682d8b5ea0f9736028cce08b2f313f544", "class_name": "RelatedNodeInfo"}}, "hash": "ac923a2db990e486018fb5daa6fa5ac6dc6e1c598b17786b324ecf8732943b45", "text": "Where next?\u200b\n\nWe've created a text-based RPG that can be played on a Discord server, but our game is pretty barebones. We could expand it in a few different ways:\n\nImplement a magic system using the mana attribute.\n\nImplement an economy in which characters can buy and sell items, such as health potions.\n\nFlesh out the battle system, with multiple attack types, multiple enemies per battle, and the ability to use items that weaken enemies or temporarily strengthen characters.\n\nCreate a game world with different areas the player can travel to, containing different enemies.\n\nImplement NPCs the player can talk to and receive quests from.\n\nEnable player versus player combat.\n\nDiscord bot code can be hosted on Replit permanently, but you'll need to use a Deployments repl to keep it running 24/7.\n\nYou can find our repl below:\n\n< Previous: Discord meme maker bot with Python\n\nNext: 2D Platform Game with PyGame >\n\nWas this helpful?\n\nLast updated on Nov 2, 2023\n\nGetting started\n\nGame design\n\nGame classes\n\nSaving and loading from the database\n\nGame actions\n\nCreating a Discord application\n\nWriting the Discord bot code\n\nHandling user commandsCharacter creationCharacter statusBattlesLeveling upCharacter deathCharacter reset\n\nWhere next?", "start_char_idx": 37863, "end_char_idx": 39103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9": {"node_ids": ["9ef58ea6-3fd2-4433-8ae1-ffb6ab55b763", "6fb81baa-331a-40e2-9219-82c3c0fb42c8", "90db1392-5889-4767-86a9-7a7458a5f7a0", "65868151-ec8b-4d45-8088-3b1957eff73a", "8ce1fec2-e2a4-4ca4-9c92-5809e0c103de", "b83b012d-ea1a-4d89-8b22-a63944e5a395", "4dd6a042-8ca6-41dd-a9be-81ddada706ef", "ad13d4f4-4841-4a67-97e4-230575a40c41", "233a2bfc-f469-424d-8e71-876733bcd323", "2595c591-67c4-4fab-a9be-649263bd2bd8", "63a44666-6f12-4e8d-8ac3-515d4205cb9b", "a9ff8bac-49aa-4246-8ddd-bf212c7bdcd5"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-rpg-bot.html"}}}, "docstore/metadata": {"9ef58ea6-3fd2-4433-8ae1-ffb6ab55b763": {"doc_hash": "48a821b0b2d77506a2e6bb6004b149369107cc6e2b90a430fb3e5d4577c8d21f", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "6fb81baa-331a-40e2-9219-82c3c0fb42c8": {"doc_hash": "e5c0f4152757b7d7e2204b824e5674e9ddc97800ccea6c2cdda6990eb7e0234f", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "90db1392-5889-4767-86a9-7a7458a5f7a0": {"doc_hash": "f729255f42aebb48d06cba547656864e95c4bb7bf67bb5989bea61adb85be11c", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "65868151-ec8b-4d45-8088-3b1957eff73a": {"doc_hash": "5925588a4f52cba6e8955ef05c3db1de21c6ee6907d6778e92e948ef7e548e41", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "8ce1fec2-e2a4-4ca4-9c92-5809e0c103de": {"doc_hash": "86559b2054141c3ec0cd406a4a53bc76b52a6e60670f70a1c47edbda6c4c186d", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "b83b012d-ea1a-4d89-8b22-a63944e5a395": {"doc_hash": "49b7df8d00a2765d0187612e1bc2b32fff694373d45cfe9c25e838290f9998c9", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "4dd6a042-8ca6-41dd-a9be-81ddada706ef": {"doc_hash": "b1855ed801de1437d7d8b45dd5ed2c7be3e332fdac4ca28d765e1a4816dcd683", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "ad13d4f4-4841-4a67-97e4-230575a40c41": {"doc_hash": "f1a142db305950ca2c639733b6dbf3f653c373be1ce93d5a7d953148c3a8a125", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "233a2bfc-f469-424d-8e71-876733bcd323": {"doc_hash": "4d94d2187a6a1364087f2ab610873cd5626a877d479eddd5083217ed615197bf", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "2595c591-67c4-4fab-a9be-649263bd2bd8": {"doc_hash": "3da0eb9783d553a9baa6e65b593d3ad446c3e53a3a5ce0d13c7349d2c8a3954d", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "63a44666-6f12-4e8d-8ac3-515d4205cb9b": {"doc_hash": "03e6f8d3bc02544a2422a613e816aae682d8b5ea0f9736028cce08b2f313f544", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}, "a9ff8bac-49aa-4246-8ddd-bf212c7bdcd5": {"doc_hash": "ac923a2db990e486018fb5daa6fa5ac6dc6e1c598b17786b324ecf8732943b45", "ref_doc_id": "faea0f3e-a0b0-47b4-b3cf-bdbf1f5fe8c9"}}}