{"docstore/data": {"bfca46c3-7b53-4266-8de8-f749b9995d8b": {"__data__": {"id_": "bfca46c3-7b53-4266-8de8-f749b9995d8b", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dbe70d9e-0bb9-4784-b18c-8078c099b70d", "node_type": "1", "metadata": {}, "hash": "0b8c94bd60c01a6c1888a96615d91718cb32359c1877204cdf0f36f7965df0c2", "class_name": "RelatedNodeInfo"}}, "hash": "c8a9bd4337691fbad401813edea18918a2cc592414505d9f6354887c0f14b1a1", "text": "requests[id] = true;\n\nemit RandomNumberRequested(id);\n\nHere we use a require statement to ensure that the contract's oracle is initialized. We do this by checking that it is not a contract at the null address, which is the address of uninitialized contract references. We then call requestRandomNumber(), the function that we declared in the IRandOracle interface. This function will return a request ID, which we mark as valid in our requests mapping. Finally, we emit an event to show that a random number has been requested.\n\nNow we need to write the callback function. Add the following code below the function you added above:\n\nfunction fulfillRandomNumberRequest(uint256 randomNumber, uint256 id) external onlyRandOracle {\n\nrequire(requests[id], \"Request is invalid or already fulfilled.\");\n\nresults[id] = randomNumber;\n\ndelete requests[id];\n\nemit RandomNumberReceived(randomNumber, id);\n\nWhen the oracle contract calls this function (which only it is allowed to do, per onlyRandOracle) it will supply the random number requested along with the request ID it's fufilling. The function will first check if the request ID is valid and then store the random number in the results mapping.\n\nNow that the request has been fulfilled, it will also delete the request ID from requests, which is equivalent to setting it to false. This will ensure that only active requests are tracked.\n\nFinally, our callback function emits an event to announce that the request has been fulfilled. In a more complex contract, this function would do more than just store the random number in a results mapping: for example, it might use the number to determine a lottery winner, or generate an attribute of an NFT.\n\nBefore we wrap up this contract, we need to define the events we've emitted above. Add the following code to the bottom of the contract body:\n\nevent OracleAddressChanged(address oracleAddress);\n\nevent RandomNumberRequested(uint256 id);\n\nevent RandomNumberReceived(uint256 number, uint256 id);\n\nOur caller contract is now complete. But it won't be able to do much of anything until we implement the oracle contract it depends on.\n\nOracle contract\u200b\n\nIf you take another look at the architecture diagram above, you'll notice that the oracle contract is intended to interact with multiple off-chain data providers. This is to ensure decentralization, a key attribute of robust smart contract protocols. If we relied on a single data provider for our random numbers, we'd be in trouble if that provider was compromised and the numbers it sent to us started being fixed, or if it had an outage and stopped returning anything.\n\nSo to minimize the impact of any single provider being compromised or going down, we'll implement functionality to source several different random numbers from several different providers, which we'll combine at the end using a bitwise XOR.\n\nCreate a new subdirectory in your repl at contracts/oracle. Inside this subdirectory, create a new file named RandOracle.sol. Enter the following code into your new file:\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"./ICaller.sol\";\n\ncontract RandOracle is AccessControl {\n\nThis stub is quite similar to the code we started out with when writing Caller, having only two key differences:\n\nInstead of Ownable, we import AccessControl from OpenZeppelin, which will allow us to implement role-based access control, a more complex and granular authorization model than we used in Caller. While we could have used this for Caller as well, it would have been overkill, and we'd like to keep our contracts as small as possible to save on deployment costs.\n\nInstead of IRandOracle, we import the interface ICaller. You can probably guess what it will contain. Let's create it now, in a file named ICaller.sol within the same directory:\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface ICaller {\n\nfunction fulfillRandomNumberRequest(uint256 randomNumber, uint256 id) external;\n\nLike Caller, RandOracle only needs to know about a single function in the other contract.\n\nLet's return to RandOracle.sol and define some state variables.\n\nbytes32 public constant PROVIDER_ROLE = keccak256(\"PROVIDER_ROLE\");\n\nFirst we define a name for our data provider role, in accordance with the AccessControl contract's documentation. We then define two variables which we'll use to manage multiple providers:\n\nuint private numProviders = 0;\n\nuint private providersThreshold = 1;\n\nWe use numProviders to store the total count of data providers we've added to the contract, and providersThreshold to define the minimum number of provider responses we need to consider a request fulfilled.", "start_char_idx": 0, "end_char_idx": 4720, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dbe70d9e-0bb9-4784-b18c-8078c099b70d": {"__data__": {"id_": "dbe70d9e-0bb9-4784-b18c-8078c099b70d", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bfca46c3-7b53-4266-8de8-f749b9995d8b", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "c8a9bd4337691fbad401813edea18918a2cc592414505d9f6354887c0f14b1a1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "522c577e-6ea8-4b26-b6ae-a42f9c83d5c7", "node_type": "1", "metadata": {}, "hash": "75de3437d139ffc14b962c618599fbc8c253757d2460f05ddfe918aa3ce58ccb", "class_name": "RelatedNodeInfo"}}, "hash": "0b8c94bd60c01a6c1888a96615d91718cb32359c1877204cdf0f36f7965df0c2", "text": "Let's create it now, in a file named ICaller.sol within the same directory:\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface ICaller {\n\nfunction fulfillRandomNumberRequest(uint256 randomNumber, uint256 id) external;\n\nLike Caller, RandOracle only needs to know about a single function in the other contract.\n\nLet's return to RandOracle.sol and define some state variables.\n\nbytes32 public constant PROVIDER_ROLE = keccak256(\"PROVIDER_ROLE\");\n\nFirst we define a name for our data provider role, in accordance with the AccessControl contract's documentation. We then define two variables which we'll use to manage multiple providers:\n\nuint private numProviders = 0;\n\nuint private providersThreshold = 1;\n\nWe use numProviders to store the total count of data providers we've added to the contract, and providersThreshold to define the minimum number of provider responses we need to consider a request fulfilled. For now, we've set providersThreshold to just one, opening ourselves up to the centralization risk mentioned above, but it will suffice for getting a basic demo up and running.\n\nNext, we need to define some variables we'll use to deal with requests and responses. Enter the following code below the definitions you just added above:\n\nuint private randNonce = 0;\n\nmapping(uint256=>bool) private pendingRequests;\n\nstruct Response {\n\naddress providerAddress;\n\naddress callerAddress;\n\nuint256 randomNumber;\n\nmapping(uint256=>Response[]) private idToResponses;\n\nHere we define:\n\nrandNonce, a cryptographic nonce we'll use to generate request IDs. This will be a simple counter that we increment every time requestRandomNumber() is called.\n\npendingRequests, a mapping of requests awaiting fulfillment, similar to requests in our Caller contract.\n\nThe Response struct, in which we'll store all the key details of each random number we receive from data providers: who requested the number, who provided the number, and the number itself.\n\nidToResponses, a mapping of request IDs to arrays of Response structs. This will allow us to track responses per request.\n\nNow let's define our contract's constructor, the function that will run when it's deployed.\n\nconstructor() {\n\n_setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // make the deployer admin\n\nThis function assigns AccessControl's DEFAULT_ADMIN_ROLE to the contract's deploying address, commonly called its owner. This role has the power to grant and revoke other roles.\n\nNow we're ready to define requestRandomNumber(), the function we called from Caller. Add the following code below the constructor's definition:\n\nfunction requestRandomNumber() external returns (uint256) {\n\nrequire(numProviders > 0, \" No data providers not yet added.\");\n\nrandNonce++;\n\nuint id = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender, randNonce))) % 1000;\n\npendingRequests[id] = true;\n\nemit RandomNumberRequested(msg.sender, id);\n\nreturn id;\n\nAll this code does is generate a unique ID for the request, based on randNonce, adds that ID to pendingRequests, emits an event and returns the ID, similar to the concept of a support desk ticketing system. The require statement at the top of the code will revert if the contract's administrator has not yet added any data providers.\n\nAn off-chain data provider, which we'll create later on using Node.js, will watch the contract for RandomNumberRequested events and respond to them by submitting a random number to the contract function returnRandomNumber(), which will in turn return the number to the caller contract using fulfillRandomNumberRequest(). Let's start writing returnRandomNumber() now, just below requestRandomNumber():\n\nfunction returnRandomNumber(uint256 randomNumber, address callerAddress, uint256 id) external onlyRole(PROVIDER_ROLE) {\n\nrequire(pendingRequests[id], \"Request not found.\");\n\n// Add newest response to list\n\nResponse memory res = Response(msg.sender, callerAddress, randomNumber);\n\nidToResponses[id].push(res);\n\nuint numResponses = idToResponses[id].length;\n\nHere, returnRandomNumber is a public function which we'll restrict to the addresses with the PROVIDER_ROLE. It takes three arguments: the random number, the address that made the initial request, and the request ID. In the code above, we ensure that the request ID is valid and then add the response to the array of responses for the request with this ID, stored in idToResponses. We then store the length of the array in numResponses, which we'll use to check if we've met the response threshold.\n\nIn the next part of the function, we'll combine all the responses we receive and submit the result back to the caller.", "start_char_idx": 3792, "end_char_idx": 8412, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "522c577e-6ea8-4b26-b6ae-a42f9c83d5c7": {"__data__": {"id_": "522c577e-6ea8-4b26-b6ae-a42f9c83d5c7", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dbe70d9e-0bb9-4784-b18c-8078c099b70d", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0b8c94bd60c01a6c1888a96615d91718cb32359c1877204cdf0f36f7965df0c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2d2d0bc3-0b14-4c51-9f1f-5c714d7502b2", "node_type": "1", "metadata": {}, "hash": "83e98083bb58a7b97ccc5e1332a26fea1eefd5e529187040aa235e58296969a5", "class_name": "RelatedNodeInfo"}}, "hash": "75de3437d139ffc14b962c618599fbc8c253757d2460f05ddfe918aa3ce58ccb", "text": "\");\n\n// Add newest response to list\n\nResponse memory res = Response(msg.sender, callerAddress, randomNumber);\n\nidToResponses[id].push(res);\n\nuint numResponses = idToResponses[id].length;\n\nHere, returnRandomNumber is a public function which we'll restrict to the addresses with the PROVIDER_ROLE. It takes three arguments: the random number, the address that made the initial request, and the request ID. In the code above, we ensure that the request ID is valid and then add the response to the array of responses for the request with this ID, stored in idToResponses. We then store the length of the array in numResponses, which we'll use to check if we've met the response threshold.\n\nIn the next part of the function, we'll combine all the responses we receive and submit the result back to the caller. Add the following code below the line that starts with uint numResponses:\n\n// Check if we've received enough responses\n\nif (numResponses == providersThreshold) {\n\nuint compositeRandomNumber = 0;\n\n// Loop through the array and combine responses\n\nfor (uint i=0; i < idToResponses[id].length; i++) {\n\ncompositeRandomNumber = compositeRandomNumber ^ idToResponses[id][i].randomNumber; // bitwise XOR\n\n// Clean up\n\ndelete pendingRequests[id];\n\ndelete idToResponses[id];\n\n// Fulfill request\n\nICaller(callerAddress).fulfillRandomNumberRequest(compositeRandomNumber, id);\n\nemit RandomNumberReturned(compositeRandomNumber, callerAddress, id);\n\nThe code in this if block will only run when the final data provider submits its random number. It combines all the random numbers through a bitwise XOR, as taking an average would reduce the randomness. It then deletes the data for this request \u2013 without this step, data providers could keep submitting different random numbers and changing the result. It then fulfills the request by invoking the caller function's callback, and finally emits an event.\n\nFunctions in external contracts should almost always be invoked at or near the end of a given function, after all state change operations have been performed. This avoids the risk of reentrancy, a common smart contract bug that was the cause of the famous 2016 DAO hack.\n\nHaving now completed our oracle contract's main functions, we need to add a few housekeeping functions for the contract admin to manage data providers. We'll start with a function for adding new data providers. Add the following code at the bottom of the contract body:\n\n// Admin functions\n\nfunction addProvider(address provider) external onlyRole(DEFAULT_ADMIN_ROLE) {\n\nrequire(!hasRole(PROVIDER_ROLE, provider), \"Provider already added.\");\n\n_grantRole(PROVIDER_ROLE, provider);\n\nnumProviders++;\n\nemit ProviderAdded(provider);\n\nThis code is quite straight-forward. Following a duplication check, it uses the _grantRole() function from AccessControl to assign PROVIDER_ROLE to the specified address, increments numProviders, and emits an event to let users know of a contract configuration change.\n\nNext, we add a function to remove data providers:\n\nfunction removeProvider(address provider) external onlyRole(DEFAULT_ADMIN_ROLE) {\n\nrequire(!hasRole(PROVIDER_ROLE, provider), \"Address is not a recognized provider.\");\n\nrequire (numProviders > 1, \"Cannot remove the only provider.\");\n\n_revokeRole(PROVIDER_ROLE, provider);\n\nnumProviders--;\n\nemit ProviderRemoved(provider);\n\nThis function performs the reverse operation of the one above, with an extra check to ensure that the administrator does not remove all providers from the contract, rendering it unusable.\n\nThe last admin function we need is one that sets the provider threshold. Add the following code below the body of removeProvider():\n\nfunction setProvidersThreshold(uint threshold) external onlyRole(DEFAULT_ADMIN_ROLE) {\n\nrequire(threshold > 0, \"Threshold cannot be zero.\");\n\nprovidersThreshold = threshold;\n\nemit ProvidersThresholdChanged(providersThreshold);\n\nFinally, let's define the events we've emitted above. Add the following code to the bottom of the contract body:\n\n// Events\n\nevent RandomNumberRequested(address callerAddress, uint id);\n\nevent RandomNumberReturned(uint256 randomNumber, address callerAddress, uint id);\n\nevent ProviderAdded(address providerAddress);\n\nevent ProviderRemoved(address providerAddress);\n\nevent ProvidersThresholdChanged(uint threshold);\n\nOur oracle contract is complete. Next, we need to create a data provider to feed it random numbers.\n\nNode.js data provider\u200b\n\nWe'll write our data provider as a simple Node.js application, using the Hardhat Ethereum development environment to help us interact with the blockchain. This environment provides a host of features for writing, testing, and deploying smart contracts, and for building applications that interface with the blockchain, such as this one. It includes a slightly modified version of the ethers library, which is the main component we'll be using.", "start_char_idx": 7607, "end_char_idx": 12483, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2d2d0bc3-0b14-4c51-9f1f-5c714d7502b2": {"__data__": {"id_": "2d2d0bc3-0b14-4c51-9f1f-5c714d7502b2", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "522c577e-6ea8-4b26-b6ae-a42f9c83d5c7", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "75de3437d139ffc14b962c618599fbc8c253757d2460f05ddfe918aa3ce58ccb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5102ced-dc27-4b6d-852c-4b1cd2555744", "node_type": "1", "metadata": {}, "hash": "d0b813b6988109a5d2cee901e9a922464c28f009eacfabbad919216a42467a4e", "class_name": "RelatedNodeInfo"}}, "hash": "83e98083bb58a7b97ccc5e1332a26fea1eefd5e529187040aa235e58296969a5", "text": "\");\n\nprovidersThreshold = threshold;\n\nemit ProvidersThresholdChanged(providersThreshold);\n\nFinally, let's define the events we've emitted above. Add the following code to the bottom of the contract body:\n\n// Events\n\nevent RandomNumberRequested(address callerAddress, uint id);\n\nevent RandomNumberReturned(uint256 randomNumber, address callerAddress, uint id);\n\nevent ProviderAdded(address providerAddress);\n\nevent ProviderRemoved(address providerAddress);\n\nevent ProvidersThresholdChanged(uint threshold);\n\nOur oracle contract is complete. Next, we need to create a data provider to feed it random numbers.\n\nNode.js data provider\u200b\n\nWe'll write our data provider as a simple Node.js application, using the Hardhat Ethereum development environment to help us interact with the blockchain. This environment provides a host of features for writing, testing, and deploying smart contracts, and for building applications that interface with the blockchain, such as this one. It includes a slightly modified version of the ethers library, which is the main component we'll be using.\n\nAs previously stated, our data provider will monitor the oracle contract for random number requests and submit responses to them. As JavaScript programs are single-threaded, we'll use a chunked queue structure to split the program's time between taking note of new requests and processing existing requests.\n\nWe'll need to install Hardhat before we can start developing. Open your repl's package.json file and add the following line to the bottom of the dependencies object (remember to add a comma to the end of the preceding line):\n\n\"hardhat\"\n\n\"^2.9.3\"\n\nCreate a new directory in your repl named provider. Inside that directory, create a JavaScript file named index.js. Add the following initial code to the file:\n\nconst\n\nhardhat\n\nrequire\n\n\"hardhat\"\n\nconst\n\naxios\n\nrequire\n\n\"axios\"\n\nconst\n\nMAX_RETRIES\n\nconst\n\nSLEEP_TIME\n\n2000\n\nconst\n\nBATCH_SIZE\n\nHere we import hardhat and axios, which we'll need to request random numbers from the RANDOM.ORG API.\n\nThe constants we've defined will be used as follows:\n\nMAX_RETRIES is the maximum number of times we'll attempt to fulfill a request. Our ability to fulfill requests could be hampered by RANDOM.ORG experiencing an outage, or our data provider's wallet not having enough Ethereum to pay the gas cost of executing returnRandomNumber().\n\nSLEEP_TIME is how long we'll pause between processing batches of the request queue to give our application a chance to add new requests to the queue.\n\nBATCH_SIZE is how many requests we'll fufill between sleeps when processing the request queue.\n\nBefore we dive into our application's main code, let's create a function for getting a random number from RANDOM.ORG. Add the following code below your constant definitions:\n\nasync\n\nfunction\n\nrequestRandomNumber\n\nconst\n\nres\n\nawait\n\naxios\n\nurl\n\n\"https://www.random.org/integers/\"\n\nparams\n\nnum\n\nmin\n\nmax\n\n1000\n\ncol\n\nbase\n\n10\n\nformat\n\n\"plain\"\n\nrnd\n\n\"new\"\n\nmethod\n\n\"get\"\n\nreturn\n\nparseInt\n\nres\n\ndata\n\nHere we use axios to construct and submit an HTTP request to RANDOM.ORG's integer generator, in accordance with their documentation. As axios is an asynchronous function, we must use the await keyword to receive its final return value. The same will be true of most functions we use from the ethers library.\n\nNow let's start with the meat of our application. Add the following code to the bottom of the file:\n\nasync\n\nfunction\n\nmain\n\n// Initialize account\n\nconst\n\ndataProvider\n\nawait\n\nhardhat\n\nethers\n\ngetSigners\n\n// Initialize contract\n\nconst\n\noracleContractAddress\n\n\"ORACLE-CONTRACT-ADDRESS-HERE\"\n\nconst\n\noracleContractABI\n\nrequire\n\n\"./randOracleABI.json\"\n\nconst\n\noracleContract\n\nnew\n\nhardhat\n\nethers\n\nContract\n\noracleContractAddress\n\noracleContractABI\n\ndataProvider\n\nmain\n\nThe getSigners() function from Hardhat's modified ethers library retrieves Ethereum accounts based on a provided wallet. For frontend dapps, this will usually be a wallet extension like MetaMask, but for scripts like this one, we'll need to specify a private key. We'll do that later, when we combine everything together.\n\nThe next chunk of code initializes a Contract object. To connect to a contract and run its functions, we need two things: the contract's address, which shows us where to find it, and its Application Binary Interface (ABI), which tells us what functions it implements and what their parameters are. We'll leave these as placeholders for now.\n\nNote that we've also specified dataProvider as an argument for our Contract object's constructor. This provides a default account to use when calling contract functions.\n\nWith that setup complete, we can start watching for requests and populating our queue.", "start_char_idx": 11408, "end_char_idx": 16112, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c5102ced-dc27-4b6d-852c-4b1cd2555744": {"__data__": {"id_": "c5102ced-dc27-4b6d-852c-4b1cd2555744", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2d2d0bc3-0b14-4c51-9f1f-5c714d7502b2", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "83e98083bb58a7b97ccc5e1332a26fea1eefd5e529187040aa235e58296969a5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "abec822c-9991-4d9a-8e83-9b06c73a123f", "node_type": "1", "metadata": {}, "hash": "fa87a8bf099cfd2c1bb86aad2109ad3a54879c88c5f2372e9f5b5ff44bcfbc52", "class_name": "RelatedNodeInfo"}}, "hash": "d0b813b6988109a5d2cee901e9a922464c28f009eacfabbad919216a42467a4e", "text": "For frontend dapps, this will usually be a wallet extension like MetaMask, but for scripts like this one, we'll need to specify a private key. We'll do that later, when we combine everything together.\n\nThe next chunk of code initializes a Contract object. To connect to a contract and run its functions, we need two things: the contract's address, which shows us where to find it, and its Application Binary Interface (ABI), which tells us what functions it implements and what their parameters are. We'll leave these as placeholders for now.\n\nNote that we've also specified dataProvider as an argument for our Contract object's constructor. This provides a default account to use when calling contract functions.\n\nWith that setup complete, we can start watching for requests and populating our queue. Add the following code to the bottom of your main() function:\n\n// Populate requests queue\n\nvar\n\nrequestsQueue\n\noracleContract\n\non\n\n\"RandomNumberRequested\"\n\nasync\n\ncallerAddress\n\nid\n\n=>\n\nrequestsQueue\n\npush\n\ncallerAddress\n\nid\n\nHere we've initialized an empty requests queue and used oracleContract's on method to subscribe to the RandomNumberRequested event. Whenever a new event of this type is emitted by our contract, the code in our callback will execute, appending an object containing the event's arguments to requestsQueue.\n\nThat's the input part of our functionality done, so now we need the output. As mentioned above, we'll process the queue in chunks at regular intervals, so let's wrap this next bit of code in a [setInterval()] function. Add the following code to the bottom your main() function:\n\n// Poll and process requests queue at intervals\n\nsetInterval\n\nasync\n\n=>\n\nlet\n\nprocessedRequests\n\nSLEEP_TIME\n\nshift() method to pop the first element off the requests queue. Add the following code below the definition of\n\nwhile\n\nrequestsQueue\n\nlength\n\n&&\n\nprocessedRequests\n\nBATCH_SIZE\n\nconst\n\nrequest\n\nrequestsQueue\n\nshift\n\nNow we can process the request with the next bit of code, which you can add to the while loop, below the definition of request:\n\nlet\n\nretries\n\nwhile\n\nretries\n\nMAX_RETRIES\n\ntry\n\nconst\n\nrandomNumber\n\nawait\n\nrequestRandomNumber\n\nawait\n\noracleContract\n\nreturnRandomNumber\n\nrandomNumber\n\nrequest\n\ncallerAddress\n\nrequest\n\nid\n\nbreak\n\ncatch\n\nerror\n\nretries\n\n++\n\nprocessedRequests\n\n++\n\nWe use a try... catch to smoothly handle any errors that occur. We want to be able to leave this program running without worrying about it crashing on an error.\n\nFirst, this code attempts to request a random number and send it to our oracle contract by calling returnRandomNumber(). All contract function calls in ethers are asynchronous, so we must await them. If the operation is successful, we break out of the retry loop and move on to the next request. If not, we increment the retries counter and try again.\n\nIf we reach the maximum number of retries, we'll go to the next request without submitting anything to the oracle contract.\n\nThat's it for our data provider. The last thing we need to write before we can put it all together is a simple frontend for our Caller contract, providing a user-friendly way for people to request and recieve random numbers.\n\nCaller contract frontend\u200b\n\nCreate a new folder in your repl called frontend and then create two files inside it: index.html and app.js. Add the following markup to frontend/index.html:\n\n<!\n\nDOCTYPE\n\nhtml\n\nhtml\n\nhead\n\ntitle\n\nRandom Oracle Client\n\n</\n\ntitle\n\nstyle\n\n.request\n\ncolor\n\nred\n\n.response\n\ncolor\n\ngreen\n\n</\n\nstyle\n\nhead\n\nbody\n\nbutton\n\nid\n\nrequest-rand\n\nclass\n\nbutton\n\nRequest random number\n\n</\n\nbutton\n\nbr\n\npre\n\nid\n\nrequest-id\n\n</\n\npre\n\nul\n\nid\n\nevents\n\n</\n\nul\n\nscript\n\nsrc\n\nhttps://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\n\n</\n\nscript\n\nscript\n\nsrc\n\n./callerABI.js\n\n</\n\nscript\n\nscript\n\nsrc\n\n./app.js\n\n</\n\nscript\n\n</\n\nbody\n\n</\n\nhtml\n\nIn this file, we've created the following:\n\nA button element for requesting new random numbers.\n\nA pre element, in which we'll print the ID of the last request.\n\nA ul element for logging contract events as they occur.\n\nWe've also linked our stylesheet at the top of the file and the following JavaScript files at the bottom:\n\nweb3.js, the library we'll be using to interact with the blockchain.\n\nThe Caller contract's ABI, which we'll get once we compile and deploy it.\n\nOur app.js file, which will contain the frontend's logic.", "start_char_idx": 15311, "end_char_idx": 19666, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "abec822c-9991-4d9a-8e83-9b06c73a123f": {"__data__": {"id_": "abec822c-9991-4d9a-8e83-9b06c73a123f", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5102ced-dc27-4b6d-852c-4b1cd2555744", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "d0b813b6988109a5d2cee901e9a922464c28f009eacfabbad919216a42467a4e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5a34225-5379-4898-8c86-ea34a52fdf59", "node_type": "1", "metadata": {}, "hash": "578c75bb553a814cf1c0743e1b058f236f2428629b6537ae26e76f2d83e4a12f", "class_name": "RelatedNodeInfo"}}, "hash": "fa87a8bf099cfd2c1bb86aad2109ad3a54879c88c5f2372e9f5b5ff44bcfbc52", "text": "A pre element, in which we'll print the ID of the last request.\n\nA ul element for logging contract events as they occur.\n\nWe've also linked our stylesheet at the top of the file and the following JavaScript files at the bottom:\n\nweb3.js, the library we'll be using to interact with the blockchain.\n\nThe Caller contract's ABI, which we'll get once we compile and deploy it.\n\nOur app.js file, which will contain the frontend's logic.\n\nOpen frontend/app.js and enter the code skeleton:\n\nApp\n\ncallerAddress\n\n\"FILL-ME-IN\"\n\ncallerContract\n\nnull\n\ninit\n\nasync\n\nfunction\n\nApp\n\ninit\n\nThis App object will contain all of the status and functionality we'll implement. Note that this frontend will only interact with Caller, and not RandOracle. We'll come back and enter the contract address in the next section, once we've deployed everything.\n\nThe init() function will connect to the blockchain and initialize our application's behavior. Populate your empty function body as follows:\n\ninit\n\nasync\n\nfunction\n\nif\n\nwindow\n\nethereum\n\nawait\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n'eth_requestAccounts'\n\nwindow\n\nweb3\n\nnew\n\nWeb3\n\nwindow\n\nethereum\n\nApp\n\ncallerContract\n\nnew\n\nweb3\n\neth\n\nContract\n\ncallerABI\n\ncallerAddress\n\n// Switch networks\n\nApp\n\nswitchToReplitTestnet\n\nThis code will interface with MetaMask and show a pop-up window asking the user to connect their wallet to our dapp. If the user accepts, we'll instantiate a Web3 object using their account details. As with ethers, the majority of Web3's functions are asynchronous.\n\nBecause we're building on the Replit Testnet, we need to prompt the user to switch to this network, which we'll do in the function switchToReplitTestnet(). Add the definition for this function below the definition of init:\n\nswitchToReplitTestnet\n\nfunction\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n\"wallet_addEthereumChain\"\n\nparams\n\nchainId\n\n\"0x7265706c\"\n\nchainName\n\n\"Replit Testnet\"\n\nrpcUrls\n\n\"https://eth.replit.com\"\n\niconUrls\n\n\"https://upload.wikimedia.org/wikipedia/commons/b/b2/Repl.it_logo.svg\"\n\nnativeCurrency\n\nname\n\n\"Replit ETH\"\n\nsymbol\n\n\"R\u039e\"\n\ndecimals\n\n18\n\nThis code provides the details MetaMask needs to prompt the user to switch networks.\n\nSet up done, we can move on to app functionality. We'll start with a function that calls the Caller contract's getRandomNumber() function.\n\n// contract interactions\n\ngetRandomNumber\n\nasync\n\nfunction\n\nconst\n\naccounts\n\nawait\n\nweb3\n\neth\n\ngetAccounts\n\nconst\n\naccount\n\naccounts\n\n// Request random number & return request ID\n\nreturn\n\nawait\n\nApp\n\ncallerContract\n\nmethods\n\ngetRandomNumber\n\nsend\n\nfrom\n\naccount\n\nHere we use web3.eth.getAccounts() to find the user's wallet address, which we use to call the contract function getRandomNumber(). Note that the pattern and syntax for calling functions in Web3 differs substantially from the syntax we used in ethers.\n\nNext we need a function that subscribes to contract events and prepends their details to our webpage's event log. Add the following code:\n\nsubscribeToContractEvents\n\nfunction\n\nApp\n\ncallerContract\n\nevents\n\nRandomNumberRequested\n\nasync\n\nerr\n\nevent\n\n=>\n\nif\n\nerr\n\nconsole\n\nerror\n\n'Error on event'\n\nerr\n\n// Create list item\n\nlet\n\nreqEventLi\n\ndocument\n\ncreateElement\n\n\"li\"\n\nreqEventLi\n\nclassList\n\nadd\n\n\"request\"\n\nreqEventLi\n\ninnerHTML\n\nRandom number requested, ID:\n\n${\n\nevent\n\nreturnValues\n\nid\n\n// Add to top of list\n\nconst\n\neventLog\n\ndocument\n\ngetElementById\n\n\"events\"\n\neventLog\n\nprepend\n\nreqEventLi\n\nApp\n\ncallerContract\n\nevents\n\nRandomNumberReceived\n\nasync\n\nerr\n\nevent\n\n=>\n\nif\n\nerr\n\nconsole\n\nerror\n\n'Error on event'\n\nerr\n\n// Create list item\n\nlet\n\nrecEventLi\n\ndocument\n\ncreateElement\n\n\"li\"\n\nrecEventLi\n\nclassList\n\nadd\n\n\"response\"\n\nrecEventLi\n\ninnerHTML\n\nRandom number received for ID\n\n${\n\nevent\n\nreturnValues\n\nid\n\n${\n\nevent\n\nreturnValues\n\nnumber\n\n// Add to top of list\n\nconst\n\neventLog\n\ndocument\n\ngetElementById\n\n\"events\"\n\neventLog\n\nprepend\n\nrecEventLi\n\nThis code is similar to the event subscription code we used in our data provider, but uses the web3.js Contract.events property. It waits for new contract events to be emitted and adds a record of each one to the top of the page's events list.", "start_char_idx": 19235, "end_char_idx": 23345, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c5a34225-5379-4898-8c86-ea34a52fdf59": {"__data__": {"id_": "c5a34225-5379-4898-8c86-ea34a52fdf59", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "abec822c-9991-4d9a-8e83-9b06c73a123f", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "fa87a8bf099cfd2c1bb86aad2109ad3a54879c88c5f2372e9f5b5ff44bcfbc52", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0c258e02-ce94-46d4-a17c-92c25ff71c1f", "node_type": "1", "metadata": {}, "hash": "b7f009f8dda36d0768f4314e66c813911997cc1da52a1ddd2af8f204f67cb72a", "class_name": "RelatedNodeInfo"}}, "hash": "578c75bb553a814cf1c0743e1b058f236f2428629b6537ae26e76f2d83e4a12f", "text": "It waits for new contract events to be emitted and adds a record of each one to the top of the page's events list.\n\nNext we need to work with JavaScript events and bind our random number button to the contract interaction function we wrote above. Add the following code:\n\n// interface\n\nbindBrowserEvents\n\nfunction\n\nconst\n\nrequestButton\n\ndocument\n\ngetElementById\n\n\"request-rand\"\n\nrequestButton\n\naddEventListener\n\n\"click\"\n\nasync\n\nfunction\n\nconst\n\ntransaction\n\nawait\n\nApp\n\ngetRandomNumber\n\nconst\n\nrequestID\n\ndocument\n\ngetElementById\n\n\"request-id\"\n\nrequestID\n\ninnerHTML\n\nSubmitted! Request ID:\n\n${\n\ntransaction\n\nevents\n\nRandomNumberRequested\n\nreturnValues\n\nid\n\nThis code will ensure that when we click the button, the contract function will be invoked, and the request ID in its emitted event will be printed to the page.\n\nBefore we wrap this file up, we need to invoke both of these event-related functions in our init() function. Amend the function as follows:\n\ninit\n\nasync\n\nfunction\n\nif\n\nwindow\n\nethereum\n\nawait\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n'eth_requestAccounts'\n\nwindow\n\nweb3\n\nnew\n\nWeb3\n\nwindow\n\nethereum\n\nApp\n\ncallerContract\n\nnew\n\nweb3\n\neth\n\nContract\n\ncallerABI\n\nApp\n\ncallerAddress\n\n// Switch networks\n\nApp\n\nswitchToReplitTestnet\n\n// NEW CODE BELOW\n\nApp\n\nsubscribeToContractEvents\n\nApp\n\nbindBrowserEvents\n\nWe've now got everything we need to get both oracle and oracle client up and running. In the next section, we'll deploy our contracts and connect up everything we've built.\n\nPutting it all together\u200b\n\nWe've created a lot of different pieces in the sections above. It's now time to put the puzzle together.\n\nCompiling and deploying the contracts\u200b\n\nWe'll start by compiling and deploying our contracts. But first, we need to make a change to our dependencies. Our oracle contract relies on code from version 4.6.0 of OpenZeppelin, so we'll need to edit our repl's package.json to ensure that we import that version. Open package.json now, find the dependency @openzeppelin/contracts and change the version number next to it to ^4.6.0.\n\nTo compile our contracts in the Solidity starter repository, we'll need to import them into contract.sol by their full paths. Delete the current contents of contract.sol and replace them with the following:\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"/home/runner/YOUR-REPL-NAME-HERE/contracts/caller/Caller.sol\";\n\nimport \"/home/runner/YOUR-REPL-NAME-HERE/contracts/oracle/RandOracle.sol\";\n\nEnter your repl's name as indicated. Then run your repl and wait for the Solidity starter web interface to appear, and for both contracts to compile.\n\nOnce we've compiled, we can deploy, but for that we'll need some funds. Connect your MetaMask wallet to the web interface and switch to the Replit Testnet. Then click the link to get 1 ETH for testing. Wait until 1 ETH shows up in your wallet balance on the top right of the page.\n\nNow you can deploy your contracts. Select \"Caller\" from the drop-down box and click Deploy. Approve the MetaMask pop-up that appears. Then do the same with \"RandOracle\".\n\nOnce both contracts have been deployed, they will show up as expandable boxes below the drop-down box. Expand them and take a look at the functions available in each.\n\nIn practice, the Caller and RandOracle contracts would usually be deployed by different addresses, potentially belonging to entirely different teams, but we're using a single one to avoid having to log in and out of MetaMask over and over.\n\nInitializing the contracts\u200b\n\nWe're done setting up our contracts, but leave your repl running with the Solidity starter web interface open, as we'll need it to set up our data provider application and client frontend.\n\nPreparing the data provider\u200b\n\nBefore we do anything to integrate our data provider with the blockchain, let's include axios in our repl's package.json file. Add the following line to the bottom of the dependencies object if axios is not already included as a dependency (remember to add a comma to the end of the preceding line):\n\n\"axios\"\n\n\"^0.27.2\"\n\nWith that done, we need to copy RandOracle's ABI into a file where the data provider can see it. Click on Copy ABI next to RandOracle's address to load the ABI into your clipboard. Then create a new file in provider named randOracleABI.json and paste the contents of your clipboard into it.", "start_char_idx": 23231, "end_char_idx": 27565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c258e02-ce94-46d4-a17c-92c25ff71c1f": {"__data__": {"id_": "0c258e02-ce94-46d4-a17c-92c25ff71c1f", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5a34225-5379-4898-8c86-ea34a52fdf59", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "578c75bb553a814cf1c0743e1b058f236f2428629b6537ae26e76f2d83e4a12f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7b786107-3ac1-41b7-bae9-3bb3dc5a135e", "node_type": "1", "metadata": {}, "hash": "777edb6d2f18a8e36b4e3a614adfb444a5bb814b5ae70ac187e0c07cd1229991", "class_name": "RelatedNodeInfo"}}, "hash": "b7f009f8dda36d0768f4314e66c813911997cc1da52a1ddd2af8f204f67cb72a", "text": "Initializing the contracts\u200b\n\nWe're done setting up our contracts, but leave your repl running with the Solidity starter web interface open, as we'll need it to set up our data provider application and client frontend.\n\nPreparing the data provider\u200b\n\nBefore we do anything to integrate our data provider with the blockchain, let's include axios in our repl's package.json file. Add the following line to the bottom of the dependencies object if axios is not already included as a dependency (remember to add a comma to the end of the preceding line):\n\n\"axios\"\n\n\"^0.27.2\"\n\nWith that done, we need to copy RandOracle's ABI into a file where the data provider can see it. Click on Copy ABI next to RandOracle's address to load the ABI into your clipboard. Then create a new file in provider named randOracleABI.json and paste the contents of your clipboard into it.\n\nNow open index.js, find the line beginning with const oracleContractAddress, and replace the placeholder string with the address of the deployed RandOracle contract.\n\nThe last thing we need to do to get our data provider working is to provide it with a wallet. The wallet we use for MetaMask is locked by a password, so it can't easily be used for automated operations. In any case, it's more hygenic for us to create a dedicated wallet for our data provider. We'll do this with a simple Node.js script and the ethereumjs-wallet library.\n\nOpen your repl's package.json file. Add the following line to the bottom of the dependencies object (remember to add a comma to the end of the preceding line):\n\n\"ethereumjs-wallet\"\n\n\"^1.0.2\"\n\nNow create a new file named walletGen.js. Populate it with the code below:\n\nconst\n\nwallet\n\nrequire\n\n\"ethereumjs-wallet\"\n\ndefault\n\nconst\n\naddressData\n\nwallet\n\ngenerate\n\nconsole\n\nlog\n\nPrivate key:\n\n${\n\naddressData\n\ngetPrivateKeyString\n\nconsole\n\nlog\n\nAddress:\n\n${\n\naddressData\n\ngetAddressString\n\nStop and run your repl. Navigate to the Shell tab in bottom-right panel and run the command node walletGen.js. You should see two long strings of letters and numbers appear beneath your command. The first is your new wallet's private key, and the second is your new wallet's address.\n\nAnyone who knows this private key can control the wallet, so we'll need to keep it safe. Open the Secrets tab on your repl's sidebar. Create new key named DATAPROVIDER_PRIVATE_KEY and paste in the private key as its value. Click the button \"Add new value\" to save the entry.\n\nNow we need to add the address of the new wallet as a data provider for our RandOracle contract. In your repl's web browser, navigate to the addProvider function in RandOracle. Paste in the address of your new wallet as the value for provider. Then click Run.\n\nOur new wallet will also need some ETH to send random number responses to the blockchain. We can send it some of ours using MetaMask. Open the MetaMask extension interface and click on the button marked Send. It should be right underneath your balance. Paste the data provider's wallet address into the search bar that appears. Then enter a small number into the Amount field, such as 0.2, click Next, and confirm the transaction.\n\nNow we need to configure Hardhat, so that it knows what network to connect to (the Replit Testnet) and what wallet to use (the one we just created) when running our data provider application. First add the following line to the bottom of the dependencies object (remember to add a comma to the end of the preceding line):\n\n\"@nomiclabs/hardhat-waffle\"\n\n\"^2.0.3\"\n\nCreate a file named hardhat.config.js with the following contents:\n\nrequire\n\n\"@nomiclabs/hardhat-waffle\"\n\n// You need to export an object to set up your config\n\n// Go to https://hardhat.org/config/ to learn more\n\n/**\n\n@type import('hardhat/config').HardhatUserConfig\n\n/\n\nmodule\n\nexports\n\nnetworks\n\nreplit\n\nurl\n\nhttps://eth.replit.com\n\naccounts\n\nprocess\n\nenv\n\nDATAPROVIDER_PRIVATE_KEY\n\nsolidity\n\n\"0.8.2\"\n\nThat's it for our data provider. Now we just need to prepare the client frontend.\n\nPreparing the client frontend\u200b\n\nWe need to fill in the ABI and address for Caller. Click on Copy ABI next to Caller's address to load the ABI into your clipboard. Then create a new file in frontend named callerABI.js and add the following code to it:\n\ncallerABI\n\nPaste the contents of your clipboard after the equals sign.", "start_char_idx": 26705, "end_char_idx": 31016, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7b786107-3ac1-41b7-bae9-3bb3dc5a135e": {"__data__": {"id_": "7b786107-3ac1-41b7-bae9-3bb3dc5a135e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "0fe9b7de0b4ea14151415f11742a50896d772fe28a586f704d501dffa4feb41d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0c258e02-ce94-46d4-a17c-92c25ff71c1f", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}, "hash": "b7f009f8dda36d0768f4314e66c813911997cc1da52a1ddd2af8f204f67cb72a", "class_name": "RelatedNodeInfo"}}, "hash": "777edb6d2f18a8e36b4e3a614adfb444a5bb814b5ae70ac187e0c07cd1229991", "text": "Now we just need to prepare the client frontend.\n\nPreparing the client frontend\u200b\n\nWe need to fill in the ABI and address for Caller. Click on Copy ABI next to Caller's address to load the ABI into your clipboard. Then create a new file in frontend named callerABI.js and add the following code to it:\n\ncallerABI\n\nPaste the contents of your clipboard after the equals sign. We've already included this file in frontend/index.html, so now we just need the contract address. Open frontend/app.js and paste the address of Caller in place of the placeholder value of callerAddress near the top of the file.\n\nWe'll also need to create a simple Node.js Express application to render the frontend. Create a file named frontend.js in your repl and add the following code to it:\n\nconst\n\nexpress\n\nrequire\n\n\"express\"\n\nconst\n\napp\n\nexpress\n\nconst\n\nPORT\n\n433\n\napp\n\nuse\n\nexpress\n\nstatic\n\n\"frontend\"\n\napp\n\nlisten\n\nPORT\n\n=>\n\nconsole\n\nlog\n\nServer listening on port:\n\n${\n\nPORT\n\nRunning the repl\u200b\n\nNow that we have everything connected, we want to replace the Solidity starter interface with our data provider application and client frontend. To do this, make sure that hidden files are showing and open .replit.\n\nReplace run = \"node tools\" with the following:\n\nrun = \"sh start.sh\"\n\nThis will make our repl run a Bash script instead of single command, which is useful when we need to run more than one thing. Create a file named start.sh and add the following code to it:\n\n# Start data provider in the background\n\nnpx hardhat run provider --network replit\n\n# Start client frontend\n\nnode\n\nfrontend.js\n\nWe must run the provider as a Hardhat script rather than a plain Node.js application to use our Hardhat configuration. The & symbol will make the data provider run in the background, so that we can also start the frontend.\n\nOur client and oracle are finally both ready to roll. Stop your repl and rerun it. You should see our frontend in the repl browser. Click the button to request a random number and watch the events come in.\n\nWhere next?\u200b\n\nIn this tutorial, we've built a simplified version of Chainlink's Verifiable Random Function oracle. While ours doesn't provide the same level of robust security, building it has given us insight into how smart contracts can work with off-chain data, and we can use it for other projects in the future, or let other Solidity developers on Replit use it for their projects.\n\nSome next steps you might want to try:\n\nCreate a few new repls containing just the data provider code and give each one its own wallet. Add the addresses as data providers to RandOracle, increase the providers threshold, and see how the contract works with more than one provider.\n\nBuild something more sophisticated on top of Client. For example, you could adapt the ReplBot NFT contracts to use this oracle as a source of randomness. Or you could write something like a lottery contract.\n\nExperiment with different data sources. An oracle can be a source for any data you can think of, from stock prices to the weather.\n\nYou can find our repl below:\n\n< Previous: Robot NFT Part 1: on Ethereum blockchain\n\nNext: Escrow contract with Solidity >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting startedSolidity replBrowser wallet\n\nOracle design\n\nCaller contract\n\nOracle contract\n\nNode.js data provider\n\nCaller contract frontend\n\nPutting it all togetherCompiling and deploying the contractsInitializing the contractsPreparing the data providerPreparing the client frontendRunning the repl\n\nWhere next?", "start_char_idx": 30644, "end_char_idx": 34151, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"af5ccd32-aada-4b69-866c-1d3271c6b2b0": {"node_ids": ["bfca46c3-7b53-4266-8de8-f749b9995d8b", "dbe70d9e-0bb9-4784-b18c-8078c099b70d", "522c577e-6ea8-4b26-b6ae-a42f9c83d5c7", "2d2d0bc3-0b14-4c51-9f1f-5c714d7502b2", "c5102ced-dc27-4b6d-852c-4b1cd2555744", "abec822c-9991-4d9a-8e83-9b06c73a123f", "c5a34225-5379-4898-8c86-ea34a52fdf59", "0c258e02-ce94-46d4-a17c-92c25ff71c1f", "7b786107-3ac1-41b7-bae9-3bb3dc5a135e"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-smart-contract-oracle.html"}}}, "docstore/metadata": {"bfca46c3-7b53-4266-8de8-f749b9995d8b": {"doc_hash": "c8a9bd4337691fbad401813edea18918a2cc592414505d9f6354887c0f14b1a1", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "dbe70d9e-0bb9-4784-b18c-8078c099b70d": {"doc_hash": "0b8c94bd60c01a6c1888a96615d91718cb32359c1877204cdf0f36f7965df0c2", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "522c577e-6ea8-4b26-b6ae-a42f9c83d5c7": {"doc_hash": "75de3437d139ffc14b962c618599fbc8c253757d2460f05ddfe918aa3ce58ccb", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "2d2d0bc3-0b14-4c51-9f1f-5c714d7502b2": {"doc_hash": "83e98083bb58a7b97ccc5e1332a26fea1eefd5e529187040aa235e58296969a5", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "c5102ced-dc27-4b6d-852c-4b1cd2555744": {"doc_hash": "d0b813b6988109a5d2cee901e9a922464c28f009eacfabbad919216a42467a4e", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "abec822c-9991-4d9a-8e83-9b06c73a123f": {"doc_hash": "fa87a8bf099cfd2c1bb86aad2109ad3a54879c88c5f2372e9f5b5ff44bcfbc52", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "c5a34225-5379-4898-8c86-ea34a52fdf59": {"doc_hash": "578c75bb553a814cf1c0743e1b058f236f2428629b6537ae26e76f2d83e4a12f", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "0c258e02-ce94-46d4-a17c-92c25ff71c1f": {"doc_hash": "b7f009f8dda36d0768f4314e66c813911997cc1da52a1ddd2af8f204f67cb72a", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}, "7b786107-3ac1-41b7-bae9-3bb3dc5a135e": {"doc_hash": "777edb6d2f18a8e36b4e3a614adfb444a5bb814b5ae70ac187e0c07cd1229991", "ref_doc_id": "af5ccd32-aada-4b69-866c-1d3271c6b2b0"}}}