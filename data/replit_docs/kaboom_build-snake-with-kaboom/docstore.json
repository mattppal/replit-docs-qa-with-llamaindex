{"docstore/data": {"3ea34374-3bd4-48b0-9588-ef13e324fa14": {"__data__": {"id_": "3ea34374-3bd4-48b0-9588-ef13e324fa14", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6de60457-517f-458b-b68c-429b220b678a", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "2eb97032793a1855e4f509edcedcf4ab5805396b2e1f66bb81178cb0d296cb4d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "388ce55b-626a-4269-bddd-55233f3736d2", "node_type": "1", "metadata": {}, "hash": "d789ea82de8a8edb1645d53c80c5b9b6d75b8cafb6f642774432f1e2d170cc05", "class_name": "RelatedNodeInfo"}}, "hash": "44ecf2768da8ae65fa5a70a8bc94c3040460d40ce774c28017eb2d8c0a797ca9", "text": "Then Kaboom.js allows us to specify what to draw for each symbol in the text map. We're only using one symbol here, =, but you can make maps out of many different elements \u2013 e.g., a symbol for a wall, a symbol for water, a symbol for a health kit and so on. To tell Kaboom.js what to draw for the symbol, we add the symbol as a key, as in =, and then specify parameters for it. In this code, we draw a red rectangle as each piece of the boundary wall. The area() component generates the collision area which will be useful when we want to check for collision between the snake and wall later on. The string wall assigns a tag to each of the pieces of wall drawn, which will also help us with collision detection later on.\n\nIf we run this code, we should see the outline of a red square on the screen, representing the map.\n\nAdding the Snake\u200b\n\nNow that we have a map, let's add the snake. The snake is made up of a number of blocks moving together. We'll need to keep track of these so that we can move them together, so an array would be a good data structure to use here.\n\nWe also need to start the snake off with a given size, position and direction to move in on the map. It can return to these each time the game ends as well. So we should make a function that we can call whenever a new game starts, or the old one ends, to reset the snake to a default position and size.\n\nWe'll need to add a few variables and constants that our snake drawing function will use. Add these definitions above the const block_size = 20; we added earlier:\n\nconst\n\ndirections\n\nUP\n\n\"up\"\n\nDOWN\n\n\"down\"\n\nLEFT\n\n\"left\"\n\nRIGHT\n\n\"right\"\n\nlet\n\ncurrent_direction\n\ndirections\n\nRIGHT\n\nlet\n\nrun_action\n\nfalse\n\nlet\n\nsnake_length\n\nlet\n\nsnake_body\n\nFirst, we define an object with properties for each of the allowable directions the snake can move in. This makes code that checks and changes directions easy to read and change, compared to just using numbers or strings to define the directions. The variable current_direction tracks the direction the snake is moving at any given time. We choose a starting direction, RIGHT, as its default. run_action is a flag variable that we'll use to flag if we are in the actual game, or setting up, or ending the game. The variable snake_length keeps track of how long the snake tail has become \u2013 we start it at a chosen value of 3. Finally, snake_body holds all the screen objects that make up the snake's body.\n\nNow we can add a function to spawn, and respawn, the snake.\n\nLet's add this function:\n\nfunction\n\nrespawn_snake\n\ndestroyAll\n\n\"snake\"\n\nsnake_body\n\nsnake_length\n\nfor\n\nlet\n\n<=\n\nsnake_length\n\n++\n\nlet\n\nsegment\n\nadd\n\nrect\n\nblock_size\n\nblock_size\n\npos\n\nblock_size\n\nblock_size\n\ncolor\n\n255\n\narea\n\n\"snake\"\n\nsnake_body\n\npush\n\nsegment\n\ncurrent_direction\n\ndirections\n\nRIGHT\n\nfunction\n\nrespawn_all\n\nrun_action\n\nfalse\n\nwait\n\n0.5\n\nfunction\n\nrespawn_snake\n\nrun_action\n\ntrue\n\nrespawn_all\n\nFirst, the function gets rid of any existing snake segment objects by using the Kaboom.js destroyAll function. This removes any object with the given tag from the game. Then we reset our segment array to an empty array, and the snake length back to the default.\n\nThen the function sets up a loop to create new snake segments, up to the length we specified. It does this by calling the Kaboom.js add method, which adds a new object to the game. add takes a few parameters, as components of the object to create. We pass in components to specify how to draw the object (using rect), its color, and a tag \"snake\" to identify the segments when we are checking collisions, and updating/removing segments. We also specify the position for the segment we create. To create the starting snake, we just ensure it is at least one block_size, or block, from the left side, and then add each subsequent segment one more block down per loop. This gives a straight snake pointing down to start. Then we add the new segment to our snake_body array to keep track of it.\n\nFinally, we set a default starting direction for the snake to move in.\n\nwait function, with a small delay of 0.5 seconds.", "start_char_idx": 0, "end_char_idx": 4070, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "388ce55b-626a-4269-bddd-55233f3736d2": {"__data__": {"id_": "388ce55b-626a-4269-bddd-55233f3736d2", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6de60457-517f-458b-b68c-429b220b678a", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "2eb97032793a1855e4f509edcedcf4ab5805396b2e1f66bb81178cb0d296cb4d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3ea34374-3bd4-48b0-9588-ef13e324fa14", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "44ecf2768da8ae65fa5a70a8bc94c3040460d40ce774c28017eb2d8c0a797ca9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aea97bc1-da55-4990-b290-39fede4bac72", "node_type": "1", "metadata": {}, "hash": "230280ec25d1abf9355adc517f21b2f9389603985beef33683800702a60cd273", "class_name": "RelatedNodeInfo"}}, "hash": "d789ea82de8a8edb1645d53c80c5b9b6d75b8cafb6f642774432f1e2d170cc05", "text": "It does this by calling the Kaboom.js add method, which adds a new object to the game. add takes a few parameters, as components of the object to create. We pass in components to specify how to draw the object (using rect), its color, and a tag \"snake\" to identify the segments when we are checking collisions, and updating/removing segments. We also specify the position for the segment we create. To create the starting snake, we just ensure it is at least one block_size, or block, from the left side, and then add each subsequent segment one more block down per loop. This gives a straight snake pointing down to start. Then we add the new segment to our snake_body array to keep track of it.\n\nFinally, we set a default starting direction for the snake to move in.\n\nwait function, with a small delay of 0.5 seconds. This is because when we detect a \"game over\" condition, we don't immediately want to reset the game, as it could be a bit disorienting to a player.\n\nRunning the code now, you should see a blue line at the top-left side of the map.\n\nMoving the Snake\u200b\n\nNow that we've got map boundaries, and a snake drawn on the screen, we can work on getting player input and moving the snake around.\n\nKaboom.js has a function onKeyPress, which can call a supplied function whenever a particular key is pressed. We'll use that to determine which way the player wants the snake to go. Add this code to get user direction input:\n\nonKeyPress\n\n\"up\"\n\n=>\n\nif\n\ncurrent_direction\n\n!=\n\ndirections\n\nDOWN\n\ncurrent_direction\n\ndirections\n\nUP\n\nonKeyPress\n\n\"down\"\n\n=>\n\nif\n\ncurrent_direction\n\n!=\n\ndirections\n\nUP\n\ncurrent_direction\n\ndirections\n\nDOWN\n\nonKeyPress\n\n\"left\"\n\n=>\n\nif\n\ncurrent_direction\n\n!=\n\ndirections\n\nRIGHT\n\ncurrent_direction\n\ndirections\n\nLEFT\n\nonKeyPress\n\n\"right\"\n\n=>\n\nif\n\ncurrent_direction\n\n!=\n\ndirections\n\nLEFT\n\ncurrent_direction\n\ndirections\n\nRIGHT\n\nFor each of the named \"arrow\" keys, we set up a function to call if the key is pressed. In each of these functions, we check to ensure that the new direction input is not the complete opposite direction to which the snake is currently moving. This is because we don't want to allow the snake to reverse. If the input direction is a legal move, we update the current_direction property to the new direction.\n\nNow we need to think about how to make the snake appear to move on the screen. A way to do this is to check which direction the snake is heading, and add a block in front of the snake in that direction. Then we'll need to remove a block at the tail-end of the snake. We'll need to do this a few times in a second so that the snake appears to be moving smoothly. Kaboom.js has a function onUpdate which can be used to update game objects on each frame. Add the following code, which uses the onUpdate function, to move the snake:\n\nlet\n\nmove_delay\n\n0.2\n\nlet\n\ntimer\n\nonUpdate\n\n=>\n\nif\n\nrun_action\n\nreturn\n\ntimer\n\n+=\n\ndt\n\nif\n\ntimer\n\nmove_delay\n\nreturn\n\ntimer\n\nlet\n\nmove_x\n\nlet\n\nmove_y\n\nswitch\n\ncurrent_direction\n\ncase\n\ndirections\n\nDOWN\n\nmove_x\n\nmove_y\n\nblock_size\n\nbreak\n\ncase\n\ndirections\n\nUP\n\nmove_x\n\nmove_y\n\nblock_size\n\nbreak\n\ncase\n\ndirections\n\nLEFT\n\nmove_x\n\nblock_size\n\nmove_y\n\nbreak\n\ncase\n\ndirections\n\nRIGHT\n\nmove_x\n\nblock_size\n\nmove_y\n\nbreak\n\n// Get the last element (the snake head)\n\nlet\n\nsnake_head\n\nsnake_body\n\nsnake_body\n\nlength\n\nsnake_body\n\npush\n\nadd\n\nrect\n\nblock_size\n\nblock_size\n\npos\n\nsnake_head\n\npos\n\nmove_x\n\nsnake_head\n\npos\n\nmove_y\n\ncolor\n\n255\n\narea\n\n\"snake\"\n\nif\n\nsnake_body\n\nlength\n\nsnake_length\n\nlet\n\ntail\n\nsnake_body\n\nshift\n\n// Remove the last of the tail\n\ndestroy\n\ntail\n\ndt() function to get the time that has elapsed between the previous and current frame, so that we can keep track if 0.2 seconds has elapsed for us to move the snake. If the desired delay has not elapsed we exit early without updating anything otherwise we reset the timer and execute the code to move the snake. You can try experiment with different times to see the effect on the game by adjusting the value of the\n\nThen the function switches on the value of the current direction the snake is heading in.", "start_char_idx": 3251, "end_char_idx": 7301, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aea97bc1-da55-4990-b290-39fede4bac72": {"__data__": {"id_": "aea97bc1-da55-4990-b290-39fede4bac72", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6de60457-517f-458b-b68c-429b220b678a", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "2eb97032793a1855e4f509edcedcf4ab5805396b2e1f66bb81178cb0d296cb4d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "388ce55b-626a-4269-bddd-55233f3736d2", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "d789ea82de8a8edb1645d53c80c5b9b6d75b8cafb6f642774432f1e2d170cc05", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9e3cd6b3-15bb-48e4-894f-a8be300d8bbf", "node_type": "1", "metadata": {}, "hash": "891f46880e7130aa94194af09c22506ce06695ca1d4b02c1b274ff6999a351a9", "class_name": "RelatedNodeInfo"}}, "hash": "230280ec25d1abf9355adc517f21b2f9389603985beef33683800702a60cd273", "text": "If the desired delay has not elapsed we exit early without updating anything otherwise we reset the timer and execute the code to move the snake. You can try experiment with different times to see the effect on the game by adjusting the value of the\n\nThen the function switches on the value of the current direction the snake is heading in. For each direction, the move_x and move_y are set to either 0, block_size or -1 * block_size. If the snake is moving left or right, we add or subtract a block from the x dimension accordingly. The same occurs if the snake is moving up or down, but in the y dimension.\n\nAfter the switch, we get the current snake head by indexing the last element in the snake body array. Now that we have both the current snake head position, and the position amount relative to the snake head to move in, we can create the new snake head by adding a new block game object. This is similar to the code we used in respawn_snake.\n\nNow all that remains is to remove a block at the tail end of the snake, using the built-in array shift function, which removes the first element from an array, and returns that element. Because our 'oldest' part of the snake, also known as a tail, is the first element, we call shift on the array, and then the Kaboom.js destroy function to get rid of the segment. We only do this if the current length of the snake body array is greater than our determined snake length. This means if we increase snake_length, the overall length of the snake on the screen will also increase. We can use this when we add food to the game.\n\nRunning the project now and clicking into the game screen should allow you to move the snake around. Note that there isn't collision detection yet, so the snake can go out of bounds without consequence.\n\nAdding Snake Food\u200b\n\nWe have a snake, it moves, and a player can steer it. Let's add some food that the snake can eat, which will cause it to grow longer. Whenever the snake eats the food, we'll have to respawn the food again, so let's write the food creation code in a function as well, like we did for the snake:\n\nlet\n\nfood\n\nnull\n\nfunction\n\nrespawn_food\n\nlet\n\nnew_pos\n\nrand\n\nvec2\n\nvec2\n\n13\n\n13\n\nnew_pos\n\nMath\n\nfloor\n\nnew_pos\n\nnew_pos\n\nMath\n\nfloor\n\nnew_pos\n\nnew_pos\n\nnew_pos\n\nscale\n\nblock_size\n\nif\n\nfood\n\ndestroy\n\nfood\n\nfood\n\nadd\n\nrect\n\nblock_size\n\nblock_size\n\ncolor\n\n255\n\npos\n\nnew_pos\n\narea\n\n\"food\"\n\nFirstly, we set up a variable food so that we can keep track of food objects we create. You can move this variable up to where we declared other variables, like block_size and snake_body if you want to keep them all neatly in the same place.\n\nThen the function respawn_food does a few things. In the game of snake, once a food block is eaten, another one appears at a random location on the grid. This means we'll need a random number generator to determine the location to place the food. Kaboom.js has a function called rand which we can use to find a random position on the screen to place the food. We need both random x and y co-ordinates \u2013 conveniently, the rand function can accept 2D vectors as the start and end amount for the random range to generate numbers in, and will then return another 2D vector as a result.\n\nWhy do we choose a range of 1-13 for the random position of the food? If you look at the map we added earlier, it is 14 spaces across and 14 spaces down. These are the dimensions of our screen in grid blocks. Because we don't want to draw the food over the boundaries, we use 1-13 to choose blocks within the map. Now, the rand function returns real numbers, with decimals, not integers. This means we need to add the Math.floor call to truncate any decimals off the random numbers, as we don't want to place the food halfway through a particular grid block. We also need to convert from our grid co-ordinates to regular screen pixels. This is done by multiplying each co-ordinate by the block_size, which specifies the size of each grid block in pixels. We make use of the Kaboom.js scale method on the vec2 class to perform the multiplication.\n\nThe next part of the function checks if the food variable already contains an existing food object. If it does, we call destroy to remove that food from the game.", "start_char_idx": 6961, "end_char_idx": 11179, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9e3cd6b3-15bb-48e4-894f-a8be300d8bbf": {"__data__": {"id_": "9e3cd6b3-15bb-48e4-894f-a8be300d8bbf", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6de60457-517f-458b-b68c-429b220b678a", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "2eb97032793a1855e4f509edcedcf4ab5805396b2e1f66bb81178cb0d296cb4d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aea97bc1-da55-4990-b290-39fede4bac72", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "230280ec25d1abf9355adc517f21b2f9389603985beef33683800702a60cd273", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "06614d85-fc0f-4883-84bc-8e9713495bd6", "node_type": "1", "metadata": {}, "hash": "e560586f74a1ae32d36f51f8946434a1e81d226373a8e7942c3ec6f4dc39ed79", "class_name": "RelatedNodeInfo"}}, "hash": "891f46880e7130aa94194af09c22506ce06695ca1d4b02c1b274ff6999a351a9", "text": "These are the dimensions of our screen in grid blocks. Because we don't want to draw the food over the boundaries, we use 1-13 to choose blocks within the map. Now, the rand function returns real numbers, with decimals, not integers. This means we need to add the Math.floor call to truncate any decimals off the random numbers, as we don't want to place the food halfway through a particular grid block. We also need to convert from our grid co-ordinates to regular screen pixels. This is done by multiplying each co-ordinate by the block_size, which specifies the size of each grid block in pixels. We make use of the Kaboom.js scale method on the vec2 class to perform the multiplication.\n\nThe next part of the function checks if the food variable already contains an existing food object. If it does, we call destroy to remove that food from the game. Finally, the function creates a new food object by calling the Kaboom.js add function to create a new food object at the random position we made.\n\nTo call this new respawn_food function, we need to update our respawn_all function, like this:\n\nfunction\n\nrespawn_all\n\nrun_action\n\nfalse\n\nwait\n\n0.5\n\nfunction\n\nrespawn_snake\n\nrespawn_food\n\nrun_action\n\ntrue\n\nRunning the game now shows a green food block positioned somewhere randomly on the map:\n\nDetecting Collisions\u200b\n\nNow that we have all the objects our game needs \u2013 a boundary wall, a snake, and food \u2013 we can move on to detecting interactions, or collisions, between these objects.\n\nKaboom.js has a useful function for helping with this: onCollide. The function takes in 2 tags for different game object types, and calls a provided callback function if there is a collision of the objects.\n\nLet's start with detecting if the snake moves over a food block. Add the code below:\n\nonCollide\n\n\"snake\"\n\n\"food\"\n\n=>\n\nsnake_length\n\n++\n\nrespawn_food\n\nWe set up the onCollide function with tags for the snake, and the food object. Then, in the callback function, snake_length is increased by 1, and we call respawn_food to replace the eaten food somewhere else on the map.\n\nRunning this, and eating the food, you should see the snake grow each time, and the food re-appear on another block:\n\nNow, we can add similar code to detect if the snake has hit the wall:\n\nonCollide\n\n\"snake\"\n\n\"wall\"\n\n=>\n\nrun_action\n\nfalse\n\nshake\n\n12\n\nrespawn_all\n\nIn the callback function, we immediately set the run_action flag to false. This is so that the code in the move loop does not run and create the appearance of the snake stuck in the wall. Then the code calls a cool Kaboom.js effect function shake, which \"shakes\" the screen in a way that makes it feel like the snake has crashed heavily, and communicates quite effectively that the game is over. Finally, we call respawn_all to reset all the game objects.\n\nWe can use the same code to detect if the snake has hit itself \u2013 we just replace the wall tag with another snake tag:\n\nonCollide\n\n\"snake\"\n\n\"snake\"\n\n=>\n\nrun_action\n\nfalse\n\nshake\n\n12\n\nrespawn_all\n\nRunning the game now, and crashing into the wall should look something like this:\n\nCongratulations! You've finished creating Snake in Kaboom.js!\n\nImproving the Graphics\u200b\n\nWe have a working snake game, but it does look a bit bland. Kaboom.js has good support for sprites, which are small pictures used to represent game objects and characters. Replit also has built-in management and loading of sprites for Kaboom.js to take care of the overhead in using sprites.\n\nUsing sprites, let's give the snake something nicer to eat than a green block. Right click and select \"Save image as\" on the pizza slice below, and save it to your computer. Then, in Replit, click the upload button next to \"Sprites\" and upload the pizza to your repl.\n\nNow, we can update the respawn_food function to use this sprite, instead of drawing a green block. Remove the lines rect and color, and replace with a call to add the pizza sprite, like this:\n\nfunction\n\nrespawn_food\n\nlet\n\nnew_pos\n\nrand\n\nvec2\n\nvec2\n\n13\n\n13\n\nnew_pos\n\nMath\n\nfloor\n\nnew_pos\n\nnew_pos\n\nMath\n\nfloor\n\nnew_pos\n\nnew_pos\n\nnew_pos\n\nscale\n\nblock_size\n\nif\n\nfood\n\ndestroy\n\nfood\n\nfood\n\nadd\n\nsprite\n\n\"pizza\"\n\npos\n\nnew_pos\n\narea\n\n\"food\"\n\nWe can also update the background to be more interesting.", "start_char_idx": 10324, "end_char_idx": 14536, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06614d85-fc0f-4883-84bc-8e9713495bd6": {"__data__": {"id_": "06614d85-fc0f-4883-84bc-8e9713495bd6", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6de60457-517f-458b-b68c-429b220b678a", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "2eb97032793a1855e4f509edcedcf4ab5805396b2e1f66bb81178cb0d296cb4d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9e3cd6b3-15bb-48e4-894f-a8be300d8bbf", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "891f46880e7130aa94194af09c22506ce06695ca1d4b02c1b274ff6999a351a9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1a1ef17b-174f-4bc3-8f97-f693b540eb68", "node_type": "1", "metadata": {}, "hash": "2593efd02e3452957a64bc7039b257137e27e2ef3b66b67e3c3b0449b6eefd91", "class_name": "RelatedNodeInfo"}}, "hash": "e560586f74a1ae32d36f51f8946434a1e81d226373a8e7942c3ec6f4dc39ed79", "text": "Using sprites, let's give the snake something nicer to eat than a green block. Right click and select \"Save image as\" on the pizza slice below, and save it to your computer. Then, in Replit, click the upload button next to \"Sprites\" and upload the pizza to your repl.\n\nNow, we can update the respawn_food function to use this sprite, instead of drawing a green block. Remove the lines rect and color, and replace with a call to add the pizza sprite, like this:\n\nfunction\n\nrespawn_food\n\nlet\n\nnew_pos\n\nrand\n\nvec2\n\nvec2\n\n13\n\n13\n\nnew_pos\n\nMath\n\nfloor\n\nnew_pos\n\nnew_pos\n\nMath\n\nfloor\n\nnew_pos\n\nnew_pos\n\nnew_pos\n\nscale\n\nblock_size\n\nif\n\nfood\n\ndestroy\n\nfood\n\nfood\n\nadd\n\nsprite\n\n\"pizza\"\n\npos\n\nnew_pos\n\narea\n\n\"food\"\n\nWe can also update the background to be more interesting. To do this, we can make use of Kaboom.js' layers concept. This allows us to create different graphic layers, for example one for a static background image, another one for the active game objects over that, and another top layer for stats and scores etc.\n\nWe'll create 2 layers, background and game, to support a background. Download and add the background grass image below to your repl as you did for the pizza slice:\n\nNow, we can set up the layers and add the background grass. Add the following code to the top of the main file:\n\nlayers\n\n\"background\"\n\n\"game\"\n\n\"game\"\n\nadd\n\nsprite\n\n\"background\"\n\nlayer\n\n\"background\"\n\nThis sets up our 2 layers, and makes the game layer the default layer to draw on. Whenever we call add, we can optionally specify a layer to put the object on \u2013 if we don't specify a layer, it uses whatever we set as default in the call to layers. Then we add our background sprite to the background layer.\n\nNext, we can update the boundaries to look a bit better. Recall that in our map we add with addLevel, each different symbol we use can map to a different game object. Using this, we can create a good looking border fence, with different elements for each side and corners. Download the following 8 sprites as before, and upload them to your repl:\n\nNow, we can update the level map to use these. Replace the previous addLevel code with the following code:\n\nconst\n\nmap\n\naddLevel\n\n\"1tttttttttttt2\"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"l            r \"\n\n\"3bbbbbbbbbbbb4\"\n\nwidth\n\nblock_size\n\nheight\n\nblock_size\n\npos\n\nvec2\n\n=>\n\nsprite\n\n\"fence-top\"\n\narea\n\n\"wall\"\n\n=>\n\nsprite\n\n\"fence-bottom\"\n\narea\n\n\"wall\"\n\n=>\n\nsprite\n\n\"fence-left\"\n\narea\n\n\"wall\"\n\n=>\n\nsprite\n\n\"fence-right\"\n\narea\n\n\"wall\"\n\n=>\n\nsprite\n\n\"post-top-left\"\n\narea\n\n\"wall\"\n\n=>\n\nsprite\n\n\"post-top-right\"\n\narea\n\n\"wall\"\n\n=>\n\nsprite\n\n\"post-bottom-left\"\n\narea\n\n\"wall\"\n\n=>\n\nsprite\n\n\"post-bottom-right\"\n\narea\n\n\"wall\"\n\nThe last thing is to upgrade the snake itself. Download the skin below, and upload to the repl as before.\n\nWe create snake pieces in 2 places: in the respawn_snake function, and in the draw loop. Update both to use the snake skin sprite instead of a blue block. The respawn_snake function should look like this:\n\nfunction\n\nrespawn_snake\n\nsnake_body\n\nforEach\n\nsegment\n\n=>\n\ndestroy\n\nsegment\n\nsnake_body\n\nsnake_length\n\nfor\n\nlet\n\n<=\n\nsnake_length\n\n++\n\nsnake_body\n\npush\n\nadd\n\nsprite\n\n\"snake-skin\"\n\npos\n\nblock_size\n\nblock_size\n\narea\n\n\"snake\"\n\ncurrent_direction\n\ndirections\n\nRIGHT\n\nIn the loop callback, the updated code for adding a new snake segment to the body should now look like this:\n\nsnake_body\n\npush\n\nadd\n\nsprite\n\n\"snake-skin\"\n\npos\n\nsnake_head\n\npos\n\nmove_x\n\nsnake_head\n\npos\n\nmove_y\n\narea\n\n\"snake\"\n\nBefore we run the game we need to load the sprites that we made reference to in the code snippets above.", "start_char_idx": 13773, "end_char_idx": 17503, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a1ef17b-174f-4bc3-8f97-f693b540eb68": {"__data__": {"id_": "1a1ef17b-174f-4bc3-8f97-f693b540eb68", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6de60457-517f-458b-b68c-429b220b678a", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "2eb97032793a1855e4f509edcedcf4ab5805396b2e1f66bb81178cb0d296cb4d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "06614d85-fc0f-4883-84bc-8e9713495bd6", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}, "hash": "e560586f74a1ae32d36f51f8946434a1e81d226373a8e7942c3ec6f4dc39ed79", "class_name": "RelatedNodeInfo"}}, "hash": "2593efd02e3452957a64bc7039b257137e27e2ef3b66b67e3c3b0449b6eefd91", "text": "Update both to use the snake skin sprite instead of a blue block. The respawn_snake function should look like this:\n\nfunction\n\nrespawn_snake\n\nsnake_body\n\nforEach\n\nsegment\n\n=>\n\ndestroy\n\nsegment\n\nsnake_body\n\nsnake_length\n\nfor\n\nlet\n\n<=\n\nsnake_length\n\n++\n\nsnake_body\n\npush\n\nadd\n\nsprite\n\n\"snake-skin\"\n\npos\n\nblock_size\n\nblock_size\n\narea\n\n\"snake\"\n\ncurrent_direction\n\ndirections\n\nRIGHT\n\nIn the loop callback, the updated code for adding a new snake segment to the body should now look like this:\n\nsnake_body\n\npush\n\nadd\n\nsprite\n\n\"snake-skin\"\n\npos\n\nsnake_head\n\npos\n\nmove_x\n\nsnake_head\n\npos\n\nmove_y\n\narea\n\n\"snake\"\n\nBefore we run the game we need to load the sprites that we made reference to in the code snippets above. Add the following code, below the line kaboom(); to load the sprites and make them available in the game:\n\nloadSprite\n\n\"background\"\n\n\"sprites/background.png\"\n\nloadSprite\n\n\"fence-top\"\n\n\"sprites/fence-top.png\"\n\nloadSprite\n\n\"fence-bottom\"\n\n\"sprites/fence-bottom.png\"\n\nloadSprite\n\n\"fence-left\"\n\n\"sprites/fence-left.png\"\n\nloadSprite\n\n\"fence-right\"\n\n\"sprites/fence-right.png\"\n\nloadSprite\n\n\"post-top-left\"\n\n\"sprites/post-top-left.png\"\n\nloadSprite\n\n\"post-top-right\"\n\n\"sprites/post-top-right.png\"\n\nloadSprite\n\n\"post-bottom-left\"\n\n\"sprites/post-bottom-left.png\"\n\nloadSprite\n\n\"post-bottom-right\"\n\n\"sprites/post-bottom-right.png\"\n\nloadSprite\n\n\"snake-skin\"\n\n\"sprites/snake-skin.png\"\n\nloadSprite\n\n\"pizza\"\n\n\"sprites/pizza.png\"\n\nIf you run the game now, you should see it looking much better!\n\nThings to Try\u200b\n\nThere is a lot of good functionality in Kaboom.js to try out, and make the game more entertaining. Here are some suggestions:\n\nCreate a 2 player version.\n\nAdd obstacles for the snake.\n\nIncrementally speed up the game as it goes on, to make it harder. You can do this by adjusting the delay parameter of the loop function as the game progresses.\n\nAdd sound effects and background music.\n\n< Previous: Mario with Kaboom.js\n\nNext: Space Invaders with Kaboom.js >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nOverview and Requirements\n\nCreating a New Project\n\nGetting Started with Kaboom.js\n\nCreating the Game Map\n\nAdding the Snake\n\nMoving the Snake\n\nAdding Snake Food\n\nDetecting Collisions\n\nImproving the Graphics\n\nThings to Try", "start_char_idx": 16795, "end_char_idx": 19027, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"6de60457-517f-458b-b68c-429b220b678a": {"node_ids": ["3ea34374-3bd4-48b0-9588-ef13e324fa14", "388ce55b-626a-4269-bddd-55233f3736d2", "aea97bc1-da55-4990-b290-39fede4bac72", "9e3cd6b3-15bb-48e4-894f-a8be300d8bbf", "06614d85-fc0f-4883-84bc-8e9713495bd6", "1a1ef17b-174f-4bc3-8f97-f693b540eb68"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-snake-with-kaboom.html"}}}, "docstore/metadata": {"3ea34374-3bd4-48b0-9588-ef13e324fa14": {"doc_hash": "44ecf2768da8ae65fa5a70a8bc94c3040460d40ce774c28017eb2d8c0a797ca9", "ref_doc_id": "6de60457-517f-458b-b68c-429b220b678a"}, "388ce55b-626a-4269-bddd-55233f3736d2": {"doc_hash": "d789ea82de8a8edb1645d53c80c5b9b6d75b8cafb6f642774432f1e2d170cc05", "ref_doc_id": "6de60457-517f-458b-b68c-429b220b678a"}, "aea97bc1-da55-4990-b290-39fede4bac72": {"doc_hash": "230280ec25d1abf9355adc517f21b2f9389603985beef33683800702a60cd273", "ref_doc_id": "6de60457-517f-458b-b68c-429b220b678a"}, "9e3cd6b3-15bb-48e4-894f-a8be300d8bbf": {"doc_hash": "891f46880e7130aa94194af09c22506ce06695ca1d4b02c1b274ff6999a351a9", "ref_doc_id": "6de60457-517f-458b-b68c-429b220b678a"}, "06614d85-fc0f-4883-84bc-8e9713495bd6": {"doc_hash": "e560586f74a1ae32d36f51f8946434a1e81d226373a8e7942c3ec6f4dc39ed79", "ref_doc_id": "6de60457-517f-458b-b68c-429b220b678a"}, "1a1ef17b-174f-4bc3-8f97-f693b540eb68": {"doc_hash": "2593efd02e3452957a64bc7039b257137e27e2ef3b66b67e3c3b0449b6eefd91", "ref_doc_id": "6de60457-517f-458b-b68c-429b220b678a"}}}