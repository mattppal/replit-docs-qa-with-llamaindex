{"docstore/data": {"5d46a18c-b385-4e67-9f03-3e5797bd594a": {"__data__": {"id_": "5d46a18c-b385-4e67-9f03-3e5797bd594a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "hash": "2296a69f803b018e897ded970ffc7995d37c122b4e9be3e99095409e8b8c7b3d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b32e6856-05db-4026-bd96-ec87f32edf9d", "node_type": "1", "metadata": {}, "hash": "05989b5641f39f5034804064ff562f79b1a7112be0def17d09a1557384617ada", "class_name": "RelatedNodeInfo"}}, "hash": "578672be47f8d15ab5fc0b54a7bb45dbe2f3e6201f9f60809cb0b08b732e725c", "text": "];\n\nYou should recognise some similarities between this code and the default replit.nix. We're still defining an anonymous function that takes pkgs, but now we're installing more than one package.\n\nAll of the packages in deps are straight from Nix's package repository, except for nginxModified. We need to make some modifications to nginx to get it to run in our repl. Nix's language and system configuration abilities make this much simpler to do than if we were using a different package manager that didn't support recompiling packages.\n\nNix's let ... in { ... } control structure is used when we want to define local variables used in a given function. We define the variables after let and then use them after in. Let's take a closer look at the definition of nginxModified:\n\nnginxModified = pkgs.nginx.overrideAttrs (oldAttrs: rec {\n\nconfigureFlags = oldAttrs.configureFlags ++ [\n\n\"--http-client-body-temp-path=/home/runner/REPL-NAME-HERE/cache/client_body\"\n\n\"--http-proxy-temp-path=/home/runner/REPL-NAME-HERE/cache/proxy\"\n\n\"--http-fastcgi-temp-path=/home/runner/REPL-NAME-HERE/cache/fastcgi\"\n\n\"--http-uwsgi-temp-path=/home/runner/REPL-NAME-HERE/cache/uwsgi\"\n\n\"--http-scgi-temp-path=/home/runner/REPL-NAME-HERE/cache/scgi\"\n\n];\n\n});\n\nHere we're taking pkgs.nginx and calling overrideAttrs to change the configuration flags that are set when compiling NGINX. We need to add a few flags that change the paths NGINX uses to paths that are accessible in our repl. Note that we've created all the directories in the expected locations.\n\nThe derivation that runs when we install pkgs.nginx can be found here. Our version will do the same things, but with a few extra items in configureFlags.\n\nThat's it for replit.nix. Now let's take a look at .replit. This file defines what command will get executed when we click the \"Run\" button, and what custom environment variables will be available to our repl.\n\nrun\n\n\"sh start.sh\"\n\nenv\n\nPGDATA\n\n\"/home/runner/\n\n${REPL_SLUG}\n\n/data\"\n\nWe'll execute the shell script start.sh when we press \"Run\", and we have defined PGDATA, an environment variable Postgres uses to locate its data directory. Let's look at start.sh next:\n\n# start Postgres\n\npg_ctl stop\n\ninitdb\n\ncp postgresql.conf.tpl data/postgresql.conf\n\nsocker_dir=\"\\/home\\/runner\\/${REPL_SLUG}\\/postgres\"\n\nsed -i \"s/replace_unix_dir/${socker_dir}/\" data/postgresql.conf\n\npg_ctl -l /home/runner/${REPL_SLUG}/postgresql.log start\n\ncreatedb -h 127.0.0.1\n\npsql -h 127.0.0.1 -c \"create database appdb;\"\n\n# start nginx\n\npkill nginx\n\nnginx -e /home/runner/$REPL_SLUG/logs/error.log -c /home/runner/$REPL_SLUG/nginx.conf\n\n# start Flask app\n\npython main.py\n\nIn order, we start Postgres, then NGINX, and then our Python Flask application.\n\nOur Postgres code first stops any existing instances of Postgres, then calls initdb, which will create a new database at the directory specified in $PGDATA if none exists. We then copy our Postgres configuration file into our data directory and use sed to fill in its unix_socket_directories value, another directory we need to change to get things working in a repl.\n\nThe file postgressql.conf.tpl is long and mostly unimportant. The only part of that file that will be relevant for basic use is the following lines under the heading \"Connection Settings\":\n\n# - Connection Settings -\n\nlisten_addresses = '127.0.0.1'      # what IP address(es) to listen on;\n\n# comma-separated list of addresses;\n\n# defaults to 'localhost'; use '*' for all\n\n# (change requires restart)\n\nport = 5432             # (change requires restart)\n\nThese lines set the database to listen on the local loopback on TCP port 5432. This will allow other programs in our repl to connect to it over the network, without having it exposed to the internet or other repls.", "start_char_idx": 0, "end_char_idx": 3761, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b32e6856-05db-4026-bd96-ec87f32edf9d": {"__data__": {"id_": "b32e6856-05db-4026-bd96-ec87f32edf9d", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "hash": "2296a69f803b018e897ded970ffc7995d37c122b4e9be3e99095409e8b8c7b3d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5d46a18c-b385-4e67-9f03-3e5797bd594a", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "hash": "578672be47f8d15ab5fc0b54a7bb45dbe2f3e6201f9f60809cb0b08b732e725c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ef1b2ffa-d964-422a-a8ef-ba828e1ed3c3", "node_type": "1", "metadata": {}, "hash": "65a9831c35b3fac545527776b568f0baa16d0795f7989321a83eeb829eeae37e", "class_name": "RelatedNodeInfo"}}, "hash": "05989b5641f39f5034804064ff562f79b1a7112be0def17d09a1557384617ada", "text": "We then copy our Postgres configuration file into our data directory and use sed to fill in its unix_socket_directories value, another directory we need to change to get things working in a repl.\n\nThe file postgressql.conf.tpl is long and mostly unimportant. The only part of that file that will be relevant for basic use is the following lines under the heading \"Connection Settings\":\n\n# - Connection Settings -\n\nlisten_addresses = '127.0.0.1'      # what IP address(es) to listen on;\n\n# comma-separated list of addresses;\n\n# defaults to 'localhost'; use '*' for all\n\n# (change requires restart)\n\nport = 5432             # (change requires restart)\n\nThese lines set the database to listen on the local loopback on TCP port 5432. This will allow other programs in our repl to connect to it over the network, without having it exposed to the internet or other repls. This is relevant for the next few lines of our script:\n\npg_ctl -l /home/runner/${REPL_SLUG}/postgresql.log start\n\ncreatedb -h 127.0.0.1\n\npsql -h 127.0.0.1 -c \"create database appdb;\"\n\nThe first line starts our database, and the last two create a Postgres instance usable by runner and within that, a database named appdb. Both of these lines will fail on subsequent runs of start.sh (if the database has already been created), so we don't need to worry about overwriting our database every time we run our repl.\n\nThe code for starting NGINX is simpler:\n\n# start nginx\n\npkill nginx\n\nnginx -e /home/runner/$REPL_SLUG/logs/error.log -c /home/runner/$REPL_SLUG/nginx.conf\n\nFirst, we kill any existing nginx processes, and then we start NGINX, telling it to write errors to logs/error.log and use the configuration file nginx.conf. Like postgresql.conf, this configuration file is mostly unimportant for basic use. The following changes have been made from Nix's default NGINX configuration file:\n\nThe option pid specifies a repl-accessible PID file location:pid        /home/runner/REPL-NAME-HERE/logs/nginx.pid;\n\nThe option access_log in the http block specifies a repl-accessible access log file location:access_log  /home/runner/REPL-NAME-HERE/logs/access.log;\n\nThe server block has been changed to host our Python server, as detailed below.    server {        listen       8080;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            proxy_pass   http://127.0.0.1:8181;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }\n\nIn NGINX, server blocks are what you use to set up websites on individual domains. Each domain (e.g. example.com) or subdomain (e.g. blog.example.com) will have its own server block. To create a server block that will define what our repl hosts, we use the following NGINX directives:\n\nlisten  8080;\n\nserver_name  localhost;\n\nReplit's hosting guidelines. Within our\n\nNGINX Beginner's Guide.\n\nThe last thing we do in start.sh is start up our Python Flask server:\n\n# start Flask app\n\npython main.py\n\nThe code for main.py should look familiar if you've used Flask before:\n\nfrom\n\nflask\n\nimport\n\nFlask\n\nfrom\n\nwaitress\n\nimport\n\nserve\n\nimport\n\npsycopg2\n\napp\n\nFlask\n\n__name__\n\n@app\n\nroute\n\n\"/\"\n\ndef\n\nindex\n\nconnection\n\npsycopg2\n\nconnect\n\nhost\n\n\"127.0.0.1\"\n\ndatabase\n\n\"appdb\"\n\ncursor\n\nconnection\n\ncursor\n\ncursor\n\nexecute\n\n'SELECT version()'\n\ndb_version\n\ncursor\n\nfetchone\n\ncursor\n\nclose\n\nreturn\n\nf\"Hello from Python! PostgreSQL database version:\n\ndb_version\n\n#app.run(host='127.0.0.1', port=8181) # dev server\n\nserve\n\napp\n\nhost\n\n'127.0.0.1'\n\nport\n\n8181\n\nurl_scheme\n\n'https'\n\n# production server\n\nIn this code, we've created a Flask application that connects to our Postgres database and is served on the local loopback address at TCP port 8181 by the Waitress WSGI server.", "start_char_idx": 2896, "end_char_idx": 6822, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ef1b2ffa-d964-422a-a8ef-ba828e1ed3c3": {"__data__": {"id_": "ef1b2ffa-d964-422a-a8ef-ba828e1ed3c3", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "hash": "2296a69f803b018e897ded970ffc7995d37c122b4e9be3e99095409e8b8c7b3d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b32e6856-05db-4026-bd96-ec87f32edf9d", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "hash": "05989b5641f39f5034804064ff562f79b1a7112be0def17d09a1557384617ada", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fba2709a-24ae-4846-a5db-d0eef47c3242", "node_type": "1", "metadata": {}, "hash": "fd4bdfb4e0d8dbd45c0c235b9210aa2065a310a6e60a44fdf602147cfe9ffeac", "class_name": "RelatedNodeInfo"}}, "hash": "65a9831c35b3fac545527776b568f0baa16d0795f7989321a83eeb829eeae37e", "text": "PostgreSQL database version:\n\ndb_version\n\n#app.run(host='127.0.0.1', port=8181) # dev server\n\nserve\n\napp\n\nhost\n\n'127.0.0.1'\n\nport\n\n8181\n\nurl_scheme\n\n'https'\n\n# production server\n\nIn this code, we've created a Flask application that connects to our Postgres database and is served on the local loopback address at TCP port 8181 by the Waitress WSGI server.\n\nIf you run the repl now, you'll see a page showing version information about our PostgreSQL database.\n\nFrom this base, you can build and configure a production-ready web application. Try the following ideas:\n\nImplement the code from one of our previous Flask-based tutorials, such as this PDF report generator. See if you can adapt the content to use Postgres rather than the Replit Database.\n\nImplement your own Flask web application, using Postgres as a database.\n\nAdd a second application listening on a different loopback port and available from a different URL. This could be your own Python or Node.js project, or a deployment of open-source software such as Ghost or Wordpress.\n\nA few other things you can do with Nix and Replit\u200b\n\nWe started with a complex example to give you an idea of the power and potential of Nix, but there are a few other things you can do with it that don't require the same amount of set up.\n\nJupyter Notebook\u200b\n\nJupyter Notebook in a Nix repl. Add\n\nmkdir data\n\njupyter notebook --ip 0.0.0.0 --port 8080 --notebook-dir /home/runner/$REPL_SLUG/data\n\nNotebooks are web-based interactive development environments that allow you to mix runnable code, text notes, mathematical equations, and charts and graphs. They're often used by data scientists.\n\nhttps://replit.com/@ritza/nix-jupyter\n\nVSCode Server\u200b\n\nYou can run a Visual Studio Code Server, which will allow you to use a personal, customised version of the popular text editor from anywhere, simply by navigating to your repl's URL.\n\nhttps://replit.com/@ritza/nix-vscode-server\n\nAlternative web stacks\u200b\n\nInstead of NGINX, you could use Apache, and instead of Postgres, you could try MySQL or even a NoSQL database like MongoDB. And of course, you can use just about any mainstream programming language to write your web application code instead of Python, such as JavaScript, Ruby or Java.\n\nOther programming languages\u200b\n\nRacket (\n\nProlog (\n\nCOBOL (\n\nhttps://replit.com/@ritza/nix-cobol\n\nDOSBox\u200b\n\nWe can get the popular MS-DOS emulator DOSBox working in a Nix repl by just installing the right package and running it. From there, we can run any DOS program and use it in our repl's VNC window.\n\nhttps://replit.com/@ritza/nix-dosbox\n\nHere's DOOM in a repl:\n\nOther DOS programs you can try:\n\nLiero, a keyboard-sharing worm fighting game.\n\nWordStar 4.0, the word processor George RR Martin uses to write the Game of Thrones book series.\n\nGeneral tips for building with Nix repls\u200b\n\nAs we've seen above, Nix allows us to use repls for more than just writing and testing code, but some packages require a fair amount of configuration to get working. Here are a few general tips for getting packages working in Nix repls:\n\nFirst, search for the package you want on the Nix package search website and add it to deps in replit.nix. If you don't see any errors in the console after running your repl, it probably worked. Some packages need to be manually started by specifying a run command in .replit, while others will start automatically.\n\nMost of the installation errors you'll encounter will relate to file paths that don't exist in your repl, or that you don't have permission to access. These can generally be fixed if you can configure your package to look for those files in your repl's file list instead, which is hosted on disk at /home/runner/REPL-NAME-HERE/. Depending on the package, you may be able to do this with a custom configuration file, like we did with Postgres, or you may need to alter the way Nix installs it, as we did with NGINX.\n\nYou can view files and directories that aren't visible in your repl's filepane from the shell, using standard Unix commands like ls, cd and cat. This includes files and directories in the Nix store, at /nix/store. This will often be useful for debugging.", "start_char_idx": 6467, "end_char_idx": 10609, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fba2709a-24ae-4846-a5db-d0eef47c3242": {"__data__": {"id_": "fba2709a-24ae-4846-a5db-d0eef47c3242", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "hash": "2296a69f803b018e897ded970ffc7995d37c122b4e9be3e99095409e8b8c7b3d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ef1b2ffa-d964-422a-a8ef-ba828e1ed3c3", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}, "hash": "65a9831c35b3fac545527776b568f0baa16d0795f7989321a83eeb829eeae37e", "class_name": "RelatedNodeInfo"}}, "hash": "fd4bdfb4e0d8dbd45c0c235b9210aa2065a310a6e60a44fdf602147cfe9ffeac", "text": "Most of the installation errors you'll encounter will relate to file paths that don't exist in your repl, or that you don't have permission to access. These can generally be fixed if you can configure your package to look for those files in your repl's file list instead, which is hosted on disk at /home/runner/REPL-NAME-HERE/. Depending on the package, you may be able to do this with a custom configuration file, like we did with Postgres, or you may need to alter the way Nix installs it, as we did with NGINX.\n\nYou can view files and directories that aren't visible in your repl's filepane from the shell, using standard Unix commands like ls, cd and cat. This includes files and directories in the Nix store, at /nix/store. This will often be useful for debugging.\n\nYou can view a list of running processes with the shell command ps aux, and terminate them with pkill <process-name>.\n\nLoading the Nix environment will sometimes take a long time, especially if you have custom derivations.\n\nIf you're setting up a web server, refer to our guidance on deploying HTTP servers.\n\nAs a final reminder, make sure to abide by Replit's Terms of Service when using Nix repls, and avoid installing packages that use excessive system resources (such as cryptocurrency miners) or are intentionally malicious.\n\n< Previous: Snake game with PyGame\n\nNext: Juggling with PyGame >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nWhat is Nix?\n\nHow can we use Nix on Replit?\n\nDeploying a production web stack on Replit with NixWhy Waitress?Why NGINX?Why Postgres?Repl overview\n\nA few other things you can do with Nix and ReplitJupyter NotebookVSCode ServerAlternative web stacksOther programming languagesDOSBox\n\nGeneral tips for building with Nix repls", "start_char_idx": 9839, "end_char_idx": 11579, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"2ed6257b-256f-4520-8a9d-6d5b76de21fa": {"node_ids": ["5d46a18c-b385-4e67-9f03-3e5797bd594a", "b32e6856-05db-4026-bd96-ec87f32edf9d", "ef1b2ffa-d964-422a-a8ef-ba828e1ed3c3", "fba2709a-24ae-4846-a5db-d0eef47c3242"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-with-nix.html"}}}, "docstore/metadata": {"5d46a18c-b385-4e67-9f03-3e5797bd594a": {"doc_hash": "578672be47f8d15ab5fc0b54a7bb45dbe2f3e6201f9f60809cb0b08b732e725c", "ref_doc_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa"}, "b32e6856-05db-4026-bd96-ec87f32edf9d": {"doc_hash": "05989b5641f39f5034804064ff562f79b1a7112be0def17d09a1557384617ada", "ref_doc_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa"}, "ef1b2ffa-d964-422a-a8ef-ba828e1ed3c3": {"doc_hash": "65a9831c35b3fac545527776b568f0baa16d0795f7989321a83eeb829eeae37e", "ref_doc_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa"}, "fba2709a-24ae-4846-a5db-d0eef47c3242": {"doc_hash": "fd4bdfb4e0d8dbd45c0c235b9210aa2065a310a6e60a44fdf602147cfe9ffeac", "ref_doc_id": "2ed6257b-256f-4520-8a9d-6d5b76de21fa"}}}