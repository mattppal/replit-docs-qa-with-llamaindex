{"docstore/data": {"cf364ac7-3257-4d26-9dce-6d970bb65d89": {"__data__": {"id_": "cf364ac7-3257-4d26-9dce-6d970bb65d89", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "33c5e991eaacbe405811a85ddf93637292a04f722944b3f76cd060ee0cc34822", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55f1392b-31db-4f60-bdc8-58ad07f6379f", "node_type": "1", "metadata": {}, "hash": "e77f7ad0b915ad07f9053f0a1be868539fcc95a89f7f6cb04bd418e8c1fb83c1", "class_name": "RelatedNodeInfo"}}, "hash": "d88fa54110da47a17b81d56fc514add854ce4c81ff6c42fc6cc537f664baf14e", "text": "Suits\n\nEnum\n\nCLUB\n\nSPADE\n\nHEART\n\nDIAMOND\n\nAlright, the boilerplate is out of the way. Now, lets define the Card class.\n\nclass\n\nCard\n\nsuit\n\nNone\n\nvalue\n\nNone\n\nimage\n\nNone\n\ndef\n\n__init__\n\nself\n\nsuit\n\nvalue\n\nself\n\nsuit\n\nsuit\n\nself\n\nvalue\n\nvalue\n\nself\n\nimage\n\npygame\n\nimage\n\nload\n\n'images/'\n\nself\n\nsuit\n\nname\n\n'-'\n\nstr\n\nself\n\nvalue\n\n'.svg'\n\nFrom this small class, we can see the various parts of a Python class. The first line is the class definition. The next 3 lines are the class properties (variables that are controlled by objects made from the class). Then we have the __init__ method, which is called the constructor method. This is where we initialize the class. In this case, we'll initialize the suit and value properties for the card. We'll also load the image for the card using Pygame's image.load function, with the filepath constructed from the suit and value. This implies that all the card images are all actually named according to the suit and value.\n\nNow that we have suits and cards, let's create a Deck of cards.\n\nclass\n\nDeck\n\ncards\n\nNone\n\ndef\n\n__init__\n\nself\n\nself\n\ncards\n\nfor\n\nsuit\n\nin\n\nSuits\n\nfor\n\nvalue\n\nin\n\nrange\n\n14\n\nself\n\ncards\n\nappend\n\nCard\n\nsuit\n\nvalue\n\ndef\n\nshuffle\n\nself\n\nrandom\n\nshuffle\n\nself\n\ncards\n\ndef\n\ndeal\n\nself\n\nreturn\n\nself\n\ncards\n\npop\n\ndef\n\nlength\n\nself\n\nreturn\n\nlen\n\nself\n\ncards\n\nThe Deck class is a collection of cards. It has a list of cards, and a few methods to manipulate the list.\n\nThe constructor, __init__ initializes the cards list, and populates it with all the cards in a deck, using 2 for loops. The first loop iterates over the Suits enum, and the second loop iterates over the values 1 through 13, which is all the cards in a deck.\n\nEvery deck of cards needs to be shuffled before it is used, so we've defined a shuffle method. Python's random module has a very handy shuffle function built in that we can use. shuffle takes a list and rearranges the contents of that list in place (i.e. it doesn't return a new list).\n\nThen we have the deal method, which removes the last card from the list and returns it. We'll use this to deal the cards to the players.\n\nWe have a length method that we'll use to determine if there are any cards left in the deck. This will be useful when dealing out cards to know when to stop.\n\nThe Deck class is now complete.\n\nLet's move to the Pile class. This class models the pile of cards face up on the table, that each player adds to when playing.\n\nclass\n\nPile\n\ncards\n\nNone\n\ndef\n\n__init__\n\nself\n\nself\n\ncards\n\ndef\n\nadd\n\nself\n\ncard\n\nself\n\ncards\n\nappend\n\ncard\n\ndef\n\npeek\n\nself\n\nif\n\nlen\n\nself\n\ncards\n\nreturn\n\nself\n\ncards\n\nelse\n\nreturn\n\nNone\n\ndef\n\npopAll\n\nself\n\nreturn\n\nself\n\ncards\n\ndef\n\nclear\n\nself\n\nself\n\ncards\n\ndef\n\nisSnap\n\nself\n\nif\n\nlen\n\nself\n\ncards\n\nreturn\n\nself\n\ncards\n\nvalue\n\n==\n\nself\n\ncards\n\nvalue\n\nreturn\n\nFalse\n\nThe Pile class has one main property: a list of cards, which is initialized in the constructor.\n\nThe add method is used when a player plays a card, i.e. adds it to the pile.\n\nThe peek method returns the top card of the pile, while still keeping it on the pile. We'll use this to draw the top card, as it is face up. If there are no cards on the pile, indicated by the length of the card array being 0, we'll return None.\n\nWhen a player wins, they get all the cards on the pile. The popAll method handles this by returning the list of cards. Then we can call the clear method to remove all the cards from the pile.\n\nIf a player calls \"Snap!\", we need to check if the top two cards are the same value. We'll use the isSnap method to check this. Python has a handy feature of negative indices. This means an index of -1 returns the last element in the list, -2 returns the second last, and so on. This allows us to easily get the last 2 cards added to the pile, and check if they are the same value.", "start_char_idx": 0, "end_char_idx": 3795, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55f1392b-31db-4f60-bdc8-58ad07f6379f": {"__data__": {"id_": "55f1392b-31db-4f60-bdc8-58ad07f6379f", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "33c5e991eaacbe405811a85ddf93637292a04f722944b3f76cd060ee0cc34822", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cf364ac7-3257-4d26-9dce-6d970bb65d89", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "d88fa54110da47a17b81d56fc514add854ce4c81ff6c42fc6cc537f664baf14e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "87128b1f-a7e9-48e0-874c-1701a3bf3d7c", "node_type": "1", "metadata": {}, "hash": "80d6db490183b83e4b7229d26bad665fb776c895c0dc45905766fccf2efcd326", "class_name": "RelatedNodeInfo"}}, "hash": "e77f7ad0b915ad07f9053f0a1be868539fcc95a89f7f6cb04bd418e8c1fb83c1", "text": "We'll use this to draw the top card, as it is face up. If there are no cards on the pile, indicated by the length of the card array being 0, we'll return None.\n\nWhen a player wins, they get all the cards on the pile. The popAll method handles this by returning the list of cards. Then we can call the clear method to remove all the cards from the pile.\n\nIf a player calls \"Snap!\", we need to check if the top two cards are the same value. We'll use the isSnap method to check this. Python has a handy feature of negative indices. This means an index of -1 returns the last element in the list, -2 returns the second last, and so on. This allows us to easily get the last 2 cards added to the pile, and check if they are the same value. Note that in the rules of Snap, only the value is important - the suit is not used.\n\nThe last of the models is the Player class.\n\nclass\n\nPlayer\n\nhand\n\nNone\n\nflipKey\n\nNone\n\nsnapKey\n\nNone\n\nname\n\nNone\n\ndef\n\n__init__\n\nself\n\nname\n\nflipKey\n\nsnapKey\n\nself\n\nhand\n\nself\n\nflipKey\n\nflipKey\n\nself\n\nsnapKey\n\nsnapKey\n\nself\n\nname\n\nname\n\ndef\n\ndraw\n\nself\n\ndeck\n\nself\n\nhand\n\nappend\n\ndeck\n\ndeal\n\ndef\n\nplay\n\nself\n\nreturn\n\nself\n\nhand\n\npop\n\nThe Player class has a few properties. The hand property is a list of cards that the player has.\n\nThe flipKey and snapKey properties are the keys assigned to player that they use to flip and snap cards.\n\nThe name property is the name of the player.\n\nThe play method pops a card off the hand list, used when the player plays a card.\n\nBuilding the game engine\u200b\n\nOk, time to build the game engine that will coordinate the interactions between the models we created.\n\nMake a new file called engine.py. Let's start by adding the libraries we'll need.\n\nfrom\n\nenum\n\nimport\n\nEnum\n\nimport\n\npygame\n\nfrom\n\nmodels\n\nimport\n\nBesides the Enum and pygame libraries, we import everything, *, from our models.py file. This way we can use all the classes that we defined in models.\n\nA common element in game engines is keeping track of the state of the game. We'll define a GameState enumeration to keep track of the state of the game.\n\nclass\n\nGameState\n\nEnum\n\nPLAYING\n\nSNAPPING\n\nENDED\n\nWe only have 3 states, or phases, of the game that we will track. The first is PLAYING, which is the main phase of the game, where the players take turns putting down cards. The second is SNAPPING. This is the state the game is in when a player calls \"Snap!\". In this state, we check if the snap is valid, and also wait until the players are ready to resume playing. The third is ENDED, which is the phase where the game is over, i.e. one player has no more cards to play.\n\nNow, let's start with the engine itself. First, let's add the definition, properties and constructor:\n\nclass\n\nSnapEngine\n\ndeck\n\nNone\n\nplayer1\n\nNone\n\nplayer2\n\nNone\n\npile\n\nNone\n\nstate\n\nNone\n\ncurrentPlayer\n\nNone\n\nresult\n\nNone\n\ndef\n\n__init__\n\nself\n\nself\n\ndeck\n\nDeck\n\nself\n\ndeck\n\nshuffle\n\nself\n\nplayer1\n\nPlayer\n\n\"Player 1\"\n\npygame\n\nK_q\n\npygame\n\nK_w\n\nself\n\nplayer2\n\nPlayer\n\n\"Player 2\"\n\npygame\n\nK_o\n\npygame\n\nK_p\n\nself\n\npile\n\nPile\n\nself\n\ndeal\n\nself\n\ncurrentPlayer\n\nself\n\nplayer1\n\nself\n\nstate\n\nGameState\n\nPLAYING\n\nThe constructor initializes objects and stores them in the properties. Note that we assign default names and keys to the players.\n\nWe also call a method we have yet to define, deal, to deal the cards to the players.\n\nWe start off the game by setting the state to PLAYING, and the currentPlayer to player1.\n\nLet's add some more methods and logic to the engine. To start, the deal method:\n\ndef\n\ndeal\n\nself\n\nhalf\n\nself\n\ndeck\n\nlength\n\n//\n\nfor\n\nin\n\nrange\n\nhalf\n\nself\n\nplayer1\n\ndraw\n\nself\n\ndeck\n\nself\n\nplayer2\n\ndraw\n\nself\n\ndeck\n\nThe deal method is in charge of making sure each player gets half the deck of cards. There are a few ways to do this - this code takes a bit of a literal translation of dealing, by dealing one card to each player alternately.", "start_char_idx": 3060, "end_char_idx": 6910, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87128b1f-a7e9-48e0-874c-1701a3bf3d7c": {"__data__": {"id_": "87128b1f-a7e9-48e0-874c-1701a3bf3d7c", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "33c5e991eaacbe405811a85ddf93637292a04f722944b3f76cd060ee0cc34822", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55f1392b-31db-4f60-bdc8-58ad07f6379f", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "e77f7ad0b915ad07f9053f0a1be868539fcc95a89f7f6cb04bd418e8c1fb83c1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ea298c00-e74a-4497-8208-bfef933e22b1", "node_type": "1", "metadata": {}, "hash": "b35097d1ca096193883c2d40880acb473a2b999fea4edc5e1461db7db5ee686e", "class_name": "RelatedNodeInfo"}}, "hash": "80d6db490183b83e4b7229d26bad665fb776c895c0dc45905766fccf2efcd326", "text": "Note that we assign default names and keys to the players.\n\nWe also call a method we have yet to define, deal, to deal the cards to the players.\n\nWe start off the game by setting the state to PLAYING, and the currentPlayer to player1.\n\nLet's add some more methods and logic to the engine. To start, the deal method:\n\ndef\n\ndeal\n\nself\n\nhalf\n\nself\n\ndeck\n\nlength\n\n//\n\nfor\n\nin\n\nrange\n\nhalf\n\nself\n\nplayer1\n\ndraw\n\nself\n\ndeck\n\nself\n\nplayer2\n\ndraw\n\nself\n\ndeck\n\nThe deal method is in charge of making sure each player gets half the deck of cards. There are a few ways to do this - this code takes a bit of a literal translation of dealing, by dealing one card to each player alternately. In practice, we'll use a for loop to do this, and in the loop we'll call the draw method on each of the players to draw a card.\n\nSince each round of the for loop takes a card for each player, 2 cards per loop, we only need to loop for half the number of cards in the deck.\n\nTo find the middle of the deck, we get the length of the deck, and divide it by 2. Note that we use the // integer division operator to get back an integer after division, as the meaning of the middle is the index of the middle card. A number with decimals wouldn't make any sense here.\n\nNext, we can add a helper method to switch the current player. We'll use this after each player plays a card to indicate that it's the next player's turn.\n\ndef\n\nswitchPlayer\n\nself\n\nif\n\nself\n\ncurrentPlayer\n\n==\n\nself\n\nplayer1\n\nself\n\ncurrentPlayer\n\nself\n\nplayer2\n\nelse\n\nself\n\ncurrentPlayer\n\nself\n\nplayer1\n\nHere we check which player is the current player and switch currentPlayer to the other player.\n\nThe last helper method we need on the engine is one that handles a player winning a round (by calling \"Snap!\" correctly, or the other player falsely calling \"Snap!\"). This method will change the state of the game. It will also add all the cards on the pile to the winner's hand. Then it will clear out the pile so the next round can start:\n\ndef\n\nwinRound\n\nself\n\nplayer\n\nself\n\nstate\n\nGameState\n\nSNAPPING\n\nplayer\n\nhand\n\nextend\n\nself\n\npile\n\npopAll\n\nself\n\npile\n\nclear\n\nNow we get to the main logic of the engine. This method will be called from our main game loop, which we will define later. Let's start with the method definition and some basic checks. Then we'll add the logic in sections. Start by adding this method to the engine:\n\ndef\n\nplay\n\nself\n\nkey\n\nif\n\nkey\n\n==\n\nNone\n\nreturn\n\nif\n\nself\n\nstate\n\n==\n\nGameState\n\nENDED\n\nreturn\n\nWe'll call this main logic method play. It takes whatever key is currently pressed, and processes the logic for that. The first thing we check is if a key has actually been pressed. If it hasn't, we return, as there is nothing to update with the game state.\n\nThe next check to make is if the game is over. If it is, we return, as again, there is nothing to do. If you want to improve the game, you could listen for a key press to restart the game.\n\nNow let's add some of the logic. The first thing is to check if the current player has pressed the key to play, or flip a card onto the pile. If they have pressed their flipKey, we call their play method and add the returned card to the pile. Then we switch turn to the next player, by calling our switchPlayer method.\n\nif\n\nkey\n\n==\n\nself\n\ncurrentPlayer\n\nflipKey\n\nself\n\npile\n\nadd\n\nself\n\ncurrentPlayer\n\nplay\n\nself\n\nswitchPlayer\n\nNext, let's check if any of the players have called \"Snap!\". We'll need to keep track of a few things: who called \"Snap!\", who didn't call \"Snap!\", and if there is a valid snap condition on the pile.", "start_char_idx": 6233, "end_char_idx": 9776, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ea298c00-e74a-4497-8208-bfef933e22b1": {"__data__": {"id_": "ea298c00-e74a-4497-8208-bfef933e22b1", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "33c5e991eaacbe405811a85ddf93637292a04f722944b3f76cd060ee0cc34822", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "87128b1f-a7e9-48e0-874c-1701a3bf3d7c", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "80d6db490183b83e4b7229d26bad665fb776c895c0dc45905766fccf2efcd326", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "79b4511e-8a0d-4b7c-b63d-3360f4730c63", "node_type": "1", "metadata": {}, "hash": "6752c999525d0e09bb730c825a93ac55d5d3e3f172c635c8807ed4e9d23cfec0", "class_name": "RelatedNodeInfo"}}, "hash": "b35097d1ca096193883c2d40880acb473a2b999fea4edc5e1461db7db5ee686e", "text": "If it is, we return, as again, there is nothing to do. If you want to improve the game, you could listen for a key press to restart the game.\n\nNow let's add some of the logic. The first thing is to check if the current player has pressed the key to play, or flip a card onto the pile. If they have pressed their flipKey, we call their play method and add the returned card to the pile. Then we switch turn to the next player, by calling our switchPlayer method.\n\nif\n\nkey\n\n==\n\nself\n\ncurrentPlayer\n\nflipKey\n\nself\n\npile\n\nadd\n\nself\n\ncurrentPlayer\n\nplay\n\nself\n\nswitchPlayer\n\nNext, let's check if any of the players have called \"Snap!\". We'll need to keep track of a few things: who called \"Snap!\", who didn't call \"Snap!\", and if there is a valid snap condition on the pile. Add this logic to the play method:\n\nsnapCaller\n\nNone\n\nnonSnapCaller\n\nNone\n\nisSnap\n\nself\n\npile\n\nisSnap\n\nif\n\nkey\n\n==\n\nself\n\nplayer1\n\nsnapKey\n\nsnapCaller\n\nself\n\nplayer1\n\nnonSnapCaller\n\nself\n\nplayer2\n\nelif\n\nkey\n\n==\n\nself\n\nplayer2\n\nsnapKey\n\nsnapCaller\n\nself\n\nplayer2\n\nnonSnapCaller\n\nself\n\nplayer1\n\nHere we create two variables, snapCaller and nonSnapCaller, which keep track of the player who called \"Snap!\" and the player who didn't call \"Snap!\". We also create a variable isSnap to keep track of whether there is a valid snap condition on the pile. Then we check if either of the players has called \"Snap!\". If they have, then we set the snapCaller and nonSnapCaller variables as applicable.\n\nWe now know if \"Snap!\" has been called and which player called it. Let's add the logic to see if the player that called \"Snap!\" wins or loses. Add this logic to the play method:\n\nif\n\nisSnap\n\nand\n\nsnapCaller\n\nself\n\nwinRound\n\nsnapCaller\n\nself\n\nresult\n\n\"winner\"\n\nsnapCaller\n\n\"isSnap\"\n\nTrue\n\n\"snapCaller\"\n\nsnapCaller\n\nself\n\nwinRound\n\nsnapCaller\n\nelif\n\nnot\n\nisSnap\n\nand\n\nsnapCaller\n\nself\n\nresult\n\n\"winner\"\n\nnonSnapCaller\n\n\"isSnap\"\n\nFalse\n\n\"snapCaller\"\n\nsnapCaller\n\nself\n\nwinRound\n\nnonSnapCaller\n\nWe have two cases: one for a valid snap, and one for an invalid snap.\n\nIf the pile is a valid snap, we call the winRound method on the player who called \"Snap!\". Then we set the result property to a dictionary with the winner, whether it was a valid snap, and the player who called \"Snap!\". This will be used for information when we make the game user interface (UI).\n\nLikewise, for an invalid snap, we call the winRound method on the player who didn't call \"Snap!\". Then we set the result property to a dictionary with the winner as the nonSnapCaller.\n\nIn both cases, we call the winRound method with whichever player won the cards. Recall in the winRound method we assign the pile to the player's hand. Then we clear the pile, and set the gameState to SNAPPING.\n\nWe've got just one last thing to check: if any player has run out of cards. If they have, then it means the other player wins. Add this logic to the play method:\n\nif\n\nlen\n\nself\n\nplayer1\n\nhand\n\n==\n\nself\n\nresult\n\n\"winner\"\n\nself\n\nplayer2\n\nself\n\nstate\n\nGameState\n\nENDED\n\nelif\n\nlen\n\nself\n\nplayer2\n\nhand\n\n==\n\nself\n\nresult\n\n\"winner\"\n\nself\n\nplayer1\n\nself\n\nstate\n\nGameState\n\nENDED\n\nIf one of the players has run out of cards, then we set the result property to a dictionary with the winner as the other player. Then we set the state property to GameState.ENDED.\n\nSetting up the game loop\u200b\n\nWe've built the model and the logic in the engine to play a game of Snap. Now we need to define the game loop to run the game.\n\nOpen up the main.py file again. We'll start by adding references to the models and engine, so that we can access them when building the UI. Add the following imports right under the import pygame line:\n\nfrom\n\nmodels\n\nimport\n\nfrom\n\nengine\n\nimport\n\nWe'll start by creating a new game engine object. Add this to the main.py file, underneath the Pygame initialization code:\n\ngameEngine\n\nSnapEngine\n\nNow the game loop.", "start_char_idx": 9007, "end_char_idx": 12845, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "79b4511e-8a0d-4b7c-b63d-3360f4730c63": {"__data__": {"id_": "79b4511e-8a0d-4b7c-b63d-3360f4730c63", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "33c5e991eaacbe405811a85ddf93637292a04f722944b3f76cd060ee0cc34822", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ea298c00-e74a-4497-8208-bfef933e22b1", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "b35097d1ca096193883c2d40880acb473a2b999fea4edc5e1461db7db5ee686e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "48c327cf-f496-4424-84d6-b5d321b1b400", "node_type": "1", "metadata": {}, "hash": "3adde05f31598fcf4f3e4b5048e7245c55bf3bce2ae00e7cb40161c8b948fbaf", "class_name": "RelatedNodeInfo"}}, "hash": "6752c999525d0e09bb730c825a93ac55d5d3e3f172c635c8807ed4e9d23cfec0", "text": "Then we set the state property to GameState.ENDED.\n\nSetting up the game loop\u200b\n\nWe've built the model and the logic in the engine to play a game of Snap. Now we need to define the game loop to run the game.\n\nOpen up the main.py file again. We'll start by adding references to the models and engine, so that we can access them when building the UI. Add the following imports right under the import pygame line:\n\nfrom\n\nmodels\n\nimport\n\nfrom\n\nengine\n\nimport\n\nWe'll start by creating a new game engine object. Add this to the main.py file, underneath the Pygame initialization code:\n\ngameEngine\n\nSnapEngine\n\nNow the game loop. The game loop's job is to listen for user input, call the engine's play method to process that input, and update the UI with the result. Add this to the main.py file:\n\nrun\n\nTrue\n\nwhile\n\nrun\n\nkey\n\nNone\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nQUIT\n\nrun\n\nFalse\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nKEYDOWN\n\nkey\n\nevent\n\nkey\n\ngameEngine\n\nplay\n\nkey\n\nrenderGame\n\nwindow\n\npygame\n\ndisplay\n\nupdate\n\nif\n\ngameEngine\n\nstate\n\n==\n\nGameState\n\nSNAPPING\n\npygame\n\ntime\n\ndelay\n\n3000\n\ngameEngine\n\nstate\n\nGameState\n\nPLAYING\n\nWe start off by defining a variable run. Then we use this as a condition for a while loop. As long as run is true, the loop will continuously run the code inside.\n\nIn Pygame, we listen for events on the event queue. We use the pygame.event.get() method to get all the events that have happened since the last time we checked. We then iterate through the events, checking if any of them is a QUIT event. If they are, we set run to false, and break out of the loop to end the program. A QUIT event is sent if the user clicks the close button on the window.\n\nIf any of the events is a KEYDOWN event, we set the key variable to the key that was pressed.\n\nThen we call out to the game engine to process the key that was pressed.\n\nOnce that is done, we can update the UI. We call the renderGame method, which we'll get to next.\n\nAfter the UI has been updated, we call the pygame.display.update() method to draw it to the screen.\n\nThe final check is to see if the game is in the SNAPPING state. If it is, we wait 3 seconds before switching back to the PLAYING state. This is so that there is enough time for the players to pause and see what happened. Remember the game loop will go around very quickly, so the delay will help them to see any messages we display in the renderGame method.\n\nRendering the game\u200b\n\nThe last main task is to render the game through a UI. This is where we'll use Pygame to draw the game to the screen.\n\nIn the game loop, we call the renderGame method. This method takes a window parameter, which is the Pygame window we created in the main.py file. The window is the graphics surface that we will draw to. The renderGame method will look at the state and result of the gameEngine, as well as the players, and draw the appropriate UI to the window.\n\nLet's implement that method now. We'll start by clearing the window, and drawing some fixed UI elements. Add the following code to the main.py file, above the game loop.\n\ncardBack\n\npygame\n\nimage\n\nload\n\n'images/BACK.png'\n\ncardBack\n\npygame\n\ntransform\n\nscale\n\ncardBack\n\nint\n\n238\n\n0.8\n\nint\n\n332\n\n0.8\n\ndef\n\nrenderGame\n\nwindow\n\nwindow\n\nfill\n\n15\n\n169\n\nfont\n\npygame\n\nfont\n\nSysFont\n\n'comicsans'\n\n60\n\nTrue\n\nwindow\n\nblit\n\ncardBack\n\n100\n\n200\n\nwindow\n\nblit\n\ncardBack\n\n700\n\n200\n\ntext\n\nfont\n\nrender\n\nstr\n\nlen\n\ngameEngine\n\nplayer1\n\nhand\n\n\" cards\"\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n100\n\n500\n\ntext\n\nfont\n\nrender\n\nstr\n\nlen\n\ngameEngine\n\nplayer2\n\nhand\n\n\" cards\"\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n700\n\n500\n\ntopCard\n\ngameEngine\n\npile\n\npeek\n\nif\n\ntopCard\n\n!=\n\nNone\n\nwindow\n\nblit\n\ntopCard\n\nimage\n\n400\n\n200\n\nFirstly we load an image of the back of a card outside the function.", "start_char_idx": 12225, "end_char_idx": 16002, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "48c327cf-f496-4424-84d6-b5d321b1b400": {"__data__": {"id_": "48c327cf-f496-4424-84d6-b5d321b1b400", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "33c5e991eaacbe405811a85ddf93637292a04f722944b3f76cd060ee0cc34822", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "79b4511e-8a0d-4b7c-b63d-3360f4730c63", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "6752c999525d0e09bb730c825a93ac55d5d3e3f172c635c8807ed4e9d23cfec0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "39c0eec1-27b6-40a3-9fb6-91fc33a4143f", "node_type": "1", "metadata": {}, "hash": "1df3c0c79480d40573eaa1930a4f255df7040af694bc616525e2cac11cda79fe", "class_name": "RelatedNodeInfo"}}, "hash": "3adde05f31598fcf4f3e4b5048e7245c55bf3bce2ae00e7cb40161c8b948fbaf", "text": "We do this to avoid loading it each time the screen is rendered - this way it is only loaded once. We will use this image to represent the cards in the players' hands, which are face down. pygame's transform.scale function is used to scale the image to 0.8 the size of the regular card size. This is just to indicate visually that they are in the background to the main part of the UI, which will be the card at top of the pile.\n\nInside the renderGame function, we first clear the window. We use the fill method to fill the window with a color, (15,0,169) in RGB (Red Green Blue) color notation, which is a dark blue color.\n\nThen we choose a font to use. We use the SysFont method to load a font from the system. We pass in the font name, the font size, and a boolean value indicating whether the font should be bold.\n\nNext is to draw the card backs representing the players' hands. We use the blit method to draw the card back to the window. We pass in the card back image we loaded outside the function, and the screen coordinates we want to draw it at. We draw two card backs, one for each player, one on the far left of the screen, and the other on the far right. We'll draw the pile between these two hands.\n\nTo indicate the current score of the game, we render text showing the number of cards each player currently holds. First, we construct a text object using the font's render method. We pass in the text we want to render (which is the player's card count and the word 'cards'), and the color we want to use. We then draw the text to the screen by blitting it to the window.\n\nThe last part of the code draws the card at the top of the pile. We use the peek method we implemented on the Pile class to get the top card. If there is no top card, we don't draw anything. Recall that for each card, we loaded its image in the constructor. This means we can get the image object from the image property on the card, without loading it here. Once again we blit the card image to the screen, this time passing in coordinates between the two hands.\n\nThe next part of the UI to draw is some indication of the current state of the game, and whose turn it is. We'll use the state property of the gameEngine to determine what to draw. We'll use if statements to draw the appropriate UI, based on the game state. There are three states to consider:\n\nPLAYING The game is in progress, and we are waiting for the current player to flip a card, or either player to call \"Snap!\". In this case, we render the current player's name and a message to indicate that it is their turn to flip. This message is written in white (255,255,255) near the top left of the window.\n\nSNAPPING A player has called snap. In this case, the message rendered depends on if the snap was valid or not. We can get this information from the result property of the gameEngine.\n\nENDING The game is over. In this case, we render the winner's name, and a message to indicate that they won.\n\nAdd this code to the renderGame function, to implement the above logic:\n\nif\n\ngameEngine\n\nstate\n\n==\n\nGameState\n\nPLAYING\n\ntext\n\nfont\n\nrender\n\ngameEngine\n\ncurrentPlayer\n\nname\n\n\" to flip\"\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n20\n\n50\n\nif\n\ngameEngine\n\nstate\n\n==\n\nGameState\n\nSNAPPING\n\nresult\n\ngameEngine\n\nresult\n\nif\n\nresult\n\n\"isSnap\"\n\n==\n\nTrue\n\nmessage\n\n\"Winning Snap! by \"\n\nresult\n\n\"winner\"\n\nname\n\nelse\n\nmessage\n\n\"False Snap! by \"\n\nresult\n\n\"snapCaller\"\n\nname\n\n\". \"\n\nresult\n\n\"winner\"\n\nname\n\n\" wins!\"\n\ntext\n\nfont\n\nrender\n\nmessage\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n20\n\n50\n\nif\n\ngameEngine\n\nstate\n\n==\n\nGameState\n\nENDED\n\nresult\n\ngameEngine\n\nresult\n\nmessage\n\n\"Game Over! \"\n\nresult\n\n\"winner\"\n\nname\n\n\" wins!\"\n\ntext\n\nfont\n\nrender\n\nmessage\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n20\n\n50\n\nRunning the game\u200b\n\nNow that we have implemented the game, we can give it a test run. Click the big green \"Run\" button at the top of your repl. You should see the game start up, prompting \"Player 1\" to flip a card.", "start_char_idx": 16003, "end_char_idx": 19955, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "39c0eec1-27b6-40a3-9fb6-91fc33a4143f": {"__data__": {"id_": "39c0eec1-27b6-40a3-9fb6-91fc33a4143f", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "33c5e991eaacbe405811a85ddf93637292a04f722944b3f76cd060ee0cc34822", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "48c327cf-f496-4424-84d6-b5d321b1b400", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}, "hash": "3adde05f31598fcf4f3e4b5048e7245c55bf3bce2ae00e7cb40161c8b948fbaf", "class_name": "RelatedNodeInfo"}}, "hash": "1df3c0c79480d40573eaa1930a4f255df7040af694bc616525e2cac11cda79fe", "text": "by \"\n\nresult\n\n\"winner\"\n\nname\n\nelse\n\nmessage\n\n\"False Snap! by \"\n\nresult\n\n\"snapCaller\"\n\nname\n\n\". \"\n\nresult\n\n\"winner\"\n\nname\n\n\" wins!\"\n\ntext\n\nfont\n\nrender\n\nmessage\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n20\n\n50\n\nif\n\ngameEngine\n\nstate\n\n==\n\nGameState\n\nENDED\n\nresult\n\ngameEngine\n\nresult\n\nmessage\n\n\"Game Over! \"\n\nresult\n\n\"winner\"\n\nname\n\n\" wins!\"\n\ntext\n\nfont\n\nrender\n\nmessage\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n20\n\n50\n\nRunning the game\u200b\n\nNow that we have implemented the game, we can give it a test run. Click the big green \"Run\" button at the top of your repl. You should see the game start up, prompting \"Player 1\" to flip a card.\n\nPlayer 1's keys are q to flip a card, and w to call snap.\nPlayer 2's keys are o to flip a card, and p to call snap.\n\nCall over a friend and see who's the quickest finger on calling \"Snap!\".\n\nNext steps\u200b\n\nCongratulations! You've implemented a card game. You can use the ideas and principles from this tutorial to implement a card game of your own.\n\nSome ideas to add features to this game are:\n\nAdd a timer to the game, so that the player has a limited amount of time to flip a card.\n\nAdd some sound effects, using the Pygame mixer module.\n\nAdd a key to restart the game after it ends. Currently, at the end of the game, the players would need to close the window and start the game to play again.\n\nTry with different cards. For example, you could use a simplified card set, perhaps themed on something you love, like Pokemons, dinosaurs, cars, celebrities, etc.\n\nYou can find our repl below:\n\n< Previous: Audio: create a media player\n\nNext: Email news digest app with Nix & Python >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nThe game rules\n\nCreating a new project\n\nGetting started with pygame\n\nDesigning the game model\n\nBuilding the game model\n\nBuilding the game engine\n\nSetting up the game loop\n\nRendering the game\n\nRunning the game\n\nNext steps", "start_char_idx": 19323, "end_char_idx": 21210, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"2385ad6c-7dcf-4e19-a288-7c8ab2efa495": {"node_ids": ["cf364ac7-3257-4d26-9dce-6d970bb65d89", "55f1392b-31db-4f60-bdc8-58ad07f6379f", "87128b1f-a7e9-48e0-874c-1701a3bf3d7c", "ea298c00-e74a-4497-8208-bfef933e22b1", "79b4511e-8a0d-4b7c-b63d-3360f4730c63", "48c327cf-f496-4424-84d6-b5d321b1b400", "39c0eec1-27b6-40a3-9fb6-91fc33a4143f"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-card-game-pygame.html"}}}, "docstore/metadata": {"cf364ac7-3257-4d26-9dce-6d970bb65d89": {"doc_hash": "d88fa54110da47a17b81d56fc514add854ce4c81ff6c42fc6cc537f664baf14e", "ref_doc_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495"}, "55f1392b-31db-4f60-bdc8-58ad07f6379f": {"doc_hash": "e77f7ad0b915ad07f9053f0a1be868539fcc95a89f7f6cb04bd418e8c1fb83c1", "ref_doc_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495"}, "87128b1f-a7e9-48e0-874c-1701a3bf3d7c": {"doc_hash": "80d6db490183b83e4b7229d26bad665fb776c895c0dc45905766fccf2efcd326", "ref_doc_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495"}, "ea298c00-e74a-4497-8208-bfef933e22b1": {"doc_hash": "b35097d1ca096193883c2d40880acb473a2b999fea4edc5e1461db7db5ee686e", "ref_doc_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495"}, "79b4511e-8a0d-4b7c-b63d-3360f4730c63": {"doc_hash": "6752c999525d0e09bb730c825a93ac55d5d3e3f172c635c8807ed4e9d23cfec0", "ref_doc_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495"}, "48c327cf-f496-4424-84d6-b5d321b1b400": {"doc_hash": "3adde05f31598fcf4f3e4b5048e7245c55bf3bce2ae00e7cb40161c8b948fbaf", "ref_doc_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495"}, "39c0eec1-27b6-40a3-9fb6-91fc33a4143f": {"doc_hash": "1df3c0c79480d40573eaa1930a4f255df7040af694bc616525e2cac11cda79fe", "ref_doc_id": "2385ad6c-7dcf-4e19-a288-7c8ab2efa495"}}}