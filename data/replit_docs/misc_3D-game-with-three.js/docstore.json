{"docstore/data": {"8ce63f44-3a98-43d6-904d-fb325161ee77": {"__data__": {"id_": "8ce63f44-3a98-43d6-904d-fb325161ee77", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "95577446-96d6-43d8-b59f-2344bea99cec", "node_type": "1", "metadata": {}, "hash": "297839c4913ad4eebe78299fb603fa3e54e58341a8c564f952c0c21f4459d700", "class_name": "RelatedNodeInfo"}}, "hash": "0f9eae325fdae356b948b243eddf955d3da4e4cb2af807ea3231da6ae8b677ed", "text": "innerWidth\n\nwindow\n\ninnerHeight\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\ndocument\n\nbody\n\nappendChild\n\nrenderer\n\ndomElement\n\nWebGL. WebGL (Web Graphics Library) is used for rendering complex graphics, such as 3D scenes, on the web. It does this by accessing the graphics card on the user's device. The\n\nNow let's create our first 3D object, the player box. This will be the box that we move around in the game. In three.js, we need three things to create an object:\n\nGeometry - An object contains the x, y, z points that make up a shape.\n\nMaterial - The surface of the geometry. Gives the geometry color and texture.\n\nMesh - Geometry + material. This is what we will add to our scene.\n\nAdd the following lines above the renderer declaration:\n\nconst\n\ngeometry\n\nnew\n\nTHREE\n\nBoxGeometry\n\nconst\n\nmaterial\n\nnew\n\nTHREE\n\nMeshBasicMaterial\n\ncolor\n\n0xe56956\n\nconst\n\nmesh\n\nnew\n\nTHREE\n\nMesh\n\ngeometry\n\nmaterial\n\nThe 0x in front of the color property value means that it is a hexadecimal value. Most materials require a light source to bounce off of them so that they can be seen. The MeshBasicMaterial does not.\n\nNow let's add the mesh to the scene:\n\nscene\n\nadd\n\nmesh\n\nRun the code now by pushing the \"Run\" button at the top of the Replit window. You should see your first scene, an orange cube:\n\nThe MeshBasicMaterial does not look 3D. It would be better to have a material that light can interact with so that we can get some depth to our player box. Replace your material with the following material:\n\nconst\n\nmaterial\n\nnew\n\nTHREE\n\nMeshLambertMaterial\n\ncolor\n\n0xe56956\n\nThe MeshLambertMaterial is a relatively simple material that can reflect light. Your player box will not be visible now, we need to add a light source. We will add an ambient light and a directional light.\n\nAdd the following lines to the script.js file, above the renderer:\n\nconst\n\nambientLight\n\nnew\n\nTHREE\n\nAmbientLight\n\n0xffffff\n\n0.6\n\nconst\n\ndirectionalLight\n\nnew\n\nTHREE\n\nDirectionalLight\n\n0xffffff\n\n0.6\n\ndirectionalLight\n\nposition\n\nset\n\n10\n\n20\n\nscene\n\nadd\n\nambientLight\n\ndirectionalLight\n\nWe add a white directional light that is set along the x-, y-, and z-axes so that it shines on the top and side of the box. The ambient light allows us to see the box better from all angles. The first parameter for the light constructor functions is the color, and the second parameter is the light intensity, which ranges from 0 to 1. You should be able to see your player box now. It will look more 3D, as each side has different lighting. You can use your browser dev tools to check the console logs if you encounter any errors.\n\nLet's also get rid of the window scrollbars. Add the following to the style.css file in the body selector:\n\noverflow\n\nhidden\n\nmargin\n\nYour player box should now look like this:\n\nTry changing the material color, light intensity, and camera position to see what happens.\n\nBefore we get our player box moving, let's change our code so that it is nicely structured for the game logic that we will add. Add the following lines to the top of the script.js file:\n\nlet\n\ncamera\n\nscene\n\nrenderer\n\nplayer\n\nconst\n\nboxSideLength\n\n0.5\n\ninit\n\nThe camera, scene, and renderer variables are global variables so that they are available throughout our script. They will be defined in functions we create. Remove the const keyword in front of their declarations that we already added.\n\nWe also initialize a player variable for our created box.\n\nThe boxSideLength variable is for the x, y and z lengths of our box. Most of our boxes will be squares.\n\nNow let's define the function called init. This function will be used to initialize the game, by rendering and setting up the scene and creating our objects.", "start_char_idx": 0, "end_char_idx": 3665, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "95577446-96d6-43d8-b59f-2344bea99cec": {"__data__": {"id_": "95577446-96d6-43d8-b59f-2344bea99cec", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8ce63f44-3a98-43d6-904d-fb325161ee77", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "0f9eae325fdae356b948b243eddf955d3da4e4cb2af807ea3231da6ae8b677ed", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25a21e21-67fd-439f-86f0-8bc0ebfc79ca", "node_type": "1", "metadata": {}, "hash": "0e17a6d4a2b8b8b97165fea5a047f6db3c0a1978a417cc4883040f3c36eb2119", "class_name": "RelatedNodeInfo"}}, "hash": "297839c4913ad4eebe78299fb603fa3e54e58341a8c564f952c0c21f4459d700", "text": "Before we get our player box moving, let's change our code so that it is nicely structured for the game logic that we will add. Add the following lines to the top of the script.js file:\n\nlet\n\ncamera\n\nscene\n\nrenderer\n\nplayer\n\nconst\n\nboxSideLength\n\n0.5\n\ninit\n\nThe camera, scene, and renderer variables are global variables so that they are available throughout our script. They will be defined in functions we create. Remove the const keyword in front of their declarations that we already added.\n\nWe also initialize a player variable for our created box.\n\nThe boxSideLength variable is for the x, y and z lengths of our box. Most of our boxes will be squares.\n\nNow let's define the function called init. This function will be used to initialize the game, by rendering and setting up the scene and creating our objects. Define an init function and move the camera, light, and renderer code into it:\n\nfunction\n\ninit\n\nscene\n\nnew\n\nTHREE\n\nScene\n\ncamera\n\nnew\n\nTHREE\n\nPerspectiveCamera\n\n70\n\nwindow\n\ninnerWidth\n\nwindow\n\ninnerHeight\n\n0.1\n\n200\n\ncamera\n\nposition\n\nset\n\ncamera\n\nlookAt\n\nconst\n\nambientLight\n\nnew\n\nTHREE\n\nAmbientLight\n\n0xffffff\n\n0.6\n\nconst\n\ndirectionalLight\n\nnew\n\nTHREE\n\nDirectionalLight\n\n0xffffff\n\n0.6\n\ndirectionalLight\n\nposition\n\nset\n\n10\n\n20\n\nscene\n\nadd\n\nambientLight\n\ndirectionalLight\n\ninitializeBoxes\n\nrenderer\n\nnew\n\nTHREE\n\nWebGLRenderer\n\nantialias\n\ntrue\n\nrenderer\n\nsetSize\n\nwindow\n\ninnerWidth\n\nwindow\n\ninnerHeight\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\ndocument\n\nbody\n\nappendChild\n\nrenderer\n\ndomElement\n\nWe also call the initializeBoxes function, which we will soon define.\n\nNow let's make a createBox function. We will use this function to create our player box, and later to create obstacles. Define the createBox function and move the code for creating your player box inside of it:\n\nfunction\n\ncreateBox\n\nconst\n\ngeometry\n\nnew\n\nTHREE\n\nBoxGeometry\n\nboxSideLength\n\nboxSideLength\n\nboxSideLength\n\nconst\n\nmaterial\n\nnew\n\nTHREE\n\nMeshLambertMaterial\n\ncolor\n\n0xe56956\n\nconst\n\nmesh\n\nnew\n\nTHREE\n\nMesh\n\ngeometry\n\nmaterial\n\nmesh\n\nposition\n\nset\n\nscene\n\nadd\n\nmesh\n\nThe geometry definition now uses the boxSideLength variable to set the lengths of the sides. There is one extra line of code here, the call to the mesh.position.set function. This will set the position of the created box in the 3D world based on the arguments passed to the function. This will be useful when we create randomly positioned obstacles.\n\nNow let's create an initializeBoxes function that will be used to create all of the boxes at the start of the game. Add the following lines of code:\n\nfunction\n\ninitializeBoxes\n\nplayer\n\ncreateBox\n\nAll this function currently does is create a player box that is positioned in the center of our 3D world. Its x, y, and z positions will be 0. If you run your repl code, you should still be able to see your box.\n\nAnimating the player box\u200b\n\nIn the final game, the player box moves continuously along the z-axis. We will make use of an animation loop to continuously move the player box and re-render the scene to see the movement. At the bottom of the script.js file, add the following lines:\n\nfunction\n\nanimate\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\ncamera\n\nposition\n\n+=\n\nspeed\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\nrequestAnimationFrame\n\nanimate\n\nThe animate function will be called on every frame by using the requestAnimationFrame function, which is a web API that is used to create animations. It will call the animate function before each repaint of the screen by the browser. The number of function calls is usually 60 per second.\n\nFor each animate function call, we move the player box and the camera by changing their position along the z-axis. The camera will follow the player box. Let's add a global speed variable at the top of our script.js file so that we can easily change it later if we want to:\n\nlet\n\nspeed\n\n0.1\n\nTo access the player box's mesh property, let's return the mesh property from the createBox function. Add the following to the end of the createBox function:\n\nreturn\n\nmesh\n\nWe also need to call our animate function initially to get it started. In the init function, add the following line below renderer.render(scene, camera):\n\nanimate\n\nOur player box will now be moving, but we won't be able to see the movement.", "start_char_idx": 2848, "end_char_idx": 7084, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "25a21e21-67fd-439f-86f0-8bc0ebfc79ca": {"__data__": {"id_": "25a21e21-67fd-439f-86f0-8bc0ebfc79ca", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "95577446-96d6-43d8-b59f-2344bea99cec", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "297839c4913ad4eebe78299fb603fa3e54e58341a8c564f952c0c21f4459d700", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "61f17d33-a9bb-4423-a4ec-ebf19272d33d", "node_type": "1", "metadata": {}, "hash": "124cedd12485922571773f743333561c343eb149c88d56275c108200791d9cf7", "class_name": "RelatedNodeInfo"}}, "hash": "0e17a6d4a2b8b8b97165fea5a047f6db3c0a1978a417cc4883040f3c36eb2119", "text": "It will call the animate function before each repaint of the screen by the browser. The number of function calls is usually 60 per second.\n\nFor each animate function call, we move the player box and the camera by changing their position along the z-axis. The camera will follow the player box. Let's add a global speed variable at the top of our script.js file so that we can easily change it later if we want to:\n\nlet\n\nspeed\n\n0.1\n\nTo access the player box's mesh property, let's return the mesh property from the createBox function. Add the following to the end of the createBox function:\n\nreturn\n\nmesh\n\nWe also need to call our animate function initially to get it started. In the init function, add the following line below renderer.render(scene, camera):\n\nanimate\n\nOur player box will now be moving, but we won't be able to see the movement. We are going to add a GridHelper so that we can see the movement. A GridHelper is an object that defines a grid, which is a two-dimensional array of lines along the x- and y-axes. This will give our 3D world a 2D grid surface. In the init function, add the following lines below initializeBoxes():\n\nconst\n\ngridHelper\n\nnew\n\nTHREE\n\nGridHelper\n\n200\n\n200\n\nscene\n\nadd\n\ngridHelper\n\nYou will now be able to see your player box move through the 3D world.\n\nIf you wait long enough, the box will move off the grid. Let's restrict the movement of the box so that it can't move off the grid.\n\nCreating a game course\u200b\n\nThe first thing we will do to prevent the player box from moving off the grid will be to add another box, the finishing line box. The finishing line box will be added at the boundary of the grid. Our game course will be from the center of the grid to the end of the grid, along the z-axis. Later, we will add collision detection to check if our player box has hit the finishing line box so that we can end the game before the player box leaves the grid.\n\nWe will create a new global variable called courseLength that will define the distance to the edge of the grid. Our player box starts moving from the center of the grid (x = 0, y = 0, z = 0) so our square grid's length should be double the course length. We will also restrict the movement of the box along the x- and y-axes. Add the following global variables to the top of the script.js file:\n\nconst\n\ncourseLength\n\n100\n\nconst\n\ngridHelperSize\n\ncourseLength\n\n// limit movement of player box on x and y-axis\n\nconst\n\nxBoundary\n\nboxSideLength\n\nconst\n\nyBoundary\n\nxBoundary\n\nWe set the courseLength to 100 world units. We use the gridHelperSize to define the length of our square grid along the x- and z-axes. The xBoundary and yBoundary variables are used to limit the movement of our player box along the x- and y-axes.\n\nLet's update the gridHelper to use the gridHelperSize variable for its size and number of divisions parameters:\n\nconst\n\ngridHelper\n\nnew\n\nTHREE\n\nGridHelper\n\ngridHelperSize\n\ngridHelperSize\n\nNow we will add the finish line box. Add the following to the initializeBoxes function:\n\n// create finish line box\n\nconst\n\ngeometry\n\nnew\n\nTHREE\n\nBoxGeometry\n\nxBoundary\n\nyBoundary\n\nboxSideLength\n\nconst\n\nmaterial\n\nnew\n\nTHREE\n\nMeshLambertMaterial\n\ncolor\n\n\"green\"\n\nconst\n\nmesh\n\nnew\n\nTHREE\n\nMesh\n\ngeometry\n\nmaterial\n\nmesh\n\nposition\n\nset\n\ncourseLength\n\nscene\n\nadd\n\nmesh\n\nThis creates a green box that is positioned at the end of the grid. It marks the end of the game course. It's positioned at the end of the course where the z-axis value is equal to the course length. The size of the box along its x- and y-axes marks the x and y boundary. We will restrict the player box's movement so that it can't move past the finish line box. Its size along the x- and y-axes is double the boundary length, because it needs to mark the negative and positive axis boundaries.\n\nYou will now be able to see the finish line box at the end of the grid. To reach the end of the grid sooner, you can change the speed variable.\n\nControlling the player box\u200b\n\nLet's add some controls so that we can move our player box up, down, left, and right.", "start_char_idx": 6239, "end_char_idx": 10272, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "61f17d33-a9bb-4423-a4ec-ebf19272d33d": {"__data__": {"id_": "61f17d33-a9bb-4423-a4ec-ebf19272d33d", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25a21e21-67fd-439f-86f0-8bc0ebfc79ca", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "0e17a6d4a2b8b8b97165fea5a047f6db3c0a1978a417cc4883040f3c36eb2119", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04ea0eb3-f319-4fe5-b38e-ced00816f0e3", "node_type": "1", "metadata": {}, "hash": "c6d5d2caeac212b396d413a8b6c644c15b189357f983ad37396251f5fd3683d2", "class_name": "RelatedNodeInfo"}}, "hash": "124cedd12485922571773f743333561c343eb149c88d56275c108200791d9cf7", "text": "It marks the end of the game course. It's positioned at the end of the course where the z-axis value is equal to the course length. The size of the box along its x- and y-axes marks the x and y boundary. We will restrict the player box's movement so that it can't move past the finish line box. Its size along the x- and y-axes is double the boundary length, because it needs to mark the negative and positive axis boundaries.\n\nYou will now be able to see the finish line box at the end of the grid. To reach the end of the grid sooner, you can change the speed variable.\n\nControlling the player box\u200b\n\nLet's add some controls so that we can move our player box up, down, left, and right. Add the following lines to the bottom of the script.js file:\n\n// moving player box with arrow keys\n\nwindow\n\naddEventListener\n\n\"keydown\"\n\n=>\n\nconst\n\nkey\n\nkey\n\nif\n\nkey\n\n===\n\n\"ArrowLeft\"\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\nif\n\nkey\n\n===\n\n\"ArrowRight\"\n\nplayer\n\nmesh\n\nposition\n\n=\n\nspeed\n\nif\n\nkey\n\n===\n\n\"ArrowUp\"\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\nif\n\nkey\n\n===\n\n\"ArrowDown\"\n\nplayer\n\nmesh\n\nposition\n\n=\n\nspeed\n\nThis creates an event listener that listens for a key press event. The player box's mesh (geometry + material) position is increased or decreased along the x- or y-axis, depending on which arrow button is pressed. Run your repl now and you should be able to move your player box with the arrow keys. You will notice that you can move off the screen, and when you reach the edge of the grid, you can avoid hitting the finish line box. Let's restrict the movement of the player box so that it always hits the finish line box. Replace the event listener that you just added with the following code:\n\nwindow\n\naddEventListener\n\n\"keydown\"\n\n=>\n\nconst\n\nkey\n\nkey\n\nconst\n\ncurrXPos\n\nplayer\n\nmesh\n\nposition\n\nconst\n\ncurrYPos\n\nplayer\n\nmesh\n\nposition\n\nif\n\nkey\n\n===\n\n\"ArrowLeft\"\n\nif\n\ncurrXPos\n\nxBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\nif\n\nkey\n\n===\n\n\"ArrowRight\"\n\nif\n\ncurrXPos\n\nxBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n=\n\nspeed\n\nif\n\nkey\n\n===\n\n\"ArrowUp\"\n\nif\n\ncurrYPos\n\nyBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\nif\n\nkey\n\n===\n\n\"ArrowDown\"\n\nif\n\ncurrYPos\n\nyBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n=\n\nspeed\n\nHere we add some extra lines of code to restrict the movement of the player box along the x- and y-axes by getting the current x and y position of the player box and then preventing movement if the position exceeds the current boundary values that we set using our global variables xBoundary and yBoundary.\n\nNote that if you increased the speed variable to reach the end of the course sooner, you may need to increase the width and height of the finish line box to ensure that the player box always hits it, as the player box will be able to move a bit more along the x- and y-axes.\n\nDetecting collisions\u200b\n\nTo determine that we have reached the end of the course, we need to be able to detect collisions. Once the player box has collided with the finish line box, the game is over. Add the following global variables to the top of your script.js file:\n\nlet\n\ngameOver\n\nfalse\n\nconst\n\nnumOfObstacles\n\nvar\n\nobstaclesBoundingBoxes\n\nThe gameOver flag variable will be used to determine when the game is over. This will occur once the finish line is reached, or if the player box collides with an obstacle (we will add obstacles later). The number of obstacles is currently zero. The obstaclesBoundingBoxes will store a set of x, y, and z positions of bounding boxes that describe the positions of all of our objects, excluding the player box. We will use these bounding boxes to detect collisions.\n\nIn the initializeBoxes function, add the following lines at the bottom:\n\nconst\n\nboundingBox\n\nnew\n\nTHREE\n\nBox3\n\nsetFromObject\n\nmesh\n\nobstaclesBoundingBoxes\n\npush\n\nboundingBox\n\nBox3 object represents a bounding box in 3D space. It describes a set of coordinates, it does not appear in our 3D world.", "start_char_idx": 9585, "end_char_idx": 13479, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04ea0eb3-f319-4fe5-b38e-ced00816f0e3": {"__data__": {"id_": "04ea0eb3-f319-4fe5-b38e-ced00816f0e3", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "61f17d33-a9bb-4423-a4ec-ebf19272d33d", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "124cedd12485922571773f743333561c343eb149c88d56275c108200791d9cf7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "268be51d-1102-4a76-a810-272d4c51bf08", "node_type": "1", "metadata": {}, "hash": "01ed4960cee66aab187106669ff103a4ff5707ed6a7a70d9ec816587729071a6", "class_name": "RelatedNodeInfo"}}, "hash": "c6d5d2caeac212b396d413a8b6c644c15b189357f983ad37396251f5fd3683d2", "text": "This will occur once the finish line is reached, or if the player box collides with an obstacle (we will add obstacles later). The number of obstacles is currently zero. The obstaclesBoundingBoxes will store a set of x, y, and z positions of bounding boxes that describe the positions of all of our objects, excluding the player box. We will use these bounding boxes to detect collisions.\n\nIn the initializeBoxes function, add the following lines at the bottom:\n\nconst\n\nboundingBox\n\nnew\n\nTHREE\n\nBox3\n\nsetFromObject\n\nmesh\n\nobstaclesBoundingBoxes\n\npush\n\nboundingBox\n\nBox3 object represents a bounding box in 3D space. It describes a set of coordinates, it does not appear in our 3D world. We use the\n\nmax\n\n3.75\n\n0.9375\n\n100.25\n\nmin\n\n3.75\n\n0.9375\n\n99.75\n\nNow let's create a function to detect collisions. Add the following function below the createBox function:\n\nfunction\n\ndetectCollisions\n\nconst\n\nplayerBox\n\nnew\n\nTHREE\n\nBox3\n\nsetFromObject\n\nplayer\n\nmesh\n\n// Check each object to detect if there is a collision\n\nfor\n\nlet\n\nnumOfObstacles\n\n++\n\n// an object was hit\n\nif\n\nobstaclesBoundingBoxes\n\nintersectsBox\n\nplayerBox\n\ngameOver\n\ntrue\n\nalert\n\n\"You win!\"\n\nreturn\n\nWe need to call the detectCollisions function in the game loop animate function so that we constantly check for a collision. Change your animate function so that it is the same as the animate function below:\n\nfunction\n\nanimate\n\nif\n\ngameOver\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\ncamera\n\nposition\n\n+=\n\nspeed\n\ndetectCollisions\n\nrenderer\n\nrender\n\nscene\n\ncamera\n\nrequestAnimationFrame\n\nanimate\n\nThe if statement at the start of the animate function prevents the function from running if the game is over.\n\nLet's also add if (gameOver) return; to the start of the \"keydown\" window.addEventListener callback function to disable the keyboard event if the game is over.\n\nYou will now get a \"You win!\" alert message once you reach the finish line box at the end of the grid.\n\nCreating obstacles\u200b\n\nNow let's add some obstacles for the player box to avoid to make it a game. Set the numOfObstacles global variable to 50. We are going to write a createObstacle function to generate 50 randomly positioned obstacles. Add the following function below the createBox function:\n\nfunction\n\ncreateObstacle\n\nconst\n\nTHREE\n\nMathUtils\n\nrandFloatSpread\n\nxBoundary\n\nconst\n\nTHREE\n\nMathUtils\n\nrandFloatSpread\n\nyBoundary\n\nconst\n\nTHREE\n\nMathUtils\n\nrandFloat\n\n10\n\ncourseLength\n\nboxSideLength\n\nconst\n\nobstacle\n\ncreateBox\n\nconst\n\nboundingBox\n\nnew\n\nTHREE\n\nBox3\n\nsetFromObject\n\nobstacle\n\nmesh\n\nobstaclesBoundingBoxes\n\npush\n\nboundingBox\n\nMathUtils object to get random x, y, and z points along our course. These will be used to randomly position obstacles. We get random x and y points using our x and y boundaries. The\n\nWe need to call the createObstacle function to create the obstacles. In the initializeBoxes function, let's add a for loop to create the obstacles:\n\nfunction\n\ninitializeBoxes\n\nplayer\n\ncreateBox\n\nfor\n\nlet\n\nnumOfObstacles\n\n++\n\ncreateObstacle\n\n...\n\nThis will create 50 randomly positioned obstacles. Run your repl to see them:\n\nEach time you reload the page, the obstacles will be randomly positioned.\n\nAdding win-or-lose logic\u200b\n\nTry to collide with an obstacle, and you will see that the alert message is always \"You win!\". Let's fix that by adding some win-or-lose logic. In the detectCollisions function, replace the for loop with the following for loop:\n\nfor\n\nlet\n\nnumOfObstacles\n\n++\n\n// an object was hit\n\nif\n\nobstaclesBoundingBoxes\n\nintersectsBox\n\nplayerBox\n\ngameOver\n\ntrue\n\nif\n\n!==\n\nnumOfObstacles\n\nalert\n\n\"You lose\"\n\nelse\n\n// the last box is the finish line box\n\nalert\n\n\"You win!\"\n\nreturn\n\nThe last object bounding box in the obstaclesBoundingBoxes array is the finish line box. Knowing this, we can determine when the player box has reached the finish line without hitting an obstacle. If the player box intersects with the last item in the obstaclesBoundingBoxes array, you win. If the player box intersects with any other item, you lose.\n\nThe game is now playable. Try make it to the end of the obstacle course.", "start_char_idx": 12793, "end_char_idx": 16862, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "268be51d-1102-4a76-a810-272d4c51bf08": {"__data__": {"id_": "268be51d-1102-4a76-a810-272d4c51bf08", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04ea0eb3-f319-4fe5-b38e-ced00816f0e3", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "c6d5d2caeac212b396d413a8b6c644c15b189357f983ad37396251f5fd3683d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5098ca05-59a1-4b62-9393-81c8decc6166", "node_type": "1", "metadata": {}, "hash": "7c76f1e0320a2bd223129104a872ddd6deaec8634226a0bb0fc45ba22056f880", "class_name": "RelatedNodeInfo"}}, "hash": "01ed4960cee66aab187106669ff103a4ff5707ed6a7a70d9ec816587729071a6", "text": "Let's fix that by adding some win-or-lose logic. In the detectCollisions function, replace the for loop with the following for loop:\n\nfor\n\nlet\n\nnumOfObstacles\n\n++\n\n// an object was hit\n\nif\n\nobstaclesBoundingBoxes\n\nintersectsBox\n\nplayerBox\n\ngameOver\n\ntrue\n\nif\n\n!==\n\nnumOfObstacles\n\nalert\n\n\"You lose\"\n\nelse\n\n// the last box is the finish line box\n\nalert\n\n\"You win!\"\n\nreturn\n\nThe last object bounding box in the obstaclesBoundingBoxes array is the finish line box. Knowing this, we can determine when the player box has reached the finish line without hitting an obstacle. If the player box intersects with the last item in the obstaclesBoundingBoxes array, you win. If the player box intersects with any other item, you lose.\n\nThe game is now playable. Try make it to the end of the obstacle course.\n\nAdding restart\u200b\n\nThere is one big problem with our game: once the game is over we need to refresh the page to play again. That's not a very good user experience. Let's add a \"Play\" button that will show on page load and when the game is over. It will start the game and reset everything that needs to be reset at the start of a game.\n\nAdd the following to the index.html file inside of the <body> tag to create a button and a screen that covers the window behind the button:\n\ndiv\n\nid\n\nplay-btn-screen\n\ndiv\n\nclass\n\nplay-btn-container\n\ndiv\n\nUse the up, down, left and right arrow keys to move\n\n</\n\ndiv\n\nbutton\n\nid\n\nplay-btn\n\nPlay\n\n</\n\nbutton\n\n</\n\ndiv\n\n</\n\ndiv\n\nAdd the following to the style.css file:\n\n#play-btn-screen\n\nposition\n\nabsolute\n\nmin-width\n\n100\n\nmin-height\n\n100\n\ndisplay\n\nflex\n\nalign-items\n\ncenter\n\njustify-content\n\ncenter\n\nz-index\n\n.play-btn-container\n\ncolor\n\nwhite\n\ntext-align\n\ncenter\n\n#play-btn\n\nbackground-color\n\nred\n\npadding\n\nrem\n\n1.5\n\nrem\n\nmargin\n\n0.5\n\nrem\n\nThis will create a play button in the middle of the screen.\n\nNow let's make the button work. Add the following global variables to the top of the script.js file:\n\nconst\n\nplayBtnScreen\n\ndocument\n\ngetElementById\n\n\"play-btn-screen\"\n\nconst\n\nplayBtn\n\nplayBtnScreen\n\nquerySelector\n\n\"#play-btn\"\n\nvar\n\nallObjs\n\nThis gets the play button screen (background cover behind the button) and play button element from the DOM and stores them in variables. The allObjs array will store all of the created objects. We need this array to clear the scene by removing all of the objects at the start of each game. We do this so that we can place new randomly positioned objects in the scene and not have objects in the scene from previous rounds.\n\nNext, add a new click event listener on the playBtn. Add the following to the bottom of the script.js file:\n\nplayBtn\n\naddEventListener\n\n\"click\"\n\n=>\n\nallObjs\n\nforEach\n\nobj\n\n=>\n\nscene\n\nremove\n\nobj\n\ncamera\n\nposition\n\nset\n\ncamera\n\nlookAt\n\ninitializeBoxes\n\ngameOver\n\nfalse\n\nanimate\n\nplayBtnScreen\n\nstyle\n\nvisibility\n\n\"hidden\"\n\nDelete the animate() function call in the init function. We now call it when the play button is clicked.\n\nAdd allObjs.push(mesh); in the createBox function above  scene.add(mesh);. This adds the created box mesh (object) to the allObjs array.\n\nAdd the following lines in the detectCollisions function below gameOver = true;:playBtnScreen.style.visibility = \"visible\";playBtn.focus();This will make our play button visible at the end of the game and focus the button so that you can easily restart the game by pressing the spacebar or enter key.\n\nAdd the following lines at the start of the initializeBoxes function:// make empty at start of a gameallObjs = [];obstaclesBoundingBoxes = [];This clears the allObjs array so that it only contains objects created in the current game. We also clear the obstaclesBoundingBoxes as we only want to detect collisions with objects in the current game.\n\nAdd allObjs.push(mesh); in the initializeBoxes function above scene.add(mesh);. This adds the finish line box to the allObjs array.\n\nOur game is almost complete, all we need to do now is make it mobile-friendly.\n\nMaking the game mobile friendly: Adding on-screen arrow buttons\u200b\n\nTo make the game mobile friendly, we will add up, down, left, and right buttons to the bottom of the screen.", "start_char_idx": 16065, "end_char_idx": 20166, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5098ca05-59a1-4b62-9393-81c8decc6166": {"__data__": {"id_": "5098ca05-59a1-4b62-9393-81c8decc6166", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "268be51d-1102-4a76-a810-272d4c51bf08", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "01ed4960cee66aab187106669ff103a4ff5707ed6a7a70d9ec816587729071a6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "463fb1f4-f863-4a8a-9aaf-6d5f292fdd48", "node_type": "1", "metadata": {}, "hash": "f6717bfa33e8f68bbb9372190a2678df3100cab63b059a7ace0fa88e698c155a", "class_name": "RelatedNodeInfo"}}, "hash": "7c76f1e0320a2bd223129104a872ddd6deaec8634226a0bb0fc45ba22056f880", "text": "Add the following lines at the start of the initializeBoxes function:// make empty at start of a gameallObjs = [];obstaclesBoundingBoxes = [];This clears the allObjs array so that it only contains objects created in the current game. We also clear the obstaclesBoundingBoxes as we only want to detect collisions with objects in the current game.\n\nAdd allObjs.push(mesh); in the initializeBoxes function above scene.add(mesh);. This adds the finish line box to the allObjs array.\n\nOur game is almost complete, all we need to do now is make it mobile-friendly.\n\nMaking the game mobile friendly: Adding on-screen arrow buttons\u200b\n\nTo make the game mobile friendly, we will add up, down, left, and right buttons to the bottom of the screen.\n\nAdd the following to the index.html file inside the <body> tag, just above the <script> tag to create the buttons:\n\ndiv\n\nid\n\nkeys\n\ndiv\n\nclass\n\nkeys-container\n\nbutton\n\nid\n\nup\n\nsvg\n\nwidth\n\n30\n\nheight\n\n30\n\nviewBox\n\n0 0 10 10\n\ntransform\n\nrotate(0, 5,5)\n\npath\n\nM5,4 L7,6 L3,6 L5,4\n\n/>\n\n</\n\n</\n\nsvg\n\n</\n\nbutton\n\nbutton\n\nid\n\nleft\n\nsvg\n\nwidth\n\n30\n\nheight\n\n30\n\nviewBox\n\n0 0 10 10\n\ntransform\n\nrotate(-90, 5,5)\n\npath\n\nM5,4 L7,6 L3,6 L5,4\n\n/>\n\n</\n\n</\n\nsvg\n\n</\n\nbutton\n\nbutton\n\nid\n\ndown\n\nsvg\n\nwidth\n\n30\n\nheight\n\n30\n\nviewBox\n\n0 0 10 10\n\ntransform\n\nrotate(180, 5,5)\n\npath\n\nM5,4 L7,6 L3,6 L5,4\n\n/>\n\n</\n\n</\n\nsvg\n\n</\n\nbutton\n\nbutton\n\nid\n\nright\n\nsvg\n\nwidth\n\n30\n\nheight\n\n30\n\nviewBox\n\n0 0 10 10\n\ntransform\n\nrotate(90, 5,5)\n\npath\n\nM5,4 L7,6 L3,6 L5,4\n\n/>\n\n</\n\n</\n\nsvg\n\n</\n\nbutton\n\n</\n\ndiv\n\n</\n\ndiv\n\nThe up, down, left, and right icons are created using SVGs.\n\nNow let's add some basic styling to our buttons. Add the following to the style.css file:\n\n#keys\n\nposition\n\nabsolute\n\nmin-width\n\n100\n\nmin-height\n\n100\n\ndisplay\n\nflex\n\nalign-items\n\nflex-end\n\njustify-content\n\ncenter\n\n.keys-container\n\ndisplay\n\ngrid\n\ngrid-template-columns\n\n50\n\npx\n\n50\n\npx\n\n50\n\npx\n\ngrid-template-rows\n\nauto\n\ngrid-template-areas\n\n\".    up   .\"\n\n\"left down right\"\n\ngrid-gap\n\n10\n\npx\n\npadding-bottom\n\nrem\n\n#keys\n\nbutton\n\npadding\n\n0.5\n\nrem\n\n#up\n\ngrid-area\n\nup\n\n#down\n\ngrid-area\n\ndown\n\n#left\n\ngrid-area\n\nleft\n\n#right\n\ngrid-area\n\nright\n\nTo see the arrows, click the \"Open in a new tab\" button in the repl Output tab. This opens the link to the repl in a new tab. You can copy this link to view your repl on your phone or to share it with your friends.\n\nYou should now be able to see the screen arrow buttons.\n\nTry clicking a button before pressing \"Play\". You will notice that you can't click the arrow buttons. This is because the play button screen, which covers the whole screen, has a CSS z-index property of 1. Once you click \"Play\", the play button screen CSS visibility property is set to hidden, and you will be able to press the arrow buttons.\n\nNow let's add some JavaScript click event listeners and some functions to make our arrow buttons work on desktop and mobile. Our code is going to look quite complex because we use some extra functions and setTimeout to allow the player box to continuously move when the arrow button is held down. This makes for a better user experience than having to continuously tap or click the button to move in one direction. Add the following global variable to the top of the script.js file:\n\nconst\n\nkeyBtns\n\ndocument\n\nquerySelectorAll\n\n\".keys-container button\"\n\nThis gets all the key buttons from the DOM and stores them in a variable.", "start_char_idx": 19432, "end_char_idx": 22791, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "463fb1f4-f863-4a8a-9aaf-6d5f292fdd48": {"__data__": {"id_": "463fb1f4-f863-4a8a-9aaf-6d5f292fdd48", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5098ca05-59a1-4b62-9393-81c8decc6166", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "7c76f1e0320a2bd223129104a872ddd6deaec8634226a0bb0fc45ba22056f880", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3792beec-c0ce-4424-a1ed-cd5ec88ae74a", "node_type": "1", "metadata": {}, "hash": "e7d87560f32a981a04890ba1de8732c7d390f0c172af24025169114cad4489d7", "class_name": "RelatedNodeInfo"}}, "hash": "f6717bfa33e8f68bbb9372190a2678df3100cab63b059a7ace0fa88e698c155a", "text": "You will notice that you can't click the arrow buttons. This is because the play button screen, which covers the whole screen, has a CSS z-index property of 1. Once you click \"Play\", the play button screen CSS visibility property is set to hidden, and you will be able to press the arrow buttons.\n\nNow let's add some JavaScript click event listeners and some functions to make our arrow buttons work on desktop and mobile. Our code is going to look quite complex because we use some extra functions and setTimeout to allow the player box to continuously move when the arrow button is held down. This makes for a better user experience than having to continuously tap or click the button to move in one direction. Add the following global variable to the top of the script.js file:\n\nconst\n\nkeyBtns\n\ndocument\n\nquerySelectorAll\n\n\".keys-container button\"\n\nThis gets all the key buttons from the DOM and stores them in a variable.\n\nNow add the following to the bottom of the script.js file:\n\nlet\n\ntimeoutID\n\nfunction\n\nmoveLeft\n\nconst\n\ncurrXPos\n\nplayer\n\nmesh\n\nposition\n\nif\n\ncurrXPos\n\nxBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nsetTimeout\n\nmoveLeft\n\n50\n\nfunction\n\nmoveRight\n\nconst\n\ncurrXPos\n\nplayer\n\nmesh\n\nposition\n\nif\n\ncurrXPos\n\nxBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n=\n\nspeed\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nsetTimeout\n\nmoveRight\n\n50\n\nfunction\n\nmoveUp\n\nconst\n\ncurrYPos\n\nplayer\n\nmesh\n\nposition\n\nif\n\ncurrYPos\n\nyBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n+=\n\nspeed\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nsetTimeout\n\nmoveUp\n\n50\n\nfunction\n\nmoveDown\n\nconst\n\ncurrYPos\n\nplayer\n\nmesh\n\nposition\n\nif\n\ncurrYPos\n\nyBoundary\n\nreturn\n\nplayer\n\nmesh\n\nposition\n\n=\n\nspeed\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nsetTimeout\n\nmoveDown\n\n50\n\nfunction\n\nhandleKeyDown\n\nif\n\ngameOver\n\nreturn\n\nconst\n\nid\n\ncurrentTarget\n\nif\n\nid\n\n===\n\n\"left\"\n\nmoveLeft\n\nif\n\nid\n\n===\n\n\"right\"\n\nmoveRight\n\nif\n\nid\n\n===\n\n\"up\"\n\nmoveUp\n\nif\n\nid\n\n===\n\n\"down\"\n\nmoveDown\n\n// moving box - mobile - using screen btns\n\nkeyBtns\n\nforEach\n\nkeyBtn\n\n=>\n\nkeyBtn\n\naddEventListener\n\n\"mousedown\"\n\nhandleKeyDown\n\nkeyBtn\n\naddEventListener\n\n\"touchstart\"\n\nhandleKeyDown\n\nkeyBtn\n\naddEventListener\n\n\"mouseup\"\n\n=>\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nkeyBtn\n\naddEventListener\n\n\"mouseleave\"\n\n=>\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nkeyBtn\n\naddEventListener\n\n\"touchend\"\n\n=>\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nkeyBtn\n\naddEventListener\n\n\"touchcancel\"\n\n=>\n\nclearTimeout\n\ntimeoutID\n\ntimeoutID\n\nsetTimeout so that the movement is continuous when the button is held down.\n\nThe setTimeout function returns a timeoutID that is a positive integer value. It identifies the timer created by the call to setTimeout(). This value is passed to clearTimeout() to cancel the timeout after each recursive function call so that we don't create unnecessary timeouts.\n\nFor each key button, we also add \"mouseleave\", \"touchend\", and \"touchcancel\" event listeners. These clear the timeouts when the button is not held down anymore.\n\nA little cheat in the game: If you have a touchscreen laptop, pressing the arrow key on your keyboard and on the screen will make it move faster than normal!\n\nSave and run your project. Our game is complete!\n\nNext steps\u200b\n\nWe learnt the basics of three.js and built a simple 3D game. There are many things that you can do to improve the game. Here are some you might want to try:\n\nReplace the alert with a nicely styled modal.\n\nStyle the objects, or import or create 3D models. See rendering 3D scenes with three.js for more information.\n\nAdd a nicer surface instead of the grid.\n\nAdd a loading screen while the 3D scene is loading.\n\nMake the game more challenging by increasing the speed the player box moves at as the game progresses, adding more obstacles, or by making the obstacles move.\n\nAdd a points system. Change the game logic so that you have to hit the boxes to get points.Store the points in local storage.\n\nAdd physics to the collisions using cannon-es.\n\nOr for a more advanced challenge: Make a bigger course, try making infinite movement within finite bounds so that you don't use too much of your computer's memory.", "start_char_idx": 21866, "end_char_idx": 25975, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3792beec-c0ce-4424-a1ed-cd5ec88ae74a": {"__data__": {"id_": "3792beec-c0ce-4424-a1ed-cd5ec88ae74a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "41e2661644ed8d809f0b871839af07caf66e21894904a9d9a892906c81b2006b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "463fb1f4-f863-4a8a-9aaf-6d5f292fdd48", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}, "hash": "f6717bfa33e8f68bbb9372190a2678df3100cab63b059a7ace0fa88e698c155a", "class_name": "RelatedNodeInfo"}}, "hash": "e7d87560f32a981a04890ba1de8732c7d390f0c172af24025169114cad4489d7", "text": "There are many things that you can do to improve the game. Here are some you might want to try:\n\nReplace the alert with a nicely styled modal.\n\nStyle the objects, or import or create 3D models. See rendering 3D scenes with three.js for more information.\n\nAdd a nicer surface instead of the grid.\n\nAdd a loading screen while the 3D scene is loading.\n\nMake the game more challenging by increasing the speed the player box moves at as the game progresses, adding more obstacles, or by making the obstacles move.\n\nAdd a points system. Change the game logic so that you have to hit the boxes to get points.Store the points in local storage.\n\nAdd physics to the collisions using cannon-es.\n\nOr for a more advanced challenge: Make a bigger course, try making infinite movement within finite bounds so that you don't use too much of your computer's memory.\n\nYou can find our repl below:\n\n< Previous: Miscellanious\n\nNext: 3D rendering with three.js >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nCreating a new project in Replit\n\nImporting three.js to the project\n\nCreating a scene with the player box\n\nAnimating the player box\n\nCreating a game course\n\nControlling the player box\n\nDetecting collisions\n\nCreating obstacles\n\nAdding win-or-lose logic\n\nAdding restart\n\nMaking the game mobile friendly: Adding on-screen arrow buttons\n\nNext steps", "start_char_idx": 25127, "end_char_idx": 26463, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"560cd1a8-b9b4-4dc4-bc7d-044ba029ac82": {"node_ids": ["8ce63f44-3a98-43d6-904d-fb325161ee77", "95577446-96d6-43d8-b59f-2344bea99cec", "25a21e21-67fd-439f-86f0-8bc0ebfc79ca", "61f17d33-a9bb-4423-a4ec-ebf19272d33d", "04ea0eb3-f319-4fe5-b38e-ced00816f0e3", "268be51d-1102-4a76-a810-272d4c51bf08", "5098ca05-59a1-4b62-9393-81c8decc6166", "463fb1f4-f863-4a8a-9aaf-6d5f292fdd48", "3792beec-c0ce-4424-a1ed-cd5ec88ae74a"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/misc/3D-game-with-three.js.html"}}}, "docstore/metadata": {"8ce63f44-3a98-43d6-904d-fb325161ee77": {"doc_hash": "0f9eae325fdae356b948b243eddf955d3da4e4cb2af807ea3231da6ae8b677ed", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "95577446-96d6-43d8-b59f-2344bea99cec": {"doc_hash": "297839c4913ad4eebe78299fb603fa3e54e58341a8c564f952c0c21f4459d700", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "25a21e21-67fd-439f-86f0-8bc0ebfc79ca": {"doc_hash": "0e17a6d4a2b8b8b97165fea5a047f6db3c0a1978a417cc4883040f3c36eb2119", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "61f17d33-a9bb-4423-a4ec-ebf19272d33d": {"doc_hash": "124cedd12485922571773f743333561c343eb149c88d56275c108200791d9cf7", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "04ea0eb3-f319-4fe5-b38e-ced00816f0e3": {"doc_hash": "c6d5d2caeac212b396d413a8b6c644c15b189357f983ad37396251f5fd3683d2", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "268be51d-1102-4a76-a810-272d4c51bf08": {"doc_hash": "01ed4960cee66aab187106669ff103a4ff5707ed6a7a70d9ec816587729071a6", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "5098ca05-59a1-4b62-9393-81c8decc6166": {"doc_hash": "7c76f1e0320a2bd223129104a872ddd6deaec8634226a0bb0fc45ba22056f880", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "463fb1f4-f863-4a8a-9aaf-6d5f292fdd48": {"doc_hash": "f6717bfa33e8f68bbb9372190a2678df3100cab63b059a7ace0fa88e698c155a", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}, "3792beec-c0ce-4424-a1ed-cd5ec88ae74a": {"doc_hash": "e7d87560f32a981a04890ba1de8732c7d390f0c172af24025169114cad4489d7", "ref_doc_id": "560cd1a8-b9b4-4dc4-bc7d-044ba029ac82"}}}