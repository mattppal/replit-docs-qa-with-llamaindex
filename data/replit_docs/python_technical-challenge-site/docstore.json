{"docstore/data": {"2751da25-e8f2-4d0d-a730-c706ee496852": {"__data__": {"id_": "2751da25-e8f2-4d0d-a730-c706ee496852", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27e92265-725c-4453-8a3a-9b9d7b015ea1", "node_type": "1", "metadata": {}, "hash": "9f06f831d8b98399cc423f141a3c67c03dcb03e0185633a317f047d59eeb0a99", "class_name": "RelatedNodeInfo"}}, "hash": "d7bf92bdb91646b7ab00a9ab30dd523e40549b0fe32db943454b58757ddbca34", "text": "def\n\ndb_init\n\nif\n\n\"teams\"\n\nnot\n\nin\n\ndb\n\nkeys\n\ndb\n\n\"teams\"\n\nif\n\n\"challenges\"\n\nnot\n\nin\n\ndb\n\nkeys\n\ndb\n\n\"challenges\"\n\nif\n\n\"competition_started\"\n\nnot\n\nin\n\ndb\n\nkeys\n\ndb\n\n\"competition_started\"\n\nFalse\n\nReplit's Database. Any values we store in db will persist between repl restarts.\n\nTo import this file in main.py, we can use an import statement in much the same way as we would for a module. Add this line in main.py, below your other imports:\n\nfrom\n\ndb_init\n\nimport\n\ndb_init\n\nWe've also defined a secondary database users in main.py. While db only contains what we put into it, users is a UserStore that will automatically have the names of users who sign into our application added as keys, so we can easily store and retrieve information about them.\n\nNow let's create some test content and run our app. Add the following code, and then run your repl.\n\n# Routes\n\n@app\n\nroute\n\n\"/\"\n\n@web\n\nauthenticated\n\ndef\n\nindex\n\nreturn\n\nf\"Hello\n\nweb\n\nauth\n\nname\n\nweb\n\nrun\n\napp\n\nBecause we've added the @web.authenticated function decorator to our index page, it will only be available to logged in users. You should see this now, as your app will show a login button. Click on that button, and authorize your application to use Replit authentication in the window that pops up.\n\nHaving done that, you should now see the greeting we implemented above. If you send your repl to a friend, they will also be able to log in, and see their own Replit username on the greeting message.\n\nCreating user roles\u200b\n\nFunction decorators like @web.authenticated, which prevent a function from executing unless certain conditions are met, are very useful for web applications like this one, in which we want to restrict certain pages based on who's attempting to view them. @web.authenticated restricts users based on authentication -- who a user is. We can now create our own decorators to restrict users based on authorization -- what a user is allowed to do.\n\nFor this site, we're concerned about three things:\n\nIs the user in a team? Users who aren't need to be able to create or join a team, and users who are need to be able to submit challenge solutions.\n\nIs the user an admin? Users who are need to be able to create challenges, and perform other administrative tasks. For the sake of fairness, they should not be allowed to join teams themselves.\n\nIs the competition running? If not, we don't want non-admin users to be able to view challenge pages or attempt to submit solutions.\n\nFirst, we'll create two helper functions to answer these questions. Add the following code to main.py, just below your ADMINS list:\n\n# Helper functions\n\ndef\n\nis_admin\n\nusername\n\nreturn\n\nusername\n\nin\n\nADMINS\n\ndef\n\nin_team\n\nusername\n\nif\n\n\"team\"\n\nin\n\nusers\n\nusername\n\nkeys\n\nreturn\n\nusers\n\nusername\n\n\"team\"\n\nThe is_admin() function will return True if the provided user is an admin, or False otherwise. The function in_team() will return the name of the team the user is in, or None if they aren't in a team.\n\nNow we can create our authorization function decorators. Add the following import function to the top of main.py:\n\nfrom\n\nfunctools\n\nimport\n\nwraps\n\nThen add this code below our helper functions:\n\n# Authorization decorators\n\ndef\n\nadmin_only\n\n@wraps\n\ndef\n\ndecorated_function\n\nargs\n\n**\n\nkwargs\n\nif\n\nnot\n\nis_admin\n\nweb\n\nauth\n\nname\n\nflash\n\n\"Permission denied.\"\n\n\"warning\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nargs\n\n**\n\nkwargs\n\nreturn\n\ndecorated_function\n\nThis code may look a bit strange if you haven't written your own decorators before. Here's how it works: admin_only is the name of our decorator. You can think of decorators as functions which take other functions as arguments. (The code coming up is example code for the purpose of illustration, and not part of our program.) Therefore, if we write the following:\n\n@admin_only\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_function\n\nit will be roughly equivalent to:\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_only\n\nadmin_function\n\nSo whenever admin_function gets called, the code we've defined in decorated_function will execute before anything we define in admin_function. This means we don't have to include an if not is_admin check in every piece of admin functionality.", "start_char_idx": 0, "end_char_idx": 4208, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27e92265-725c-4453-8a3a-9b9d7b015ea1": {"__data__": {"id_": "27e92265-725c-4453-8a3a-9b9d7b015ea1", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2751da25-e8f2-4d0d-a730-c706ee496852", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "d7bf92bdb91646b7ab00a9ab30dd523e40549b0fe32db943454b58757ddbca34", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9a104f85-54ee-4f72-a7e9-41b3c764f679", "node_type": "1", "metadata": {}, "hash": "259ac69ab14e951a8a0de918241459ecac6a00111e77777d9638755cbaef434f", "class_name": "RelatedNodeInfo"}}, "hash": "9f06f831d8b98399cc423f141a3c67c03dcb03e0185633a317f047d59eeb0a99", "text": "\"warning\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nargs\n\n**\n\nkwargs\n\nreturn\n\ndecorated_function\n\nThis code may look a bit strange if you haven't written your own decorators before. Here's how it works: admin_only is the name of our decorator. You can think of decorators as functions which take other functions as arguments. (The code coming up is example code for the purpose of illustration, and not part of our program.) Therefore, if we write the following:\n\n@admin_only\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_function\n\nit will be roughly equivalent to:\n\ndef\n\nadmin_function\n\nreturn\n\nf\"Hello admin\"\n\nadmin_only\n\nadmin_function\n\nSo whenever admin_function gets called, the code we've defined in decorated_function will execute before anything we define in admin_function. This means we don't have to include an if not is_admin check in every piece of admin functionality. As per the code, if a non-admin attempts to access restricted functionality, our app will flash a warning message and redirect them to the home page.\n\nWe also need to define a decorator for the opposite case, where we need to ensure that the current user is not an admin. Add the following code just below the # Authorization decorators code you added above:\n\ndef\n\nnot_admin_only\n\n@wraps\n\ndef\n\ndecorated_function\n\nargs\n\n**\n\nkwargs\n\nif\n\nis_admin\n\nweb\n\nauth\n\nname\n\nflash\n\n\"Admins can't do that.\"\n\n\"warning\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nargs\n\n**\n\nkwargs\n\nreturn\n\ndecorated_function\n\nWe will do much the same thing for team_only and not_team_only:\n\ndef\n\nteam_only\n\n@wraps\n\ndef\n\ndecorated_function\n\nargs\n\n**\n\nkwargs\n\nif\n\nnot\n\nin_team\n\nweb\n\nauth\n\nname\n\nflash\n\n\"Join a team first!\"\n\n\"warning\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nargs\n\n**\n\nkwargs\n\nreturn\n\ndecorated_function\n\ndef\n\nnot_team_only\n\n@wraps\n\ndef\n\ndecorated_function\n\nargs\n\n**\n\nkwargs\n\nif\n\nin_team\n\nweb\n\nauth\n\nname\n\nflash\n\n\"You've already joined a team!\"\n\n\"warning\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nargs\n\n**\n\nkwargs\n\nreturn\n\ndecorated_function\n\nFinally, we need to add a decorator to check whether our competition is running. This is mainly for challenge description pages, so we'll add an exception for non-admin users:\n\ndef\n\ncompetition_running\n\n@wraps\n\ndef\n\ndecorated_function\n\nargs\n\n**\n\nkwargs\n\nif\n\nnot\n\nis_admin\n\nweb\n\nauth\n\nname\n\nor\n\ndb\n\n\"competition_started\"\n\nflash\n\n\"The competition has not started yet.\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nargs\n\n**\n\nkwargs\n\nreturn\n\ndecorated_function\n\nNow that we've added our authorization controls, it's time to give them something to authorize. In the next sections, we'll define all of our app's functionality and build its front-end.\n\nBuilding forms\u200b\n\nThe bulk of interactivity in our application will be enabled through forms. Users will be able to create and join teams, as well as submit challenge solutions. When we work with web forms, there's a lot to consider, including:\n\nWhich users should be able to submit which forms (authorization)?\n\nWhat validation do we want on different fields? For example, length requirements, or ensuring a given value is an integer rather than a string.\n\nHow do we give feedback on data that doesn't pass our validations?\n\nSecurity concerns around user input, such as SQL injection, cross-site scripting and cross-site request forgery. While the first one won't be relevant to our app, the second two are.\n\nWe could build all of this ourselves using Flask's request.form as a basis, but fortunately someone else has already done the hard work and built the WTForms library, as well as Flask WTF, which integrates WTForms with Flask. We'll be using both of these to construct our application's various forms.\n\nTo keep our codebase navigable, we'll put all our form code in a separate file, like we did with our database initialization code. Create forms.py in your repl's files tab now:\n\nWe'll start this file off with some imports:\n\nfrom\n\nreplit\n\nimport\n\ndb\n\nfrom\n\nflask_wtf\n\nimport\n\nFlaskForm\n\nfrom\n\nwtforms\n\nimport\n\nStringField\n\nTextAreaField\n\nSubmitField\n\nPasswordField\n\nSelectField\n\nIntegerField\n\nValidationError\n\nfrom\n\nwtforms\n\nvalidators\n\nimport\n\nInputRequired\n\nNumberRange\n\nLength\n\nHere we import our Replit database, which we'll need for uniqueness validations, as well as everything we'll be using from WTForms and Flask WTF.", "start_char_idx": 3317, "end_char_idx": 7626, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a104f85-54ee-4f72-a7e9-41b3c764f679": {"__data__": {"id_": "9a104f85-54ee-4f72-a7e9-41b3c764f679", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27e92265-725c-4453-8a3a-9b9d7b015ea1", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "9f06f831d8b98399cc423f141a3c67c03dcb03e0185633a317f047d59eeb0a99", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f8126eec-489c-4ec1-b80a-b132fe17f834", "node_type": "1", "metadata": {}, "hash": "36658118049cd782a96b962fe92f0f5ebdb2c7e7ffc4ebfee62fccbf46a1678a", "class_name": "RelatedNodeInfo"}}, "hash": "259ac69ab14e951a8a0de918241459ecac6a00111e77777d9638755cbaef434f", "text": "We'll be using both of these to construct our application's various forms.\n\nTo keep our codebase navigable, we'll put all our form code in a separate file, like we did with our database initialization code. Create forms.py in your repl's files tab now:\n\nWe'll start this file off with some imports:\n\nfrom\n\nreplit\n\nimport\n\ndb\n\nfrom\n\nflask_wtf\n\nimport\n\nFlaskForm\n\nfrom\n\nwtforms\n\nimport\n\nStringField\n\nTextAreaField\n\nSubmitField\n\nPasswordField\n\nSelectField\n\nIntegerField\n\nValidationError\n\nfrom\n\nwtforms\n\nvalidators\n\nimport\n\nInputRequired\n\nNumberRange\n\nLength\n\nHere we import our Replit database, which we'll need for uniqueness validations, as well as everything we'll be using from WTForms and Flask WTF.\n\nBefore we get started with our forms, it's worth thinking about how we're going to lay out the data structures they'll be used to create and modify. In db_init.py, we've defined two dictionaries -- \"challenges\" and \"teams\". Each of these will contain a dictionary for each challenge or team, keyed by an ID. Our data structure will look something like this:\n\n\"challenges\"\n\n\"ID\"\n\n\"name\"\n\n\"NAME\"\n\n\"description\"\n\n\"DESCRIPTION\"\n\n\"points\"\n\n10\n\n\"code\"\n\n\"CHALLENGE SOLUTION CODE\"\n\n\"teams\"\n\n\"ID\"\n\n\"name\"\n\n\"NAME\"\n\n\"team_leader\"\n\n\"LEADER NAME\"\n\n\"team_members\"\n\n\"LEADER NAME\"\n\n\"ADDITIONAL MEMBER\"\n\n\"score\"\n\n\"password\"\n\n\"TEAM PASSWORD\"\n\n\"challenges_solved\"\n\n\"CHALLENGE ID\"\n\n\"ANOTHER CHALLENGE ID\"\n\nThe ID value for both our challenges and teams will be the challenge or team name, all-lowercase, with spaces replaced by hyphens, so we can use it in our app's URLs. Let's create a function that turns names into IDs, in forms.py, just below our imports:\n\ndef\n\nname_to_id\n\nname\n\nreturn\n\nname\n\nlower\n\nreplace\n\n\" \"\n\n\"-\"\n\nNow we can start creating our forms. With Flask WTF, we model each form as a class inheriting from FlaskForm. These classes take in the value of Flask's request.form and apply validations to the fields therein. We'll create our TeamCreateField first, with the following code:\n\nclass\n\nTeamCreateForm\n\nFlaskForm\n\nname\n\nStringField\n\n\"Team name\"\n\nvalidators\n\nInputRequired\n\nLength\n\npassword\n\nPasswordField\n\n\"Team password\"\n\nvalidators\n\nInputRequired\n\nLength\n\nsubmit\n\nSubmitField\n\n\"Create team\"\n\ndef\n\nvalidate_name\n\nform\n\nfield\n\nif\n\nname_to_id\n\nfield\n\ndata\n\nin\n\ndb\n\n\"teams\"\n\nkeys\n\nraise\n\nValidationError\n\n\"Team name already taken.\"\n\nWhen users create teams, they'll specify a team name and team password. In our WTForms field specifications above, we've defined minimum lengths for both of these fields, ensured that the team password is entered in a password field, and written a custom validator to reject new teams with IDs that match existing teams. Because we're validating on ID rather than name, users won't be able to create teams with the same name but different capitalization (e.g. \"Codeslingers\" and \"codeslingers\").\n\nEvery field in all of our forms includes the InputRequired validator, which will ensure that users do not submit blank values. This validator can be left out for optional fields.\n\nOur ChallengeCreateForm is similar to TeamCreateForm, and can be added below it:\n\nclass\n\nChallengeCreateForm\n\nFlaskForm\n\nname\n\nStringField\n\n\"Challenge name\"\n\nvalidators\n\nInputRequired\n\nLength\n\ndescription\n\nTextAreaField\n\n\"Challenge description\"\n\nvalidators\n\nInputRequired\n\npoints\n\nIntegerField\n\n\"Challenge points\"\n\nvalidators\n\nInputRequired\n\nNumberRange\n\ncode\n\nStringField\n\n\"Challenge code\"\n\nvalidators\n\nInputRequired\n\nLength\n\nsubmit\n\nSubmitField\n\n\"Create challenge\"\n\ndef\n\nvalidate_name\n\nform\n\nfield\n\nif\n\nname_to_id\n\nfield\n\ndata\n\nin\n\ndb\n\n\"challenges\"\n\nkeys\n\nraise\n\nValidationError\n\n\"Challenge name already used.\"\n\nHere we've used the TextAreaField to give a bit more space for our users to write challenge descriptions, and IntegerField to specify the number of points a challenge is worth. We're also requiring that challenges be worth at least 1 point, using the NumberRange validator.", "start_char_idx": 6925, "end_char_idx": 10825, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f8126eec-489c-4ec1-b80a-b132fe17f834": {"__data__": {"id_": "f8126eec-489c-4ec1-b80a-b132fe17f834", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9a104f85-54ee-4f72-a7e9-41b3c764f679", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "259ac69ab14e951a8a0de918241459ecac6a00111e77777d9638755cbaef434f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "06b20a78-ce61-47c8-b030-8200bbbabdba", "node_type": "1", "metadata": {}, "hash": "886c07bddb09510f8b00412222d51bd0060212c288a97bea84bd20052dc3f3ae", "class_name": "RelatedNodeInfo"}}, "hash": "36658118049cd782a96b962fe92f0f5ebdb2c7e7ffc4ebfee62fccbf46a1678a", "text": "Our ChallengeCreateForm is similar to TeamCreateForm, and can be added below it:\n\nclass\n\nChallengeCreateForm\n\nFlaskForm\n\nname\n\nStringField\n\n\"Challenge name\"\n\nvalidators\n\nInputRequired\n\nLength\n\ndescription\n\nTextAreaField\n\n\"Challenge description\"\n\nvalidators\n\nInputRequired\n\npoints\n\nIntegerField\n\n\"Challenge points\"\n\nvalidators\n\nInputRequired\n\nNumberRange\n\ncode\n\nStringField\n\n\"Challenge code\"\n\nvalidators\n\nInputRequired\n\nLength\n\nsubmit\n\nSubmitField\n\n\"Create challenge\"\n\ndef\n\nvalidate_name\n\nform\n\nfield\n\nif\n\nname_to_id\n\nfield\n\ndata\n\nin\n\ndb\n\n\"challenges\"\n\nkeys\n\nraise\n\nValidationError\n\n\"Challenge name already used.\"\n\nHere we've used the TextAreaField to give a bit more space for our users to write challenge descriptions, and IntegerField to specify the number of points a challenge is worth. We're also requiring that challenges be worth at least 1 point, using the NumberRange validator.\n\nNext up is our TeamJoinForm:\n\nclass\n\nTeamJoinForm\n\nFlaskForm\n\nname\n\nSelectField\n\n\"Team to join\"\n\nchoices\n\nteam_id\n\nteam\n\n\"name\"\n\nfor\n\nteam_id\n\nteam\n\nin\n\ndb\n\n\"teams\"\n\nitems\n\nvalidators\n\nInputRequired\n\npassword\n\nPasswordField\n\n\"Team password\"\n\nvalidators\n\nInputRequired\n\nsubmit\n\nSubmitField\n\n\"Join team\"\n\nIn this form, we're creating a drop-down box with the names of existing teams. The list comprehension in choices constructs a tuple for each team, consisting of the team's ID and name. This way, we can use the ID to identify teams on the backend while displaying the name to the user.\n\nOur last form is ChallengeSolveForm, which users will use to submit challenge solutions. Add it to the bottom of forms.py:\n\nclass\n\nChallengeSolveForm\n\nFlaskForm\n\ncode\n\nStringField\n\n\"Challenge code\"\n\nvalidators\n\nInputRequired\n\nsubmit\n\nSubmitField\n\n\"Submit solution code\"\n\nAs we'll be including this form on the individual challenge pages, we don't need to ask the user to specify which challenge they're solving.\n\nFinally, we'll need to import our forms and helper function into main.py so we can use them in the rest of our app. Add the following line to the import statements in main.py:\n\nfrom\n\nforms\n\nimport\n\nTeamCreateForm\n\nTeamJoinForm\n\nChallengeCreateForm\n\nChallengeSolveForm\n\nname_to_id\n\nNow that we have our form logic, we need to integrate them into both the front-end and back-end of the application. We'll deal with the back-end first.\n\nBuilding back-end functionality\u200b\n\nBack-end functionality is the heart of our application. Below, we'll define our application's routes and build the logic for creating and joining teams, as well as creating and solving challenges.\n\nTeam functionality\u200b\n\nLet's start with teams. We'll define the following routes and functions in main.py, below our index() function:\n\n# Teams\n\n@app\n\nroute\n\n\"/team-create\"\n\nmethods\n\n\"GET\"\n\n\"POST\"\n\n@web\n\nauthenticated\n\n@not_admin_only\n\n@not_team_only\n\ndef\n\nteam_create\n\npass\n\n@app\n\nroute\n\n\"/team-join\"\n\nmethods\n\n'GET'\n\n'POST'\n\n@web\n\nauthenticated\n\n@not_admin_only\n\n@not_team_only\n\ndef\n\nteam_join\n\npass\n\n@app\n\nroute\n\n\"/team/<team_id>\"\n\ndef\n\nteam\n\nteam_id\n\npass\n\nThe /team-create and /team-join routes will use their respective forms. Users already in teams and admins will not be permitted to create or join teams. The /team/<team_id> page will be an informational page, showing the team's name, score, and which challenges they've solved. We're using part of the URL as a parameter here, so, for example, /team/codeslingers will take us to the team page for that team. We won't require authentication for this page.\n\nBecause we'll be dealing with passwords, we're going to store them as one-way encrypted hashes. This will prevent anyone with access to our repl's database from easily seeing all team passwords. We'll use Flask's Bcrypt extension for this, which you can install by searching for \"flask-bcrypt\" in the Packages tab on the Replit IDE sidebar.\n\nWhile Replit usually automatically installs packages based on our import statements, this one must be manually installed, as its package name is slightly different on Pypi and on disk.", "start_char_idx": 9938, "end_char_idx": 13936, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06b20a78-ce61-47c8-b030-8200bbbabdba": {"__data__": {"id_": "06b20a78-ce61-47c8-b030-8200bbbabdba", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f8126eec-489c-4ec1-b80a-b132fe17f834", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "36658118049cd782a96b962fe92f0f5ebdb2c7e7ffc4ebfee62fccbf46a1678a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "947f38ef-3fbb-4d56-9a12-ab60e43a8a2c", "node_type": "1", "metadata": {}, "hash": "e30309be1825d4f2ae521fa1bd43c02463f241b2b9a1b3ad417cf290e9a8d988", "class_name": "RelatedNodeInfo"}}, "hash": "886c07bddb09510f8b00412222d51bd0060212c288a97bea84bd20052dc3f3ae", "text": "The /team/<team_id> page will be an informational page, showing the team's name, score, and which challenges they've solved. We're using part of the URL as a parameter here, so, for example, /team/codeslingers will take us to the team page for that team. We won't require authentication for this page.\n\nBecause we'll be dealing with passwords, we're going to store them as one-way encrypted hashes. This will prevent anyone with access to our repl's database from easily seeing all team passwords. We'll use Flask's Bcrypt extension for this, which you can install by searching for \"flask-bcrypt\" in the Packages tab on the Replit IDE sidebar.\n\nWhile Replit usually automatically installs packages based on our import statements, this one must be manually installed, as its package name is slightly different on Pypi and on disk. Once it's installed, we import it with the following additional line at the top of main.py:\n\nfrom\n\nflask_bcrypt\n\nimport\n\nBcrypt\n\nThen we initialize a Bcrypt object for our app by adding the following line just below app = Flask(__name__):\n\nbcrypt\n\nBcrypt\n\napp\n\nNow let's add some code to our team_create function:\n\n@app\n\nroute\n\n\"/team-create\"\n\nmethods\n\n\"GET\"\n\n\"POST\"\n\n@web\n\nauthenticated\n\n@not_admin_only\n\n@not_team_only\n\ndef\n\nteam_create\n\nform\n\nTeamCreateForm\n\nrequest\n\nform\n\nif\n\nrequest\n\nmethod\n\n==\n\n\"POST\"\n\nand\n\nform\n\nvalidate\n\nteam_name\n\nform\n\nname\n\ndata\n\nteam_id\n\nname_to_id\n\nteam_name\n\nhashed_password\n\nbcrypt\n\ngenerate_password_hash\n\nform\n\npassword\n\ndata\n\ndecode\n\n\"utf-8\"\n\nteam_leader\n\nweb\n\nauth\n\nname\n\n# Construct team dictionary\n\ndb\n\n\"teams\"\n\nteam_id\n\n\"name\"\n\nteam_name\n\n\"password\"\n\nhashed_password\n\n\"leader\"\n\nteam_leader\n\n\"members\"\n\nteam_leader\n\n\"score\"\n\n\"challenges_solved\"\n\n# Set user team\n\nusers\n\ncurrent\n\n\"team\"\n\nteam_id\n\nflash\n\n\"Team created!\"\n\nreturn\n\nredirect\n\nurl_for\n\n'team'\n\nteam_id\n\nteam_id\n\nreturn\n\nrender_template\n\n\"team-create.html\"\n\nform\n\nform\n\n**\n\ncontext\n\nFirst, we create an instance of TeamCreateForm using the values in request.form. We then check whether the current request is an HTTP POST, and we call validate() on the form. Behind the scenes, this method will run all of our field validators, and return error messages to the user for fields that fail validation. It will only return True once all fields validate.\n\nOnce we know we've got valid form input, we can save its data to our database. We construct our team's ID using the helper function from forms.py, hash our team password, and then define our team's dictionary.\n\nAfter that, we set the current user's team in our user database and redirect the user to their new team's page. We use users.current as an alias for users[web.auth.name].\n\nAt the bottom of the function, we render our team-create page and tell it which form to use. This will happen regardless of whether the initiating request was a GET or a POST. We'll create the template and define the context function when we build the front-end.\n\nNow we can add the code for joining a team, in the team_join function:\n\n@app\n\nroute\n\n\"/team-join\"\n\nmethods\n\n'GET'\n\n'POST'\n\n@web\n\nauthenticated\n\n@not_admin_only\n\n@not_team_only\n\ndef\n\nteam_join\n\nform\n\nTeamJoinForm\n\nrequest\n\nform\n\nif\n\nrequest\n\nmethod\n\n==\n\n\"POST\"\n\nand\n\nform\n\nvalidate\n\nteam_id\n\nform\n\nname\n\ndata\n\nteam_name\n\ndb\n\n\"teams\"\n\nteam_id\n\n\"name\"\n\nif\n\nbcrypt\n\ncheck_password_hash\n\ndb\n\n\"teams\"\n\nteam_id\n\n\"password\"\n\nform\n\npassword\n\ndata\n\ndb\n\n\"teams\"\n\nteam_id\n\n\"members\"\n\nappend\n\nweb\n\nauth\n\nname\n\nusers\n\ncurrent\n\n\"team\"\n\nteam_id\n\nflash\n\nf\"You joined\n\nteam_name\n\n!\"\n\nreturn\n\nredirect\n\nurl_for\n\n'team'\n\nteam_id\n\nteam_id\n\nelse\n\nflash\n\nf\"Wrong password for\n\nteam_name\n\n!\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nrender_template\n\n\"team-join.html\"\n\nform\n\nform\n\n**\n\ncontext\n\nIf our form validates, we check the provided team password, and if it's correct, we add the current user to the team and send them to the team page. If it's incorrect, we redirect them to the home page.", "start_char_idx": 13107, "end_char_idx": 17010, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "947f38ef-3fbb-4d56-9a12-ab60e43a8a2c": {"__data__": {"id_": "947f38ef-3fbb-4d56-9a12-ab60e43a8a2c", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "06b20a78-ce61-47c8-b030-8200bbbabdba", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "886c07bddb09510f8b00412222d51bd0060212c288a97bea84bd20052dc3f3ae", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bde3b8a1-f018-4577-b316-067e3e74de8a", "node_type": "1", "metadata": {}, "hash": "3d85d0113b308630baf85d220185e535f8917c0b06df25b3aab8b4d2ff9c1390", "class_name": "RelatedNodeInfo"}}, "hash": "e30309be1825d4f2ae521fa1bd43c02463f241b2b9a1b3ad417cf290e9a8d988", "text": "return\n\nredirect\n\nurl_for\n\n'team'\n\nteam_id\n\nteam_id\n\nelse\n\nflash\n\nf\"Wrong password for\n\nteam_name\n\n!\"\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nreturn\n\nrender_template\n\n\"team-join.html\"\n\nform\n\nform\n\n**\n\ncontext\n\nIf our form validates, we check the provided team password, and if it's correct, we add the current user to the team and send them to the team page. If it's incorrect, we redirect them to the home page.\n\nFinally, we can define our /team/<team_id> route, by adding this code to the team() function:\n\n@app\n\nroute\n\n\"/team/<team_id>\"\n\ndef\n\nteam\n\nteam_id\n\nreturn\n\nrender_template\n\n\"team.html\"\n\nteam_id\n\nteam_id\n\n**\n\ncontext\n\nAdmin functionality\u200b\n\nWe're going to let admin users add challenges to the front-end so that we can keep our code generic and re-use it for multiple competitions, if we wish. We'll add the other admin functionality we need at the same time.\n\nWe'll start with the challenge creation route. Add this code below your team routes:\n\n# Admin functions\n\n@app\n\nroute\n\n\"/admin/challenge-create\"\n\nmethods\n\n\"GET\"\n\n\"POST\"\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\nadmin_challenge_create\n\nform\n\nChallengeCreateForm\n\nrequest\n\nform\n\nif\n\nrequest\n\nmethod\n\n==\n\n\"POST\"\n\nand\n\nform\n\nvalidate\n\nchallenge_name\n\nform\n\nname\n\ndata\n\nchallenge_id\n\nname_to_id\n\nchallenge_name\n\nhashed_code\n\nbcrypt\n\ngenerate_password_hash\n\nform\n\ncode\n\ndata\n\ndecode\n\n\"utf-8\"\n\n# Construct challenge dictionary\n\ndb\n\n\"challenges\"\n\nchallenge_id\n\n\"name\"\n\nchallenge_name\n\n\"description\"\n\nform\n\ndescription\n\ndata\n\n\"points\"\n\nint\n\nform\n\npoints\n\ndata\n\n\"code\"\n\nhashed_code\n\nflash\n\n\"Challenge created!\"\n\nreturn\n\nredirect\n\nurl_for\n\n'challenge'\n\nchallenge_id\n\nchallenge_id\n\nreturn\n\nrender_template\n\n\"admin/challenge-create.html\"\n\nform\n\nform\n\n**\n\ncontext\n\nThis code is almost identical to our team creation functionality. While hashing challenge codes may not be strictly necessary, it will prevent any users with access to our repl from cheating by viewing the database.\n\nChallenge removal is a bit simpler:\n\n@app\n\nroute\n\n\"/admin/challenge-remove/<challenge_id>\"\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\nadmin_remove_challenge\n\nchallenge_id\n\n# Remove challenge from team solutions\n\nfor\n\nteam\n\nin\n\ndb\n\n\"teams\"\n\nitems\n\nif\n\nchallenge_id\n\nin\n\nteam\n\n\"challenges_solved\"\n\nteam\n\n\"challenges_solved\"\n\nremove\n\nchallenge_id\n\nteam\n\n\"score\"\n\n=\n\ndb\n\n\"challenges\"\n\nchallenge_id\n\n\"points\"\n\n# Delete challenge dictionary\n\ndel\n\ndb\n\n\"challenges\"\n\nchallenge_id\n\nflash\n\n\"Challenge removed!\"\n\nreturn\n\nredirect\n\nurl_for\n\n'index'\n\nWe'll allow admins to start and stop the competition with two routes that toggle a value in our database:\n\n@app\n\nroute\n\n\"/admin/competition-start\"\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\nadmin_start_competition\n\ndb\n\n\"competition_started\"\n\nTrue\n\nflash\n\n\"Competition started!\"\n\nreturn\n\nredirect\n\nurl_for\n\n'index'\n\n@app\n\nroute\n\n\"/admin/competition-stop\"\n\n@web\n\nauthenticated\n\n@admin_only\n\n@competition_running\n\ndef\n\nadmin_end_competition\n\ndb\n\n\"competition_started\"\n\nFalse\n\nflash\n\n\"Competition ended!\"\n\nreturn\n\nredirect\n\nurl_for\n\n'index'\n\nFinally, we'll define an admin route that deletes and reinitializes the application's general and user databases. This will be useful for running multiple competitions on the same app, and for debugging!\n\n@app\n\nroute\n\n'/admin/db-flush'\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\nflush_db\n\ndel\n\ndb\n\n\"challenges\"\n\ndel\n\ndb\n\n\"teams\"\n\ndel\n\ndb\n\n\"competition_started\"\n\nfor\n\nuser\n\nin\n\nusers\n\nitems\n\nuser\n\n\"team\"\n\nNone\n\ndb_init\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nIf we add any additional keys or values to either of our databases, we will need to remember to delete them in this function.\n\nChallenge functionality\u200b\n\nFinally, we need to add functionality that will allow users to solve challenges and score points.", "start_char_idx": 16601, "end_char_idx": 20308, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bde3b8a1-f018-4577-b316-067e3e74de8a": {"__data__": {"id_": "bde3b8a1-f018-4577-b316-067e3e74de8a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "947f38ef-3fbb-4d56-9a12-ab60e43a8a2c", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "e30309be1825d4f2ae521fa1bd43c02463f241b2b9a1b3ad417cf290e9a8d988", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "663c3e86-99bc-4fac-9821-a726e1d7a927", "node_type": "1", "metadata": {}, "hash": "5b4be74bc08b89cefc1209f63d75eff6bff16d0eb885e9f6d68e3798af423255", "class_name": "RelatedNodeInfo"}}, "hash": "3d85d0113b308630baf85d220185e535f8917c0b06df25b3aab8b4d2ff9c1390", "text": "return\n\nredirect\n\nurl_for\n\n'index'\n\nFinally, we'll define an admin route that deletes and reinitializes the application's general and user databases. This will be useful for running multiple competitions on the same app, and for debugging!\n\n@app\n\nroute\n\n'/admin/db-flush'\n\n@web\n\nauthenticated\n\n@admin_only\n\ndef\n\nflush_db\n\ndel\n\ndb\n\n\"challenges\"\n\ndel\n\ndb\n\n\"teams\"\n\ndel\n\ndb\n\n\"competition_started\"\n\nfor\n\nuser\n\nin\n\nusers\n\nitems\n\nuser\n\n\"team\"\n\nNone\n\ndb_init\n\nreturn\n\nredirect\n\nurl_for\n\n\"index\"\n\nIf we add any additional keys or values to either of our databases, we will need to remember to delete them in this function.\n\nChallenge functionality\u200b\n\nFinally, we need to add functionality that will allow users to solve challenges and score points. Add the following code below your admin routes:\n\n# Challenge functionality\n\n@app\n\nroute\n\n\"/challenge/<challenge_id>\"\n\nmethods\n\n\"GET\"\n\n\"POST\"\n\n@web\n\nauthenticated\n\n@competition_running\n\ndef\n\nchallenge\n\nchallenge_id\n\nform\n\nChallengeSolveForm\n\nrequest\n\nform\n\nif\n\nrequest\n\nmethod\n\n==\n\n\"POST\"\n\nand\n\nform\n\nvalidate\n\nif\n\nbcrypt\n\ncheck_password_hash\n\ndb\n\n\"challenges\"\n\nchallenge_id\n\n\"code\"\n\nform\n\ncode\n\ndata\n\ndb\n\n\"teams\"\n\nusers\n\ncurrent\n\n\"team\"\n\n\"challenges_solved\"\n\nappend\n\nchallenge_id\n\ndb\n\n\"teams\"\n\nusers\n\ncurrent\n\n\"team\"\n\n\"score\"\n\n+=\n\ndb\n\n\"challenges\"\n\nchallenge_id\n\n\"points\"\n\nflash\n\n\"Challenge solved!\"\n\nelse\n\nflash\n\n\"Wrong challenge code!\"\n\nreturn\n\nrender_template\n\n\"challenge.html\"\n\nform\n\nform\n\nchallenge_id\n\nchallenge_id\n\n**\n\ncontext\n\nThis function is very similar to team_join(). The main difference is that we will be hosting this form on the challenge description page, so we can fetch the challenge_id from the URL rather than asking the user which challenge they're submitting a code for in the form.\n\nBuilding the web application front-end\u200b\n\nWe have a fully functional application back-end, but without some front-end pages, our users will have to join teams and submit challenge solutions using curl. So let's create an interface for our back-end using HTML and Jinja, Flask's powerful front-end templating language.\n\nCreating the HTML templates\u200b\n\nFirst, we'll need the following HTML files in a new directory called templates:\n\ntemplates/\n\n|__ admin/\n\n|     |__  challenge-create.html\n\n|__  _macros.html\n\n|__  challenge.html\n\n|__  index.html\n\n|__  layout.html\n\n|__  leaderboard.html\n\n|__  team-create.html\n\n|__  team-join.html\n\n|__  team.html\n\nOnce you've created these files, let's populate them, starting with templates/layout.html:\n\n<!\n\nDOCTYPE\n\nhtml\n\nhtml\n\nhead\n\ntitle\n\nChallenge Leaderboard\n\n</\n\ntitle\n\n</\n\nhead\n\nbody\n\n{% with messages = get_flashed_messages() %} {% if messages %}\n\nul\n\nclass\n\nflashes\n\n{% for message in messages %}\n\nli\n\n{{ message }}\n\n</\n\nli\n\n{% endfor %}\n\n</\n\nul\n\n{% endif %} {% endwith %} {% if name != None %}\n\nLogged in as {{ username }}\n\n</\n\n{% endif %}\n\nul\n\nli\n\nhref\n\nView challenges\n\n</\n\n</\n\nli\n\nli\n\nhref\n\n/leaderboard\n\nView leaderboard\n\n</\n\n</\n\nli\n\nli\n\nhref\n\n/team-create\n\nCreate team\n\n</\n\n</\n\nli\n\nli\n\nhref\n\n/team-join\n\nJoin team\n\n</\n\n</\n\nli\n\n</\n\nul\n\n{% block body %}{% endblock %}\n\n</\n\nbody\n\n</\n\nhtml\n\nWe'll use this file as the base of all our pages, so we don't need to repeat the same HTML. It contains features we want on every page, such as flashed messages, an indication of who's currently logged in, and a global navigation menu. All subsequent pages will inject content into the body block:\n\n{% block body %}{% endblock %}\n\nNext, we need to populate another helper file, templates/_macros.html:\n\n{% macro render_field(field) %}\n\ndt\n\n{{ field.label }}\n\n</\n\ndt\n\ndd\n\n{{ field(**kwargs)|safe }} {% if field.errors %}\n\nul\n\nclass\n\nerrors\n\n{% for error in field.errors %}\n\nli\n\n{{ error }}\n\n</\n\nli\n\n{% endfor %}\n\n</\n\nul\n\n{% endif %}\n\n</\n\ndd\n\n{% endmacro %}\n\nThis file defines the Jinja macro render_field, which we'll use to give all our form fields their own error-handling, provided by WTForms.\n\nLet's define our home page now, with a list of challenges.", "start_char_idx": 19569, "end_char_idx": 23506, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "663c3e86-99bc-4fac-9821-a726e1d7a927": {"__data__": {"id_": "663c3e86-99bc-4fac-9821-a726e1d7a927", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bde3b8a1-f018-4577-b316-067e3e74de8a", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "3d85d0113b308630baf85d220185e535f8917c0b06df25b3aab8b4d2ff9c1390", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e994fe01-966a-4842-936e-dd5da0f9c7ae", "node_type": "1", "metadata": {}, "hash": "56cf2d5c2ebcbaf4106c86ef890abc00ba18689a854a55a225465ac0cbf7fed3", "class_name": "RelatedNodeInfo"}}, "hash": "5b4be74bc08b89cefc1209f63d75eff6bff16d0eb885e9f6d68e3798af423255", "text": "It contains features we want on every page, such as flashed messages, an indication of who's currently logged in, and a global navigation menu. All subsequent pages will inject content into the body block:\n\n{% block body %}{% endblock %}\n\nNext, we need to populate another helper file, templates/_macros.html:\n\n{% macro render_field(field) %}\n\ndt\n\n{{ field.label }}\n\n</\n\ndt\n\ndd\n\n{{ field(**kwargs)|safe }} {% if field.errors %}\n\nul\n\nclass\n\nerrors\n\n{% for error in field.errors %}\n\nli\n\n{{ error }}\n\n</\n\nli\n\n{% endfor %}\n\n</\n\nul\n\n{% endif %}\n\n</\n\ndd\n\n{% endmacro %}\n\nThis file defines the Jinja macro render_field, which we'll use to give all our form fields their own error-handling, provided by WTForms.\n\nLet's define our home page now, with a list of challenges. Add the following code to templates/index.html:\n\n{% extends \"layout.html\" %} {% block body %}\n\nh1\n\nChallenges\n\n</\n\nh1\n\nul\n\n{% for id, challenge in challenges.items()|sort(attribute='1.points') %}\n\nli\n\nhref\n\n/challenge/{{ id }}\n\n{{ challenge.name }}\n\n</\n\n({{ challenge.points\n\n}} points) {% if admin %} |\n\nhref\n\n/admin/challenge-remove/{{ id }}\n\nDELETE\n\n</\n\n{% endif %}\n\n</\n\nli\n\nli\n\n{% endfor %} {% if admin %}\n\n</\n\nli\n\nli\n\nhref\n\n/admin/challenge-create\n\nNEW CHALLENGE...\n\n</\n\n</\n\nli\n\n{% endif %}\n\n</\n\nul\n\n{% if admin %}\n\nh1\n\nAdmin functions\n\n</\n\nh1\n\nul\n\n{% if competition_running %}\n\nli\n\nhref\n\n/admin/competition-stop\n\nEnd competition\n\n</\n\n</\n\nli\n\n{% else %}\n\nli\n\nhref\n\n/admin/competition-start\n\nStart competition\n\n</\n\n</\n\nli\n\n{% endif %}\n\nli\n\nhref\n\n/admin/db-flush\n\nFlush database\n\n</\n\n</\n\nli\n\n</\n\nul\n\n{% endif %} {% endblock %}\n\nHere, {% extends \"layout.html\" %} tells our templating engine to use layout.html as a base template, and {% block body %} ... {% endblock %} defines the code to place inside layout.html's body block.\n\nThe following line will sort challenges in ascending order of points:\n\n{% for id, challenge in challenges.items()|sort(attribute='1.points') %}\n\nIn addition, we use {% if admin %} blocks to include links to admin functionality that will only display when an admin is logged in.\n\nNext we define our team pages:\n\ntemplates/team-create.html\n\n{% extends \"layout.html\" %} {% block body %} {% from \"_macros.html\" import\n\nrender_field %}\n\nh1\n\nCreate team\n\n</\n\nh1\n\nform\n\naction\n\n/team-create\n\nmethod\n\npost\n\nenctype\n\nmultipart/form-data\n\n{{ render_field(form.name) }} {{ render_field(form.password) }} {{\n\nform.csrf_token }} {{ form.submit }}\n\n</\n\nform\n\n{% endblock %}\n\ntemplates/team-join.html\n\n{% extends \"layout.html\" %} {% block body %} {% from \"_macros.html\" import\n\nrender_field %}\n\nh1\n\nJoin team\n\n</\n\nh1\n\nform\n\naction\n\n/team-join\n\nmethod\n\npost\n\n{{ render_field(form.name) }} {{ render_field(form.password) }} {{\n\nform.csrf_token }} {{ form.submit }}\n\n</\n\nform\n\n{% endblock %}\n\ntemplates/team.html\n\n{% extends \"layout.html\" %} {% block body %}\n\nh1\n\n{{ teams[team_id].name }}\n\n</\n\nh1\n\nh2\n\nTeam members\n\n</\n\nh2\n\nul\n\n{% for user in teams[team_id].members %}\n\nli\n\n{{ user }}\n\n</\n\nli\n\n{% endfor %}\n\n</\n\nul\n\nh2\n\nChallenges solved\n\n</\n\nh2\n\nul\n\n{% for id in teams[team_id].challenges_solved %}\n\nli\n\nhref\n\n/challenge/\n\n{{\n\nid\n\n}}\n\n{{ challenges[id].name }}\n\n</\n\n</\n\nli\n\nli\n\n{% endfor %}\n\n</\n\nli\n\n</\n\nul\n\n{% endblock %}\n\nYou'll notice that we've imported our render_function macro on these pages and used it to show our various form fields. Each form also has a hidden field specified by {{ form.csrf_token }}. This is a security feature WTForms provides to prevent cross-site request forgery vulnerabilities.", "start_char_idx": 22743, "end_char_idx": 26235, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e994fe01-966a-4842-936e-dd5da0f9c7ae": {"__data__": {"id_": "e994fe01-966a-4842-936e-dd5da0f9c7ae", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "663c3e86-99bc-4fac-9821-a726e1d7a927", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "5b4be74bc08b89cefc1209f63d75eff6bff16d0eb885e9f6d68e3798af423255", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9236ba25-08c9-4a55-ab2b-385f5fb56d19", "node_type": "1", "metadata": {}, "hash": "b0d399425356ffc6685cb01dee76a81092ed2466413a8c6c8658a30ba5f6083f", "class_name": "RelatedNodeInfo"}}, "hash": "56cf2d5c2ebcbaf4106c86ef890abc00ba18689a854a55a225465ac0cbf7fed3", "text": "Each form also has a hidden field specified by {{ form.csrf_token }}. This is a security feature WTForms provides to prevent cross-site request forgery vulnerabilities.\n\nNow we can create our challenge page:\n\ntemplates/challenge.html\n\n{% extends \"layout.html\" %} {% block body %} {% from \"_macros.html\" import\n\nrender_field %}\n\nh1\n\n{{ challenges[challenge_id].name }}\n\n</\n\nh1\n\n{{ challenges[challenge_id].description }}\n\n</\n\nPoints: {{ challenges[challenge_id].points }}\n\n</\n\n</\n\n{% if user_team != None and challenge_id not in\n\nteams[user_team][\"challenges_solved\"] %}\n\nform\n\naction\n\n/challenge/{{challenge_id}}\n\nmethod\n\npost\n\n{{ render_field(form.code) }} {{ form.csrf_token }} {{ form.submit }}\n\n</\n\nform\n\n{% endif %} {% endblock %}\n\nThen our challenge creation page (inside the templates/admin directory):\n\ntemplates/admin/challenge-create.html\n\n{% extends \"layout.html\" %} {% block body %} {% from \"_macros.html\" import\n\nrender_field %}\n\nh1\n\nCreate challenge\n\n</\n\nh1\n\nform\n\naction\n\n/admin/challenge-create\n\nmethod\n\npost\n\nenctype\n\nmultipart/form-data\n\n{{ render_field(form.name) }} {{ render_field(form.description) }} {{\n\nrender_field(form.points) }} {{ render_field(form.code) }} {{ form.csrf_token\n\n}} {{ form.submit }}\n\n</\n\nform\n\n{% endblock %}\n\nunpack the return value of a function named\n\ndef\n\ncontext\n\nreturn\n\n\"username\"\n\nweb\n\nauth\n\nname\n\n\"user_team\"\n\nin_team\n\nweb\n\nauth\n\nname\n\n\"admin\"\n\nis_admin\n\nweb\n\nauth\n\nname\n\n\"teams\"\n\ndb\n\n\"teams\"\n\n\"challenges\"\n\ndb\n\n\"challenges\"\n\n\"competition_running\"\n\ndb\n\n\"competition_started\"\n\nThis will give every page most of the application's state. If we find we need another piece of state later, we can add it to the context helper function, and it will be available to all our pages.\n\nImportantly, we're using a function rather than a static dictionary so that we can get the most up-to-date application state every time we serve a page.\n\nBefore we move on, we should change our app's home page from the initial demo version we made at the beginning of this tutorial to a proper page. Find the index() function and replace it with this code:\n\n@app\n\nroute\n\n\"/\"\n\ndef\n\nindex\n\nreturn\n\nrender_template\n\n\"index.html\"\n\n**\n\ncontext\n\nYou'll notice we've removed the @web.authenticated decorator. This will allow unauthenticated users to get a glimpse of our site before being asked to log in. replit.web will prompt them to log in as soon as they attempt to access an authenticated page.\n\nBuilding the leaderboard\u200b\n\nWe've left out a key part of our application: the leaderboard showing which team is winning! Let's add the leaderboard frontend now, with the following HTML and Jinja code in templates/leaderboard.html:\n\n{% extends \"layout.html\" %} {% block body %}\n\nh1\n\nLeaderboard\n\n</\n\nh1\n\nul\n\n{% for id, team in teams.items()|sort(attribute='1.score', reverse=True) %}\n\n<li {% if id == user_team %}style=\"font-weight: bold\"{% endif %}>\n\nhref\n\n/team/{{ id }}\n\n{{ team.name }}\n\n</\n\n: {{ team.score }} points\n\nli\n\n{% endfor %}\n\n</\n\nli\n\n</\n\nul\n\n{% endblock %}\n\nSimilar to the list of challenges on our home page, we use Jinja's sort filter to order the teams from highest to lowest score.\n\n{% for id, team in teams.items()|sort(attribute='1.score', reverse=True) %}\n\nWe also use an if block to show the name of the current user's team in bold.\n\nFinally, we can add one last route to main.py, just above the line web.run(app):\n\n@app\n\nroute\n\n\"/leaderboard\"\n\ndef\n\nleaderboard\n\nreturn\n\nrender_template\n\n\"leaderboard.html\"\n\n**\n\ncontext\n\nWe're leaving this one unauthenticated as well, so that spectators can see how the competition's going.\n\nUsing the app\u200b\n\nWe're done! Run your repl now to see your app in action. As your user account will be a site admin, you may need to enlist a couple of friends to test out all the app's functionality.\n\nFor best results, open your repl's web page in a new tab.\n\nIf you run into unexplained errors, you may need to clear your browser cookies, or flush the database.\n\nWhere next?\u200b\n\nWe've built a CRUD application with a fair amount of functionality, but there's still room for improvement. Some things you might want to add include:\n\nCSS styling.", "start_char_idx": 26067, "end_char_idx": 30177, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9236ba25-08c9-4a55-ab2b-385f5fb56d19": {"__data__": {"id_": "9236ba25-08c9-4a55-ab2b-385f5fb56d19", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2b3667e4-8044-470e-9394-04038b39e6fa", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "49f1791cd23ca0a00c51cb163d9993d1154a3b2f10f93411c9e01efc947055ed", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e994fe01-966a-4842-936e-dd5da0f9c7ae", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}, "hash": "56cf2d5c2ebcbaf4106c86ef890abc00ba18689a854a55a225465ac0cbf7fed3", "class_name": "RelatedNodeInfo"}}, "hash": "b0d399425356ffc6685cb01dee76a81092ed2466413a8c6c8658a30ba5f6083f", "text": "Finally, we can add one last route to main.py, just above the line web.run(app):\n\n@app\n\nroute\n\n\"/leaderboard\"\n\ndef\n\nleaderboard\n\nreturn\n\nrender_template\n\n\"leaderboard.html\"\n\n**\n\ncontext\n\nWe're leaving this one unauthenticated as well, so that spectators can see how the competition's going.\n\nUsing the app\u200b\n\nWe're done! Run your repl now to see your app in action. As your user account will be a site admin, you may need to enlist a couple of friends to test out all the app's functionality.\n\nFor best results, open your repl's web page in a new tab.\n\nIf you run into unexplained errors, you may need to clear your browser cookies, or flush the database.\n\nWhere next?\u200b\n\nWe've built a CRUD application with a fair amount of functionality, but there's still room for improvement. Some things you might want to add include:\n\nCSS styling.\n\nMore admin functionality, such as adjusting scores, banning users and teams, and setting team size limitations.\n\nFile upload, for challenge files and/or team avatars.\n\nTime-limited competitions, with a countdown.\n\nBadges/achievements for things like being the first team to solve a given challenge.\n\nA place for teams to submit challenge solution write-ups.\n\nAnd of course, you can also use your site to host a competition right now.\n\nYou can find code for this tutorial here:\n\n< Previous: Steganography: hiding messages in images\n\nNext: Telegram bot >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting started\n\nCreating user roles\n\nBuilding forms\n\nBuilding back-end functionalityTeam functionalityAdmin functionalityChallenge functionality\n\nBuilding the web application front-endCreating the HTML templates\n\nBuilding the leaderboard\n\nUsing the app\n\nWhere next?", "start_char_idx": 29343, "end_char_idx": 31048, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"2b3667e4-8044-470e-9394-04038b39e6fa": {"node_ids": ["2751da25-e8f2-4d0d-a730-c706ee496852", "27e92265-725c-4453-8a3a-9b9d7b015ea1", "9a104f85-54ee-4f72-a7e9-41b3c764f679", "f8126eec-489c-4ec1-b80a-b132fe17f834", "06b20a78-ce61-47c8-b030-8200bbbabdba", "947f38ef-3fbb-4d56-9a12-ab60e43a8a2c", "bde3b8a1-f018-4577-b316-067e3e74de8a", "663c3e86-99bc-4fac-9821-a726e1d7a927", "e994fe01-966a-4842-936e-dd5da0f9c7ae", "9236ba25-08c9-4a55-ab2b-385f5fb56d19"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/technical-challenge-site.html"}}}, "docstore/metadata": {"2751da25-e8f2-4d0d-a730-c706ee496852": {"doc_hash": "d7bf92bdb91646b7ab00a9ab30dd523e40549b0fe32db943454b58757ddbca34", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "27e92265-725c-4453-8a3a-9b9d7b015ea1": {"doc_hash": "9f06f831d8b98399cc423f141a3c67c03dcb03e0185633a317f047d59eeb0a99", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "9a104f85-54ee-4f72-a7e9-41b3c764f679": {"doc_hash": "259ac69ab14e951a8a0de918241459ecac6a00111e77777d9638755cbaef434f", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "f8126eec-489c-4ec1-b80a-b132fe17f834": {"doc_hash": "36658118049cd782a96b962fe92f0f5ebdb2c7e7ffc4ebfee62fccbf46a1678a", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "06b20a78-ce61-47c8-b030-8200bbbabdba": {"doc_hash": "886c07bddb09510f8b00412222d51bd0060212c288a97bea84bd20052dc3f3ae", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "947f38ef-3fbb-4d56-9a12-ab60e43a8a2c": {"doc_hash": "e30309be1825d4f2ae521fa1bd43c02463f241b2b9a1b3ad417cf290e9a8d988", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "bde3b8a1-f018-4577-b316-067e3e74de8a": {"doc_hash": "3d85d0113b308630baf85d220185e535f8917c0b06df25b3aab8b4d2ff9c1390", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "663c3e86-99bc-4fac-9821-a726e1d7a927": {"doc_hash": "5b4be74bc08b89cefc1209f63d75eff6bff16d0eb885e9f6d68e3798af423255", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "e994fe01-966a-4842-936e-dd5da0f9c7ae": {"doc_hash": "56cf2d5c2ebcbaf4106c86ef890abc00ba18689a854a55a225465ac0cbf7fed3", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}, "9236ba25-08c9-4a55-ab2b-385f5fb56d19": {"doc_hash": "b0d399425356ffc6685cb01dee76a81092ed2466413a8c6c8658a30ba5f6083f", "ref_doc_id": "2b3667e4-8044-470e-9394-04038b39e6fa"}}}