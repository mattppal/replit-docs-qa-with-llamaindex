{"docstore/data": {"f9813a11-e701-4436-b0ca-fd1d8b159455": {"__data__": {"id_": "f9813a11-e701-4436-b0ca-fd1d8b159455", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17345704-6085-4a3b-a162-54a9c63778e3", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "aa52b8d45b011edc033069ff92fe13db24d6ad1c5113bb1a41046d6e5d3fe5b4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b8943482-e423-4c71-8d5f-04edeb655cb3", "node_type": "1", "metadata": {}, "hash": "87eb81c1e624f90083ad02cfab84793df2666c115128d14b247861551722462c", "class_name": "RelatedNodeInfo"}}, "hash": "80483beb1e19a893dc282054e9745bdd42c19c65a0332dc817371336238daddb", "text": "\"Viking Helmet\"\n\n];\n\nstring[] private eargear = [\n\n\"Bunny Ears\",\n\n\"Headphones\"\n\n];\n\nstring[] private facegear = [\n\n\"Sunglasses\",\n\n\"Moustache\",\n\n\"Nose\",\n\n\"DOOM Mask\"\n\n];\n\nFeel free to draw and add other accessories to these lists.\n\nNext, we'll create a struct for defining colors. Add this code below your array definitions:\n\nstruct Color {\n\nuint8 red;\n\nuint8 green;\n\nuint8 blue;\n\nEach color will have a red, green, and blue component, represented as an 8-bit unsigned integer. Most unsigned integers we work with in contracts are 256-bit, to the point that Solidity provides the alias uint for uint256. However, it is good practice to use smaller values where possible, due to gas costs \u2013 this is known as tight variable packing. An 8-bit unsigned integer can contain a value from 0 to 255, which is precisely the range we need for storing standard RGB values.\n\nNext, we'll create a struct for the ReplBot itself, consisting of our three colors and three accessories. Add this code below the previous struct definition:\n\nstruct ReplBot {\n\nColor frame;\n\nColor visor;\n\nColor background;\n\nuint8 head;\n\nuint8 ears;\n\nuint8 face;\n\nTo save space, we'll store our accessory values as indexes in the arrays we defined above. uint8 allows us to define a maximum of 255 accessories per type, which is more than enough.\n\nFinally, we'll define a mapping type that will allow us to associate numeric token IDs with ReplBot structs. Add this line below your last struct definition:\n\nmapping (uint => ReplBot) private replbots;\n\nMinting NFTs\u200b\n\nNow that we have our data structures in place, we can return to our mint function and expand it. Replace your mint() function's body with the following code:\n\nfunction mint(address recipient) public returns (uint256) {\n\n// Get ID and increment counter\n\nuint tokenId = tokenCounter;\n\ntokenCounter++;\n\n// Determine colors\n\nColor memory frameCol = Color(\n\nuint8(_random(tokenId, \"QWERT\") % 255),\n\nuint8(_random(tokenId, \"YUIOP\") % 255),\n\nuint8(_random(tokenId, \"ASDFG\") % 255));\n\nColor memory visorCol = Color(\n\nuint8(_random(tokenId, \"HJKL;\") % 255),\n\nuint8(_random(tokenId, \"ZXCVB\") % 255),\n\nuint8(_random(tokenId, \"BNM,.\") % 255));\n\nColor memory backgroundCol = Color(\n\nuint8(_random(tokenId, \"12345\") % 255),\n\nuint8(_random(tokenId, \"67890\") % 255),\n\nuint8(_random(tokenId, \"[]{}'\") % 255));\n\n// Determine accessories\n\nuint8 headIdx = uint8(_random(tokenId, \"qwert\") % headgear.length);\n\nuint8 earIdx = uint8(_random(tokenId, \"yuiop\") % eargear.length);\n\nuint8 faceIdx = uint8(_random(tokenId, \"asdfg\") % facegear.length);\n\n// Create bot\n\nreplbots[tokenId] = ReplBot(frameCol, visorCol, backgroundCol, headIdx, earIdx, faceIdx);\n\n// Mint token\n\n_safeMint(recipient, tokenId);\n\nreturn tokenId;\n\nThe bulk of this code consists of retrieving random numbers and using the modulo operator to convert them into a number in the range we need \u2013 for colors, this will be a number between 0 and 255, and for accessories, this will be a valid index in the relevant accessory array.\n\nWhen we define our Color structs, we specify the data location memory. The data location must be specified for all complex data types: arrays, structs, and strings. For variables that are local to a function, memory is usually correct.\n\nOnce that's done, we create the ReplBot struct, assign it to our token ID through the mapping, and then mint the token.\n\nHowever, if you try to compile this code, you'll notice that _random() is not defined. Unlike many traditional languages, Solidity has no native way of generating pseudorandom numbers. So we'll need to define one ourselves.\n\nRandomness in Ethereum contracts is a difficult thing to get right, and one that can be dangerous if done wrong, depending on what it's used for. If you've delved into randomness in other languages, you'll know that the random numbers we use in programming are usually only pseudorandom, originating from a predetermined seed, or based on the time of execution. This is okay when we're generating a Minecraft world, but presents problems for, say, a blockchain-based lottery.", "start_char_idx": 0, "end_char_idx": 4059, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b8943482-e423-4c71-8d5f-04edeb655cb3": {"__data__": {"id_": "b8943482-e423-4c71-8d5f-04edeb655cb3", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17345704-6085-4a3b-a162-54a9c63778e3", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "aa52b8d45b011edc033069ff92fe13db24d6ad1c5113bb1a41046d6e5d3fe5b4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f9813a11-e701-4436-b0ca-fd1d8b159455", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "80483beb1e19a893dc282054e9745bdd42c19c65a0332dc817371336238daddb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e6a869f-408a-4ba5-8e4b-0b6e571a5658", "node_type": "1", "metadata": {}, "hash": "10cb922b920bb674f60e4a62707dd6e6c403a662119cb1aff7f3a8922900f460", "class_name": "RelatedNodeInfo"}}, "hash": "87eb81c1e624f90083ad02cfab84793df2666c115128d14b247861551722462c", "text": "For variables that are local to a function, memory is usually correct.\n\nOnce that's done, we create the ReplBot struct, assign it to our token ID through the mapping, and then mint the token.\n\nHowever, if you try to compile this code, you'll notice that _random() is not defined. Unlike many traditional languages, Solidity has no native way of generating pseudorandom numbers. So we'll need to define one ourselves.\n\nRandomness in Ethereum contracts is a difficult thing to get right, and one that can be dangerous if done wrong, depending on what it's used for. If you've delved into randomness in other languages, you'll know that the random numbers we use in programming are usually only pseudorandom, originating from a predetermined seed, or based on the time of execution. This is okay when we're generating a Minecraft world, but presents problems for, say, a blockchain-based lottery. Because Ethereum is a transparent and distributed network, we have no way to hide a seed, and values like the current time can be manipulated by miners looking to profit.\n\nThe only foolproof way to generate random numbers at the moment is to use a trusted external source of randomness, such as Chainlink's VRF oracle (an oracle is a data feed built for use by smart contracts). However, as we're building on the Replit Testnet, we won't have access to such an oracle, so we'll need to settle for the best pseudorandomness we can get. If we were building a lottery contract, this would be a problem, but for this project, manipulation can only get you a slightly different-looking ReplBot.\n\nOur _random() function should be inserted below the mint() function. It looks like this:\n\nfunction _random(uint tokenId, string memory input) internal view returns (uint256) {\n\nbytes32 blckhash = blockhash(block.number - 1);\n\nreturn uint256(keccak256(abi.encodePacked(block.difficulty, blckhash, tokenId, abi.encodePacked(input))));\n\nThis is a view function because it does not change state. In the first line, we're getting the blockhash of the last block to be mined. In the second line, we use abi.encodePacked() to concatenate the following:\n\nThe blockhash we previously retrieved.\n\nThe difficulty of the current block.\n\nThe ID of the token we're minting.\n\nThe input string we passed in when calling _random().\n\nAll but the last of these values will be the same for every invocation of _random() in an individual mint() call. This is why we've specified different strings for each one.\n\nWe then hash our big chunk of data using keccak256(). A good hash function will return very different outputs given similar inputs, so this ensures that every call to _random() will return a sufficiently distinct result, even when most of the inputs are the same.\n\nFinally, we convert this hash into an unsigned integer, to be returned as our final \"random\" number.\n\nViewing token data\u200b\n\nNow that we can generate tokens with interesting-looking ReplBots, we need a way of retrieving information about them, so that we'll be able to display them on the web3 frontend we'll build in Part 2 of this tutorial. To this end, we'll write two functions: botAccessories and botColors. These will be externally callable view functions that will take the token ID and return three strings, detailing accessories and colors, respectively. As external calls to view functions are free, we don't have to worry too much about gas costs in these functions.\n\nEnter the following code between the definitions of mint() and _random():\n\nfunction botAccessories(uint256 tokenId) public view returns (string memory, string memory, string memory) {\n\nrequire(_exists(tokenId), \"ReplBots: Query for nonexistent token\");\n\nReplBot memory bot = replbots[tokenId];\n\nreturn (headgear[bot.head], eargear[bot.ears], facegear[bot.face]);\n\nOur function body starts with a require statement. This is an error-handling function in Solidity: If the condition in the first argument is not met, the current transaction will revert (undoing all previous actions) and the error message in the second argument will be displayed. In this instance, we're using it to prevent the details of unminted tokens from being queried.\n\nOnce we've confirmed that tokenId is valid, we retrieve its associated ReplBot struct. Solidity allows us to return multiple values from a function, which we use to return three different strings.\n\nNow let's create botColors().", "start_char_idx": 3166, "end_char_idx": 7552, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0e6a869f-408a-4ba5-8e4b-0b6e571a5658": {"__data__": {"id_": "0e6a869f-408a-4ba5-8e4b-0b6e571a5658", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17345704-6085-4a3b-a162-54a9c63778e3", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "aa52b8d45b011edc033069ff92fe13db24d6ad1c5113bb1a41046d6e5d3fe5b4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b8943482-e423-4c71-8d5f-04edeb655cb3", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "87eb81c1e624f90083ad02cfab84793df2666c115128d14b247861551722462c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dd8e97b4-a404-4eb3-bf45-deaf9635bea1", "node_type": "1", "metadata": {}, "hash": "ec5323ffae9af2eb68e25dadb0d6747636cf25b1569577f9f8fafd487ceee6a4", "class_name": "RelatedNodeInfo"}}, "hash": "10cb922b920bb674f60e4a62707dd6e6c403a662119cb1aff7f3a8922900f460", "text": "This is an error-handling function in Solidity: If the condition in the first argument is not met, the current transaction will revert (undoing all previous actions) and the error message in the second argument will be displayed. In this instance, we're using it to prevent the details of unminted tokens from being queried.\n\nOnce we've confirmed that tokenId is valid, we retrieve its associated ReplBot struct. Solidity allows us to return multiple values from a function, which we use to return three different strings.\n\nNow let's create botColors(). Add the following code below the definition of botAccessories():\n\nfunction botColors(uint256 tokenId) public view returns (string memory, string memory, string memory) {\n\nrequire(_exists(tokenId), \"ReplBots: Query for nonexistent token\");\n\nReplBot memory bot = replbots[tokenId];\n\nreturn (_colorToString(bot.frame),\n\n_colorToString(bot.visor),\n\n_colorToString(bot.background));\n\nThis function is quite similar to botAccessories(), but as our colors are structs rather than strings, we will need to define a new function, _colorToString() to convert them. Let's do that now.\n\nAdd the following code below the definition of botColors():\n\nfunction _colorToString(Color memory color) internal pure returns (string memory) {\n\nstring[7] memory parts;\n\nparts = [\"(\",\n\ncolor.red.toString(),\n\n\",\",\n\ncolor.blue.toString(),\n\n\",\",\n\ncolor.green.toString(),\n\n\")\"];\n\nreturn string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6]));\n\nWhile Solidity does not currently have a string concatenation function, we can use abi.encodePacked on an array of strings to achieve the same result, similar to what we did in _random(). Solidity also doesn't have any syntactic sugar for expanding/splatting arrays into function arguments, so we have to specify each element individually.\n\nBut wait! Where does .toString() come from? If you try to compile this contract now, you'll find that this method is undefined.\n\nRather than being a Solidity built-in, this comes from the OpenZeppelin Strings library that we imported at the beginning of this tutorial. To use this library, we need to add the following line to our contract definition, right below contract ReplBots is ERC721Enumerable { :\n\nusing Strings for uint8;\n\nSolidity's using Library for type directive attaches all functions in the specified library to the specified type. When a library function is called on an object of that type, it will receive that object as its first parameter.\n\nTesting our contract\u200b\n\nNow that we've implemented our NFT's core functionality, it's time to deploy to the Replit Testnet and test it out. We'll use our repl's web interface to do this.\n\nFirst, run your repl. Once all of the dependencies are installed, you should see the Replit Ethereum web interface in your repl's browser. It looks like this:\n\nConnect your MetaMask wallet to the web interface and switch to the Replit Testnet. Then click the link to get 1 ETH for testing. Wait until 1 ETH shows up in your wallet balance on the top right of the page.\n\nNow you can deploy your contracts. Select \"ReplBots\" from the drop-down box and click \"Deploy\". Approve the MetaMask pop-up that appears.\n\nOnce this contract has been deployed, it will show up as an expandable box below the drop-down box. Expand it and take a look at all the different functions available.\n\nMint your first NFT by navigating to the mint function. Click on your wallet address in the top right corner of the page to copy it, and then paste it into the recipient field. Then run the function and approve the MetaMask pop-up that appears.\n\nAfter a few seconds, you should see a pop-up indicating that your transaction has gone through. Congratulations, you're the proud owner of a ReplBot NFT! Check out its colors and accessories by entering ID 0 into botColors and botAccessories.\n\nIf you mint again, you should receive a ReplBot with ID 1 and a different set of colors and accessories.\n\nBreeding bots\u200b\n\nWe can now mint ReplBots with random characteristics, which fulfills the specification we laid out at the start of this tutorial. But with a bit of additional code, we can introduce a second way to create ReplBots, breeding.\n\nFor our breed function, we'll accept two separate ReplBots owned by the caller and create a new one with the following characteristics:\n\nIts colors will be an equal mix of both parents.\n\nIts headgear will come from the first parent.", "start_char_idx": 6999, "end_char_idx": 11447, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dd8e97b4-a404-4eb3-bf45-deaf9635bea1": {"__data__": {"id_": "dd8e97b4-a404-4eb3-bf45-deaf9635bea1", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17345704-6085-4a3b-a162-54a9c63778e3", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "aa52b8d45b011edc033069ff92fe13db24d6ad1c5113bb1a41046d6e5d3fe5b4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e6a869f-408a-4ba5-8e4b-0b6e571a5658", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "10cb922b920bb674f60e4a62707dd6e6c403a662119cb1aff7f3a8922900f460", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "51fc886d-3d3d-4fac-a27e-b5601d8cca1b", "node_type": "1", "metadata": {}, "hash": "b9bbda5498127d99c665c89946c7a37dec14b667817502e3861d13e0ac665849", "class_name": "RelatedNodeInfo"}}, "hash": "ec5323ffae9af2eb68e25dadb0d6747636cf25b1569577f9f8fafd487ceee6a4", "text": "Then run the function and approve the MetaMask pop-up that appears.\n\nAfter a few seconds, you should see a pop-up indicating that your transaction has gone through. Congratulations, you're the proud owner of a ReplBot NFT! Check out its colors and accessories by entering ID 0 into botColors and botAccessories.\n\nIf you mint again, you should receive a ReplBot with ID 1 and a different set of colors and accessories.\n\nBreeding bots\u200b\n\nWe can now mint ReplBots with random characteristics, which fulfills the specification we laid out at the start of this tutorial. But with a bit of additional code, we can introduce a second way to create ReplBots, breeding.\n\nFor our breed function, we'll accept two separate ReplBots owned by the caller and create a new one with the following characteristics:\n\nIts colors will be an equal mix of both parents.\n\nIts headgear will come from the first parent.\n\nIts eargear will come from the second parent.\n\nIts facegear will be randomized.\n\nTo keep track of which bots are minted and which bots are bred, we'll add a few additional fields to our ReplBot struct. Go to the top of your contract and edit the struct to resemble the following:\n\nstruct ReplBot {\n\nColor frame;\n\nColor visor;\n\nColor background;\n\nuint8 head;\n\nuint8 ears;\n\nuint8 face;\n\nuint256 generation; // new field\n\nuint256 parentOneId; // new field\n\nuint256 parentTwoId; // new field\n\nWe'll store our bot's generation and both parent IDs. Bots created through mint will have 0 for all three of these values. To avoid making it look as though all minted bots have token 0 for both parents, we'll start the tokenCounter from 1. Edit its declaration (near the top of your contract) as follows:\n\nuint256 public tokenCounter = 1; // no more token 0\n\nThen we need to add three zeros to the creation of the ReplBot struct in mint(). Find and edit the line below:\n\n// Create bot\n\nreplbots[tokenId] = ReplBot(frameCol, visorCol, backgroundCol, headIdx, earIdx, faceIdx, 0, 0, 0); // <-- ZEROS ADDED\n\n// Mint token\n\n_safeMint(recipient, tokenId);\n\nreturn tokenId;\n\nNow we can start on our breed() function. Add the following code below the definition of mint():\n\nfunction breed(uint256 parentOneId, uint256 parentTwoId, address recipient) public returns (uint256) {\n\n// Require two parents\n\nrequire(parentOneId != parentTwoId, \"ReplBots: Parents must be separate bots\");\n\n// Check ownership\n\nrequire(ownerOf(parentOneId) == msg.sender, \"ReplBots: You don't own parent 1\");\n\nrequire(ownerOf(parentTwoId) == msg.sender, \"ReplBots: You don't own parent 2\");\n\nReplBot storage parentOne = replbots[parentOneId];\n\nReplBot storage parentTwo = replbots[parentTwoId];\n\n// Check age\n\nrequire(parentOne.generation == parentTwo.generation, \"ReplBots: Parents must belong to the same generation\");\n\nWe start our function off with some checks: The two parent IDs must be different, they must be owned by the function caller (msg.sender), and they must be in the same generation.\n\nNext comes our bot creation code, which will be similar to the code in our mint() function.", "start_char_idx": 10554, "end_char_idx": 13600, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "51fc886d-3d3d-4fac-a27e-b5601d8cca1b": {"__data__": {"id_": "51fc886d-3d3d-4fac-a27e-b5601d8cca1b", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17345704-6085-4a3b-a162-54a9c63778e3", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "aa52b8d45b011edc033069ff92fe13db24d6ad1c5113bb1a41046d6e5d3fe5b4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dd8e97b4-a404-4eb3-bf45-deaf9635bea1", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "ec5323ffae9af2eb68e25dadb0d6747636cf25b1569577f9f8fafd487ceee6a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9f9dd5fb-ca9e-4d40-9ca2-3b03d6f07570", "node_type": "1", "metadata": {}, "hash": "7b4e313fb2793192d50e316f453ef4d0ec38fefc6a722bd786f105aca18b937c", "class_name": "RelatedNodeInfo"}}, "hash": "b9bbda5498127d99c665c89946c7a37dec14b667817502e3861d13e0ac665849", "text": "Next comes our bot creation code, which will be similar to the code in our mint() function. Add the following code below the final require() statement in the breed function above:\n\n// Increment token counter\n\nuint tokenId = tokenCounter;\n\ntokenCounter++;\n\n// Interpolate colors\n\nColor memory frameCol = Color(_meanOfTwo(parentOne.frame.red, parentTwo.frame.red),\n\n_meanOfTwo(parentOne.frame.green, parentTwo.frame.green),\n\n_meanOfTwo(parentOne.frame.blue, parentTwo.frame.blue));\n\nColor memory visorCol = Color(_meanOfTwo(parentOne.visor.red, parentTwo.visor.red),\n\n_meanOfTwo(parentOne.visor.green, parentTwo.visor.green),\n\n_meanOfTwo(parentOne.visor.blue, parentTwo.visor.blue));\n\nColor memory backgroundCol = Color(_meanOfTwo(parentOne.background.red, parentTwo.background.red),\n\n_meanOfTwo(parentOne.background.green, parentTwo.background.green),\n\n_meanOfTwo(parentOne.background.blue, parentTwo.background.blue));\n\n// Choose accessories\n\nuint8 headIdx = parentOne.head;\n\nuint8 earIdx = parentTwo.ears;\n\nuint8 faceIdx = uint8(_random(tokenId, \"asdfg\") % facegear.length);\n\n// Create bot\n\nreplbots[tokenId] = ReplBot(frameCol, visorCol, backgroundCol, headIdx, earIdx, faceIdx, parentOne.generation + 1, parentOneId, parentTwoId);\n\n// Mint token\n\n_safeMint(recipient, tokenId);\n\nreturn tokenId;\n\nAll of our bot's colors and attributes are generated according to the breeding process we specified above. One last thing we'll need to do is define the _meanOfTwo() function we're using to determine the child bot's colors. Add the following code to the bottom of your contract, just below the definition of _random():\n\nfunction _meanOfTwo(uint8 first, uint8 second) internal pure returns (uint8) {\n\nreturn uint8((uint16(first) + uint16(second))/2);\n\nHere we convert first and second into uint16 values to prevent them from overflowing (which would cause our function to revert), divide the result by two, and return it as a uint8.\n\nLastly, we'll need to define a new view function to return the generation and parentage of individual tokens. Insert the definition of the following function, botParentage(), just below the definition of botColors():\n\nfunction botParentage(uint256 tokenId) public view returns (uint, uint, uint) {\n\nrequire(_exists(tokenId), \"ReplBots: Query for nonexistent token\");\n\nReplBot memory bot = replbots[tokenId];\n\nreturn (bot.generation, bot.parentOneId, bot.parentTwoId);\n\nCompile and deploy your contract as you did before. Because it's a new contract, you'll need to mint two new ReplBots before you can try out the breed function. Do so now, and check that your child bot (ID 2) looks as expected. Then call botParentage to check its generation and parents.\n\nAdding events\u200b\n\nOur contract is now fully functional, but there are a few niceties we can add, in the form of events. Events provide a user-friendly form of logging on the blockchain and are commonly used by dApps. It's considered best practice to emit events whenever a state change is made, so we should define events for our contract's two state-changing actions, minting and breeding.\n\nEvent definitions are commonly placed at the bottom of contracts. Add the following code just above your contract's final closing brace (}):\n\nevent ReplBotCreated(address recipient, uint tokenId);\n\nevent ReplBotBorn(address recipient, uint tokenId, uint parentOneId, uint parentTwoId, uint generation);\n\nThen insert an event emission near the end of your mint() function, as below:\n\n_safeMint(recipient, tokenId);\n\nemit ReplBotCreated(recipient, tokenId); // <-- NEW LINE\n\nreturn tokenId;\n\nAnd another one near the end of your breed() function:\n\n_safeMint(recipient, tokenId);\n\nemit ReplBotBorn(recipient, tokenId, parentOneId, parentTwoId, parentOne.generation + 1); // <-- NEW LINE\n\nreturn tokenId;\n\nNext steps\u200b\n\nWe're done with our contract code. In the second part of this tutorial, we'll build a dApp frontend for users to mint, view, and breed ReplBot NFTs. If you'd like to spend a bit more time exploring Solidity first, here are some ways you might want to change and expand this contract:\n\nAdd more accessories. You'll need to draw these yourself!\n\nRefactor the code to reduce the size of the contract and make individual functions more gas efficient.", "start_char_idx": 13509, "end_char_idx": 17750, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f9dd5fb-ca9e-4d40-9ca2-3b03d6f07570": {"__data__": {"id_": "9f9dd5fb-ca9e-4d40-9ca2-3b03d6f07570", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17345704-6085-4a3b-a162-54a9c63778e3", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "aa52b8d45b011edc033069ff92fe13db24d6ad1c5113bb1a41046d6e5d3fe5b4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "51fc886d-3d3d-4fac-a27e-b5601d8cca1b", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}, "hash": "b9bbda5498127d99c665c89946c7a37dec14b667817502e3861d13e0ac665849", "class_name": "RelatedNodeInfo"}}, "hash": "7b4e313fb2793192d50e316f453ef4d0ec38fefc6a722bd786f105aca18b937c", "text": "In the second part of this tutorial, we'll build a dApp frontend for users to mint, view, and breed ReplBot NFTs. If you'd like to spend a bit more time exploring Solidity first, here are some ways you might want to change and expand this contract:\n\nAdd more accessories. You'll need to draw these yourself!\n\nRefactor the code to reduce the size of the contract and make individual functions more gas efficient. One quick way to do this would be to change the visibility of the public functions to external.\n\nTweak the breeding algorithm.\n\nIntroduce a siring mechanism that allows users to breed ReplBots they don't own.\n\n< Previous: Robot NFT Part 2: Frontend\n\nNext: Smart contract oracle with Solidity >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting startedSolidity replBrowser wallet\n\nIntroduction to smart contract development\n\nNFT design\n\nContract code scaffold\n\nNFT data structures\n\nMinting NFTs\n\nViewing token data\n\nTesting our contract\n\nBreeding bots\n\nAdding events\n\nNext steps", "start_char_idx": 17339, "end_char_idx": 18336, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"17345704-6085-4a3b-a162-54a9c63778e3": {"node_ids": ["f9813a11-e701-4436-b0ca-fd1d8b159455", "b8943482-e423-4c71-8d5f-04edeb655cb3", "0e6a869f-408a-4ba5-8e4b-0b6e571a5658", "dd8e97b4-a404-4eb3-bf45-deaf9635bea1", "51fc886d-3d3d-4fac-a27e-b5601d8cca1b", "9f9dd5fb-ca9e-4d40-9ca2-3b03d6f07570"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft.html"}}}, "docstore/metadata": {"f9813a11-e701-4436-b0ca-fd1d8b159455": {"doc_hash": "80483beb1e19a893dc282054e9745bdd42c19c65a0332dc817371336238daddb", "ref_doc_id": "17345704-6085-4a3b-a162-54a9c63778e3"}, "b8943482-e423-4c71-8d5f-04edeb655cb3": {"doc_hash": "87eb81c1e624f90083ad02cfab84793df2666c115128d14b247861551722462c", "ref_doc_id": "17345704-6085-4a3b-a162-54a9c63778e3"}, "0e6a869f-408a-4ba5-8e4b-0b6e571a5658": {"doc_hash": "10cb922b920bb674f60e4a62707dd6e6c403a662119cb1aff7f3a8922900f460", "ref_doc_id": "17345704-6085-4a3b-a162-54a9c63778e3"}, "dd8e97b4-a404-4eb3-bf45-deaf9635bea1": {"doc_hash": "ec5323ffae9af2eb68e25dadb0d6747636cf25b1569577f9f8fafd487ceee6a4", "ref_doc_id": "17345704-6085-4a3b-a162-54a9c63778e3"}, "51fc886d-3d3d-4fac-a27e-b5601d8cca1b": {"doc_hash": "b9bbda5498127d99c665c89946c7a37dec14b667817502e3861d13e0ac665849", "ref_doc_id": "17345704-6085-4a3b-a162-54a9c63778e3"}, "9f9dd5fb-ca9e-4d40-9ca2-3b03d6f07570": {"doc_hash": "7b4e313fb2793192d50e316f453ef4d0ec38fefc6a722bd786f105aca18b937c", "ref_doc_id": "17345704-6085-4a3b-a162-54a9c63778e3"}}}