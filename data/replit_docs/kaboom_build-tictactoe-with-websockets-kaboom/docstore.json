{"docstore/data": {"ecbf8f12-f9d4-4424-b86c-fbecb20d4535": {"__data__": {"id_": "ecbf8f12-f9d4-4424-b86c-fbecb20d4535", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "77376030-5e54-4339-8a91-8071c8b28bd5", "node_type": "1", "metadata": {}, "hash": "95c1d0e231cbd0ef57e1f7d36dad890f89c364bb82b995d73e14fb6007fd6901", "class_name": "RelatedNodeInfo"}}, "hash": "662546ddc100f32f8eef6280d7718737960a092081cf789b62b631fe41338c68", "text": "WAITING: We are waiting for all the players to join the game.\n\nPLAYING: The players can make moves on the board.\n\nDRAW: The game has ended in a draw.\n\nWIN: A player has won the game.\n\nNow let's add a game state object to track everything:\n\nlet\n\ngameState\n\nboard\n\nnew\n\nArray\n\nfill\n\nnull\n\ncurrentPlayer\n\nnull\n\nplayers\n\nresult\n\nstatus\n\nStatuses\n\nWAITING\n\nFirst, we have a representation of the tic-tac-toe board as an array with 9 elements. This is how the array elements are mapped to the board:\n\nEach number in the blocks represents the index at which the board position is represented in the array. Initially, we fill all the elements of the array with null to indicate that the block is open. When players make a move to occupy an open space, we'll add a reference to the player instead. That way we can keep track of which blocks are empty, and which are occupied by which player.\n\nNext, we have currentPlayer, which we will alternately set to each player when it's their turn to move.\n\nThen there is an array called players, which will hold references to both of the players in the game. This will allow us to show the names of the players on screen, as well as generally keep track of the players.\n\nThe result field is updated after every move. This field will contain the status of the game (as we defined above). As it's represented as an object, it will also be able to hold extra fields. We'll use that functionality to add a reference to the winner of the game, if the game ends in a win.\n\nAccepting connections\u200b\n\nWhen a player connects via WebSocket, Sockets.IO will fire a connection event. We can listen for this event and handle tracking the connection, as well as creating listeners for other custom events. There are a few custom events we can define here, that our players will emit:\n\naddPlayer: We'll use this event for a player to request joining the game.\n\naction: This is used when a player wants to make a move.\n\nrematch: Used when a game is over, but the players want to play again.\n\nWe can also listen for the built-in disconnect event, which will alert us if a player leaves the game (for example, by closing the browser window or if their internet connection is lost).\n\nLet's add the code that will hook up our listeners to the events:\n\nio\n\non\n\n\"connection\"\n\nfunction\n\nconnection\n\nconnection\n\non\n\n\"addPlayer\"\n\naddPlayer\n\nconnection\n\nid\n\nconnection\n\non\n\n\"action\"\n\naction\n\nconnection\n\nid\n\nconnection\n\non\n\n\"rematch\"\n\nrematch\n\nconnection\n\nid\n\nconnection\n\non\n\n\"disconnect\"\n\ndisconnect\n\nconnection\n\nid\n\nNext we'll implement each of these listener functions, starting with addPlayer.\n\nSide Note: Normally in examples for custom listeners, you'll see the handler code added immediately with an anonymous function, like this:\n\nio\n\non\n\n\"connection\"\n\nfunction\n\nconnection\n\nconnection\n\non\n\n\"addPlayer\"\n\ndata\n\n=>\n\n// some code here\n\nconnection\n\non\n\n\"action\"\n\ndata\n\n=>\n\n// some code here\n\n// etc ...\n\nThis is convenient, especially when there are a couple of handlers, each with only a small amount of code. It's also handy because in each of the handler functions, you still have access to the connection object, which is not passed on each event. However, it can get a little messy and unwieldy if there are many event handlers, with more complex logic in each.\n\nWe're doing it differently so that we can separate the handlers into functions elsewhere in the code base. We do have one problem to solve though: if they are separate functions, how will they access the connection parameter in such a way that we can tell which player sent the command? With the concept of closures, which are well-supported in Javascript, we can make functions that return another function. In this way, we can pass in the connection.id parameter to the first wrapping function, and it can return another function that takes the data arguments from the Socket.IO event caller. Because the second function is within the closure of the first, it will have access to the connection.id parameter.", "start_char_idx": 0, "end_char_idx": 3986, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "77376030-5e54-4339-8a91-8071c8b28bd5": {"__data__": {"id_": "77376030-5e54-4339-8a91-8071c8b28bd5", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ecbf8f12-f9d4-4424-b86c-fbecb20d4535", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "662546ddc100f32f8eef6280d7718737960a092081cf789b62b631fe41338c68", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6c3b197f-621a-4fbb-ab1f-0d6b010d301c", "node_type": "1", "metadata": {}, "hash": "4ab76f135598edbb6f3485c191d4b9ab99de7854cd272f3265ae96b88334a634", "class_name": "RelatedNodeInfo"}}, "hash": "95c1d0e231cbd0ef57e1f7d36dad890f89c364bb82b995d73e14fb6007fd6901", "text": "It's also handy because in each of the handler functions, you still have access to the connection object, which is not passed on each event. However, it can get a little messy and unwieldy if there are many event handlers, with more complex logic in each.\n\nWe're doing it differently so that we can separate the handlers into functions elsewhere in the code base. We do have one problem to solve though: if they are separate functions, how will they access the connection parameter in such a way that we can tell which player sent the command? With the concept of closures, which are well-supported in Javascript, we can make functions that return another function. In this way, we can pass in the connection.id parameter to the first wrapping function, and it can return another function that takes the data arguments from the Socket.IO event caller. Because the second function is within the closure of the first, it will have access to the connection.id parameter. The pattern looks like this:\n\nio\n\non\n\n\"connection\"\n\nfunction\n\nconnection\n\nconnection\n\non\n\n\"addPlayer\"\n\naddPlayer\n\nconnection\n\nid\n\nconnection\n\non\n\n\"action\"\n\naction\n\nconnection\n\nid\n\n// etc ...\n\nfunction\n\naddPlayer\n\nsocketId\n\nreturn\n\ndata\n\n=>\n\n// code here\n\nfunction\n\naction\n\nsocketId\n\nreturn\n\ndata\n\n=>\n\n// code here\n\nHandling new players\u200b\n\nAdd the following function to handle adding players:\n\nfunction\n\naddPlayer\n\nsocketId\n\nreturn\n\ndata\n\n=>\n\nconst\n\nnumberOfPlayers\n\ngameState\n\nplayers\n\nlength\n\nif\n\nnumberOfPlayers\n\n>=\n\nreturn\n\nlet\n\nnextSymbol\n\n\"X\"\n\nif\n\nnumberOfPlayers\n\n===\n\nif\n\ngameState\n\nplayers\n\nsymbol\n\n===\n\n\"X\"\n\nnextSymbol\n\n\"O\"\n\nconst\n\nnewPlayer\n\nplayerName\n\ndata\n\nplayerName\n\nid\n\nsocketId\n\nsymbol\n\nnextSymbol\n\ngameState\n\nplayers\n\npush\n\nnewPlayer\n\nif\n\ngameState\n\nplayers\n\nlength\n\n===\n\ngameState\n\nresult\n\nstatus\n\nStatuses\n\nPLAYING\n\ngameState\n\ncurrentPlayer\n\nnewPlayer\n\nio\n\nemit\n\n\"gameState\"\n\ngameState\n\nThis function does quite a bit. Let's go through the main features.\n\nFirst it checks to see how many players are already in the game. If there are already 2 players, it returns early without changing anything. If this check passes, it goes on to add a new player. Note that even when there is no space in the game for a new player, we don't disconnect the player - they still get updates and can watch the match.\n\nNext, the function figures out which symbol, X or O, the new player should be. It will assign X to the first player. If there is already a player, and the existing player's symbol is X, then it will assign O to the new player. Note that there is a possible case where there is only one player, and their symbol is O. This would occur if there are 2 players, and the player with the X symbol disconnects from the game, leaving only the player with the O symbol. This is why we always check what symbol the existing player in the game has.\n\nThen the function constructs a new player object with some identifying information, including the name that the player sends through, the socketId they connected on, and their symbol. When a new player requests to join, we expect them to send an object with a field playerName to tell us their handle.\n\nNow we add the new player to the player array in our gameState object, so that they are part of the game.\n\nWe go on to check if we have 2 players, and start playing if we do. We begin by updating the status of the game to PLAYING, and set the currentPlayer, i.e. the player who is first to go, as the latest player to have joined.\n\nFinally, we use the Socket.IO emit function to send the updated gameState to all connections. This will allow them to update the players' displays.\n\nHandling player actions\u200b\n\nThe next handler takes care of the moves players make. We expect that the incoming data from the player will have a property called gridIndex to indicate which block on the board the player wants to mark. This should be a number that maps to the numbers for each block in the board, as in the picture earlier on.", "start_char_idx": 3019, "end_char_idx": 6968, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c3b197f-621a-4fbb-ab1f-0d6b010d301c": {"__data__": {"id_": "6c3b197f-621a-4fbb-ab1f-0d6b010d301c", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "77376030-5e54-4339-8a91-8071c8b28bd5", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "95c1d0e231cbd0ef57e1f7d36dad890f89c364bb82b995d73e14fb6007fd6901", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "52c7e2d3-2309-4e95-843a-00ec22e9d2c8", "node_type": "1", "metadata": {}, "hash": "2f963e47fbfe0118fe7ebd4c1d1f0128fa61a2d8bbec4b63b34304e1173bfd4c", "class_name": "RelatedNodeInfo"}}, "hash": "4ab76f135598edbb6f3485c191d4b9ab99de7854cd272f3265ae96b88334a634", "text": "Now we add the new player to the player array in our gameState object, so that they are part of the game.\n\nWe go on to check if we have 2 players, and start playing if we do. We begin by updating the status of the game to PLAYING, and set the currentPlayer, i.e. the player who is first to go, as the latest player to have joined.\n\nFinally, we use the Socket.IO emit function to send the updated gameState to all connections. This will allow them to update the players' displays.\n\nHandling player actions\u200b\n\nThe next handler takes care of the moves players make. We expect that the incoming data from the player will have a property called gridIndex to indicate which block on the board the player wants to mark. This should be a number that maps to the numbers for each block in the board, as in the picture earlier on.\n\nfunction\n\naction\n\nsocketId\n\nreturn\n\ndata\n\n=>\n\nif\n\ngameState\n\nresult\n\nstatus\n\n===\n\nStatuses\n\nPLAYING\n\n&&\n\ngameState\n\ncurrentPlayer\n\nid\n\n===\n\nsocketId\n\nconst\n\nplayer\n\ngameState\n\nplayers\n\nfind\n\n=>\n\nid\n\n===\n\nsocketId\n\nif\n\ngameState\n\nboard\n\ndata\n\ngridIndex\n\n==\n\nnull\n\ngameState\n\nboard\n\ndata\n\ngridIndex\n\nplayer\n\ngameState\n\ncurrentPlayer\n\ngameState\n\nplayers\n\nfind\n\n=>\n\n!==\n\nplayer\n\ncheckForEndOfGame\n\nio\n\nemit\n\n\"gameState\"\n\ngameState\n\nIn this function, we check a couple of things first:\n\nThe game status must be PLAYING - players can't make moves if the game is in any other state.\n\nThe player attempting to make the move must be the currentPlayer, i.e. the player whose turn it is to go.\n\nIf these conditions are met, we find the player in the gameState.players array using the built-in find method on arrays, by looking for the player by their socketId.\n\nNow we can check if the board position (gridIndex) requested by the player is available. We check that the value for that position in the gameState.board array is null, and if it is, we assign the player to it.\n\nThe player has made a successful move, so we give the other player a turn. We switch the gameState.currentPlayer to the other player by using the array find method again, to get the player who does not match the current player.\n\nWe also need to check if the move the player made changed the status of the game. Did that move make them win the game, or is it a draw, or is the game still in play? We call out to a function checkForEndOfGame to check for this. We'll implement this function a little later, after we're done with all the handlers.\n\nFinally, we send out the latest gameState to all the players (and spectators) to update the game UI.\n\nHandling a rematch request\u200b\n\nLet's make it possible for a player to challenge their opponent to a rematch when the game has ended:\n\nfunction\n\nrematch\n\nsocketId\n\nreturn\n\ndata\n\n=>\n\nif\n\ngameState\n\nplayers\n\nfindIndex\n\n=>\n\nid\n\n===\n\nsocketId\n\nreturn\n\n// Don't let spectators rematch\n\nif\n\ngameState\n\nresult\n\nstatus\n\n===\n\nStatuses\n\nWIN\n\n||\n\ngameState\n\nresult\n\nstatus\n\n===\n\nStatuses\n\nDRAW\n\nresetGame\n\nio\n\nemit\n\n\"gameState\"\n\ngameState\n\nThis function first checks if the connection sending the rematch request is actually one of the players, and not just a spectator. If we can't find a match for a player, we return immediately, making no changes.\n\nThen we check if the game is in one of the final states, either WIN or DRAW. If it is, we call out to a function resetGame to set up the game again. Finally, we send out the latest gameState to all the players.\n\nLet's implement the resetGame function:\n\nfunction\n\nresetGame\n\ngameState\n\nboard\n\nnew\n\nArray\n\nfill\n\nnull\n\nif\n\ngameState\n\nplayers\n\nlength\n\n===\n\ngameState\n\nresult\n\nstatus\n\nStatuses\n\nPLAYING\n\nconst\n\nrandPlayer\n\nMath\n\nfloor\n\nMath\n\nrandom\n\ngameState\n\nplayers\n\nlength\n\ngameState\n\ncurrentPlayer\n\ngameState\n\nplayers\n\nrandPlayer\n\nelse\n\ngameState\n\nresult\n\nstatus\n\nStatuses\n\nWAITING\n\ngameState\n\ncurrentPlayer\n\nnull\n\nLet's take a look at what we're doing here:\n\nFirst, our function creates a new array for the gameState board. This effectively clears the board, setting all the positions back to null, or empty.\n\nThen it checks that there are still 2 players connected.", "start_char_idx": 6149, "end_char_idx": 10187, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "52c7e2d3-2309-4e95-843a-00ec22e9d2c8": {"__data__": {"id_": "52c7e2d3-2309-4e95-843a-00ec22e9d2c8", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6c3b197f-621a-4fbb-ab1f-0d6b010d301c", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "4ab76f135598edbb6f3485c191d4b9ab99de7854cd272f3265ae96b88334a634", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d5704410-46e2-4dad-ae4a-ab6f39764b17", "node_type": "1", "metadata": {}, "hash": "1705c6594645d64cc55e57324c10de9ef1b0198f28fb44b66a66b430f5f62a74", "class_name": "RelatedNodeInfo"}}, "hash": "2f963e47fbfe0118fe7ebd4c1d1f0128fa61a2d8bbec4b63b34304e1173bfd4c", "text": "If it is, we call out to a function resetGame to set up the game again. Finally, we send out the latest gameState to all the players.\n\nLet's implement the resetGame function:\n\nfunction\n\nresetGame\n\ngameState\n\nboard\n\nnew\n\nArray\n\nfill\n\nnull\n\nif\n\ngameState\n\nplayers\n\nlength\n\n===\n\ngameState\n\nresult\n\nstatus\n\nStatuses\n\nPLAYING\n\nconst\n\nrandPlayer\n\nMath\n\nfloor\n\nMath\n\nrandom\n\ngameState\n\nplayers\n\nlength\n\ngameState\n\ncurrentPlayer\n\ngameState\n\nplayers\n\nrandPlayer\n\nelse\n\ngameState\n\nresult\n\nstatus\n\nStatuses\n\nWAITING\n\ngameState\n\ncurrentPlayer\n\nnull\n\nLet's take a look at what we're doing here:\n\nFirst, our function creates a new array for the gameState board. This effectively clears the board, setting all the positions back to null, or empty.\n\nThen it checks that there are still 2 players connected. If there are, it sets the game status back to PLAYING and chooses at random which player's turn it is to go. We choose the first player randomly so that there isn't one player getting an advantage by going first every time.\n\nIf there is only one player remaining, we set the game status to WAITING instead, and listen for any new players who want to join. We also set the currentPlayer to null, as we will choose which player should go once the new player has joined.\n\nHandling disconnects\u200b\n\nThe last handler we need to implement is if a connection to a player is lost. This could be because the player has exited the game (by closing the browser tab), or has other internet issues.\n\nfunction\n\ndisconnect\n\nsocketId\n\nreturn\n\nreason\n\n=>\n\ngameState\n\nplayers\n\ngameState\n\nplayers\n\nfilter\n\n=>\n\nid\n\n!=\n\nsocketId\n\nif\n\ngameState\n\nplayers\n\n!==\n\nresetGame\n\nio\n\nemit\n\n\"gameState\"\n\ngameState\n\nThis function uses the built-in array filter function to remove the player that disconnected from the server. Since it's possible that the disconnect event isn't from a player but from a spectator, we check the number of players left after filtering the disconnecting socket from the player list. If there aren't 2 players remaining after filtering, we reset the game and send out the updated game state.\n\nChecking for the end of the game\u200b\n\nNow we can get back to implementing the checkForEndOfGame() function we referenced in the action handler.\n\nWe're only interested in detecting 2 cases: A win or a draw.\n\nThere are just 8 patterns that determine if a player has won at tic-tac-toe. Let's map them to our board with its indexed blocks:\n\nWe can encode each of these winning patterns into an array of 3 numbers each. Then we can add each of those patterns to a larger array, like this:\n\nconst\n\nwinPatterns\n\nNow that we have each winning pattern in an array, we can loop through each of them to see if there is a player that has positions that match any of the patterns.\n\nSince the players are also in an array in gameState.players, we can loop through that array, and check each player against the winning pattern array. If a player matches any of these patterns, we can change the game status to WIN and set that player as the winner in the results.\n\nHere is the code to do that:\n\nfunction\n\ncheckForEndOfGame\n\n// Check for a win\n\ngameState\n\nplayers\n\nforEach\n\nplayer\n\n=>\n\nwinPatterns\n\nforEach\n\nseq\n\n=>\n\nif\n\ngameState\n\nboard\n\nseq\n\n==\n\nplayer\n\n&&\n\ngameState\n\nboard\n\nseq\n\n==\n\nplayer\n\n&&\n\ngameState\n\nboard\n\nseq\n\n==\n\nplayer\n\ngameState\n\nresult\n\nstatus\n\nStatuses\n\nWIN\n\ngameState\n\nresult\n\nwinner\n\nplayer\n\n// Check for a draw\n\nif\n\ngameState\n\nresult\n\nstatus\n\n!=\n\nStatuses\n\nWIN\n\nconst\n\nemptyBlock\n\ngameState\n\nboard\n\nindexOf\n\nnull\n\nif\n\nemptyBlock\n\n==\n\ngameState\n\nresult\n\nstatus\n\nStatuses\n\nDRAW\n\nindexOf to find any\n\nNow we have all the functionality we need on the server, let's move on to building the Kaboom website the players will use to play the game.\n\nSetting up Kaboom\u200b\n\nTo start, we need to set up Kaboom with the screen size and colors we want for the game window. Replace the code in main.js with the code below:\n\nimport\n\nkaboom\n\nfrom\n\n\"kaboom\"\n\nkaboom\n\nbackground\n\nwidth\n\n1000\n\nheight\n\n600\n\nThis creates a new Kaboom canvas with a black background.\n\nSetting up Kaboom with Socket.IO\u200b\n\nNow we can add a reference to Socket.IO.", "start_char_idx": 9397, "end_char_idx": 13494, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d5704410-46e2-4dad-ae4a-ab6f39764b17": {"__data__": {"id_": "d5704410-46e2-4dad-ae4a-ab6f39764b17", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "52c7e2d3-2309-4e95-843a-00ec22e9d2c8", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "2f963e47fbfe0118fe7ebd4c1d1f0128fa61a2d8bbec4b63b34304e1173bfd4c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "592f4d81-068f-442d-b881-6b5648b11f2a", "node_type": "1", "metadata": {}, "hash": "5fff0900a96b55a263f98e08d3b5bec47a7ec15e88c4ee92dfedab24b4227b69", "class_name": "RelatedNodeInfo"}}, "hash": "1705c6594645d64cc55e57324c10de9ef1b0198f28fb44b66a66b430f5f62a74", "text": "Setting up Kaboom\u200b\n\nTo start, we need to set up Kaboom with the screen size and colors we want for the game window. Replace the code in main.js with the code below:\n\nimport\n\nkaboom\n\nfrom\n\n\"kaboom\"\n\nkaboom\n\nbackground\n\nwidth\n\n1000\n\nheight\n\n600\n\nThis creates a new Kaboom canvas with a black background.\n\nSetting up Kaboom with Socket.IO\u200b\n\nNow we can add a reference to Socket.IO. Normally, in a plain HTML project, we could add a <script> tag and reference the Socket.IO client script, hosted automatically on our game server. However, here we will add the script programmatically. We can do this by accessing the document object available in every browser, and insert a new element with our script. Add the following code to the main.js file below the code to initialise Kaboom.\n\nlet\n\nscript\n\ndocument\n\ncreateElement\n\n\"script\"\n\nscript\n\nsrc\n\n\"https://tic-tac-toe-server--<YOUR_USER_NAME>.repl.co\"\n\n\"/socket.io/socket.io.js\"\n\ndocument\n\nhead\n\nappendChild\n\nscript\n\nReplace the <YOUR_USER_NAME> part of the URL with your Replit username. This code inserts the new <script> tag into the <head> section of the underlying HTML page that Kaboom runs in.\n\nLet's move on to creating the relevant scenes for our game. Kaboom \"scenes\" allow us to group logic and levels together. In this game we'll have 2 scenes:\n\nA \"startGame\" scene that will prompt for the player's name.\n\nA \"main\" scene, which will contain all the logic to play the tic-tac-toe game.\n\nLet's move on to the code to prompt the player to enter their name.\n\nscene\n\n\"startGame\"\n\n=>\n\nconst\n\nSCREEN_WIDTH\n\n1000\n\nconst\n\nSCREEN_HEIGHT\n\n600\n\nadd\n\ntext\n\n\"What's your name? \"\n\nsize\n\n32\n\nfont\n\n\"sinko\"\n\npos\n\nSCREEN_WIDTH\n\nSCREEN_HEIGHT\n\norigin\n\n\"center\"\n\nconst\n\nnameField\n\nadd\n\ntext\n\n\"\"\n\nsize\n\n32\n\nfont\n\n\"sinko\"\n\npos\n\nSCREEN_WIDTH\n\nSCREEN_HEIGHT\n\norigin\n\n\"center\"\n\ncharInput\n\nch\n\n=>\n\nnameField\n\ntext\n\n+=\n\nch\n\nkeyRelease\n\n\"enter\"\n\n=>\n\ngo\n\n\"main\"\n\nplayerName\n\nnameField\n\ntext\n\ngo\n\n\"startGame\"\n\nTo keep the calculations for the UI layout simpler, we'll use a fixed size for the screen. That's where the 2 constants for the screen width and height come in.\n\nadd function to display the prompt \"What's your name?\" on the screen, using the\n\ntext component. We choose a position halfway across the screen,\n\norigin component, set to\n\nThen we add another object with an empty \"\" text component. This will display the characters the player types in. We position it exactly halfway down and across the screen. We also hold a reference to the object in the constant nameField.\n\nTo get the user's keyboard input, we use the Kaboom function charInput. This function calls an event handler each time a key on the keyboard is pressed. We take that character and append it to the text in the nameField object. Now, when a player presses a key to enter their name, it will show up on the screen.\n\nFinally, we use the Kaboom function keyRelease to listen for when the player pushes the enter key. We'll take that as meaning they have finished entering their name and want to start the game. In the handler, we use the Kaboom go function to redirect to the main scene of the game.\n\nAdding the game board\u200b\n\nNow we can add the UI elements for the game itself. Create the \"main\" scene in your Kaboom repl by adding the following code to draw the tic-tac-toe board:\n\nscene\n\n\"main\"\n\nplayerName\n\n=>\n\n// Board\n\nadd\n\nrect\n\n400\n\npos\n\n233\n\n100\n\nadd\n\nrect\n\n400\n\npos\n\n366\n\n100\n\nadd\n\nrect\n\n400\n\npos\n\n100\n\n233\n\nadd\n\nrect\n\n400\n\npos\n\n100\n\n366\n\nThis adds 4 rectangles with a width of 1 pixel and length of 400 pixels to the screen - each rectangle is more like a line. This is how we draw the lines that create the classic tic-tac-toe board shape. The first 2 rectangles are the vertical lines, and the second 2 are the horizontal lines. We place the board closer to the left side of the screen, instead of the center, to save space for game information to be displayed on the right hand side of the screen.", "start_char_idx": 13116, "end_char_idx": 17031, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "592f4d81-068f-442d-b881-6b5648b11f2a": {"__data__": {"id_": "592f4d81-068f-442d-b881-6b5648b11f2a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d5704410-46e2-4dad-ae4a-ab6f39764b17", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "1705c6594645d64cc55e57324c10de9ef1b0198f28fb44b66a66b430f5f62a74", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4128df84-42f8-4ca9-a005-ab9d37f8b9b7", "node_type": "1", "metadata": {}, "hash": "67ccd890a79c076dd21faacf960f9948770dc5f470923ae163c58c73c1dd4c68", "class_name": "RelatedNodeInfo"}}, "hash": "5fff0900a96b55a263f98e08d3b5bec47a7ec15e88c4ee92dfedab24b4227b69", "text": "Create the \"main\" scene in your Kaboom repl by adding the following code to draw the tic-tac-toe board:\n\nscene\n\n\"main\"\n\nplayerName\n\n=>\n\n// Board\n\nadd\n\nrect\n\n400\n\npos\n\n233\n\n100\n\nadd\n\nrect\n\n400\n\npos\n\n366\n\n100\n\nadd\n\nrect\n\n400\n\npos\n\n100\n\n233\n\nadd\n\nrect\n\n400\n\npos\n\n100\n\n366\n\nThis adds 4 rectangles with a width of 1 pixel and length of 400 pixels to the screen - each rectangle is more like a line. This is how we draw the lines that create the classic tic-tac-toe board shape. The first 2 rectangles are the vertical lines, and the second 2 are the horizontal lines. We place the board closer to the left side of the screen, instead of the center, to save space for game information to be displayed on the right hand side of the screen.\n\nIf you run the game, and enter your name, you should see the board layout like this:\n\nNow we need to add a way to draw the X and O symbols in each block. To do this, we'll add objects with text components in each block of the board. First, we'll make an array containing the location and size of each block. Add the following code snippets within the \"main\" scene we created above:\n\nconst\n\nboardSquares\n\nindex\n\n100\n\n100\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n233\n\n100\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n366\n\n100\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n100\n\n233\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n233\n\n233\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n366\n\n233\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n100\n\n366\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n233\n\n366\n\nwidth\n\n133\n\nheight\n\n133\n\nindex\n\n366\n\n366\n\nwidth\n\n133\n\nheight\n\n133\n\nWe can run through this array and create a text object that we can write to when we want to update the symbols on the board. Let's create a function to do that.\n\nfunction\n\ncreateTextBoxesForGrid\n\nboardSquares\n\nforEach\n\nsquare\n\n=>\n\nlet\n\nsquare\n\nsquare\n\nwidth\n\n0.5\n\nlet\n\nsquare\n\nsquare\n\nheight\n\n0.5\n\nsquare\n\ntextBox\n\nadd\n\ntext\n\n\"\"\n\n40\n\npos\n\norigin\n\n\"center\"\n\ncreateTextBoxesForGrid\n\nforEach method to loop through each \"square\" definition in the\n\nadd a new text object to the screen, and also add it to the square definition on the field\n\nFinally, we call the function to create the text boxes.\n\nAdding player names and game status\u200b\n\nNow let's add some areas for the player's names and for the current status of the game (whose turn it is to play, if someone has won, or if it's a draw).\n\n// Players and game status elements\n\nconst\n\nplayerOneLabel\n\nadd\n\ntext\n\n\"\"\n\nsize\n\n20\n\nfont\n\n\"sinko\"\n\npos\n\n600\n\n100\n\nconst\n\nplayerTwoLabel\n\nadd\n\ntext\n\n\"\"\n\nsize\n\n20\n\nfont\n\n\"sinko\"\n\npos\n\n600\n\n150\n\nconst\n\nstatusLabel\n\nadd\n\ntext\n\n\"\"\n\nsize\n\n20\n\nfont\n\n\"sinko\"\n\npos\n\n600\n\n200\n\ncolor\n\n255\n\nHere we add 3 objects with text components. The first 2 are placeholders for the player names and symbols. The third one is for the game status. They are positioned to the right of the screen, and contain empty text to start. We'll change the contents as we receive new game states from the server. The last object has a color component to set the color of the text to green. This is to make the status message stand out from the rest of the text.\n\nConnecting to the server\u200b\n\nTo connect to the game server, we need to initialize the Socket.IO library we dynamically added earlier. We need to provide the URL to the server repl, so copy that from the output window of the server repl:\n\nNow add this code along with the server URL to the \"main\" scene in the player repl:\n\nvar\n\nsocket\n\nio\n\n\"https://tic-tac-toe-server--<YOUR_USER_NAME>.repl.co\"\n\nsocket\n\non\n\n\"connect\"\n\nfunction\n\nsocket\n\nemit\n\n\"addPlayer\"\n\nplayerName\n\nplayerName\n\nIn the first line, we initialize the Socket.IO client library to connect to the server. Then we add a listener to the connect event. This lets us know when we have established a connection to the server.", "start_char_idx": 16299, "end_char_idx": 20012, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4128df84-42f8-4ca9-a005-ab9d37f8b9b7": {"__data__": {"id_": "4128df84-42f8-4ca9-a005-ab9d37f8b9b7", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "592f4d81-068f-442d-b881-6b5648b11f2a", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "5fff0900a96b55a263f98e08d3b5bec47a7ec15e88c4ee92dfedab24b4227b69", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d58ab79f-4964-41ba-8a67-590ef3dedcfb", "node_type": "1", "metadata": {}, "hash": "d1ebb46ce10773b0f76a64eae203335411c004d1f7cf3a6b67f713534b493e2b", "class_name": "RelatedNodeInfo"}}, "hash": "67ccd890a79c076dd21faacf960f9948770dc5f470923ae163c58c73c1dd4c68", "text": "The last object has a color component to set the color of the text to green. This is to make the status message stand out from the rest of the text.\n\nConnecting to the server\u200b\n\nTo connect to the game server, we need to initialize the Socket.IO library we dynamically added earlier. We need to provide the URL to the server repl, so copy that from the output window of the server repl:\n\nNow add this code along with the server URL to the \"main\" scene in the player repl:\n\nvar\n\nsocket\n\nio\n\n\"https://tic-tac-toe-server--<YOUR_USER_NAME>.repl.co\"\n\nsocket\n\non\n\n\"connect\"\n\nfunction\n\nsocket\n\nemit\n\n\"addPlayer\"\n\nplayerName\n\nplayerName\n\nIn the first line, we initialize the Socket.IO client library to connect to the server. Then we add a listener to the connect event. This lets us know when we have established a connection to the server.\n\nIf we have a connection, we then emit an event to the server, with our custom event type addPlayer. We also add in the player name, which we passed to this scene from the startGame scene. Emitting the addPlayer event to the server will cause the addPlayer event handler to fire on the server side, adding the player to the game, and emitting back the game state.\n\nHandling updated game state\u200b\n\nRemember that our server emits a gameState event whenever something changes in the game. We'll listen for that event, and update all the UI elements in an event handler.\n\nFirst, we need to add the definitions of each status as we have done on the server side, so that we can easily reference them in the code:\n\nconst\n\nStatuses\n\nWAITING\n\n\"waiting\"\n\nPLAYING\n\n\"playing\"\n\nDRAW\n\n\"draw\"\n\nWIN\n\n\"win\"\n\nNow we can add a listener and event handler:\n\nsocket\n\non\n\n\"gameState\"\n\nfunction\n\nstate\n\nfor\n\nlet\n\nindex\n\nindex\n\nstate\n\nboard\n\nlength\n\nindex\n\n++\n\nconst\n\nplayer\n\nstate\n\nboard\n\nindex\n\nif\n\nplayer\n\n!=\n\nnull\n\nboardSquares\n\nindex\n\ntextBox\n\ntext\n\nplayer\n\nsymbol\n\nelse\n\nboardSquares\n\nindex\n\ntextBox\n\ntext\n\n\"\"\n\nstatusLabel\n\ntext\n\n\"\"\n\nswitch\n\nstate\n\nresult\n\nstatus\n\ncase\n\nStatuses\n\nWAITING\n\nstatusLabel\n\ntext\n\n\"Waiting for players....\"\n\nbreak\n\ncase\n\nStatuses\n\nPLAYING\n\nstatusLabel\n\ntext\n\nstate\n\ncurrentPlayer\n\nplayerName\n\n\" to play\"\n\nbreak\n\ncase\n\nStatuses\n\nDRAW\n\nstatusLabel\n\ntext\n\n\"Draw! \\nPress R for rematch\"\n\nbreak\n\ncase\n\nStatuses\n\nWIN\n\nstatusLabel\n\ntext\n\nstate\n\nresult\n\nwinner\n\nplayerName\n\n\" Wins! \\nPress R for rematch\"\n\nbreak\n\ndefault\n\nbreak\n\nplayerOneLabel\n\ntext\n\n\"\"\n\nplayerTwoLabel\n\ntext\n\n\"\"\n\nif\n\nstate\n\nplayers\n\nlength\n\nplayerOneLabel\n\ntext\n\nstate\n\nplayers\n\nsymbol\n\n\": \"\n\nstate\n\nplayers\n\nplayerName\n\nif\n\nstate\n\nplayers\n\nlength\n\nplayerTwoLabel\n\ntext\n\nstate\n\nplayers\n\nsymbol\n\n\": \"\n\nstate\n\nplayers\n\nplayerName\n\nThis function looks quite long, but it's mainly just updating the text boxes we added.\n\nFirst, we loop through the board positions array that is passed from the server on the state payload, to check each block for a player positioned on it. If there is a player on a block, we write that player's symbol to the corresponding text box, found in the boardSquares array we created above. If there is no player in the block, i.e it's a null value, we write an empty string to the text block.\n\nThen we update the statusLabel to show what is currently happening in the game. We use a switch statement to create logic for each of the possibilities. We write a different message to the statusLabel text box depending on the status, drawing from data in the gameState object.\n\nNext we update the player name text boxes. First we reset them, in case one of the players has dropped out. Then we update the text boxes with the players' symbols and names. Note that we first check if there are the corresponding players in the array.\n\nNow that we're done with updating from the game state, let's try running the game again. Open the game window in a new tab so that requests to the repl server don't get blocked by the browser due to the CORS header 'Access-Control-Allow-Origin' not matching in the embedded window.\n\nMake sure the server is also running, and enter your name. You should see something like this:\n\nYou can connect to your game in another browser tab, and enter another name.", "start_char_idx": 19181, "end_char_idx": 23286, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d58ab79f-4964-41ba-8a67-590ef3dedcfb": {"__data__": {"id_": "d58ab79f-4964-41ba-8a67-590ef3dedcfb", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "7483e0c78cd4a1f13ed6cb1e63c7c9cc08431c44dcb524b1c7ddbd0891b9a64d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4128df84-42f8-4ca9-a005-ab9d37f8b9b7", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}, "hash": "67ccd890a79c076dd21faacf960f9948770dc5f470923ae163c58c73c1dd4c68", "class_name": "RelatedNodeInfo"}}, "hash": "d1ebb46ce10773b0f76a64eae203335411c004d1f7cf3a6b67f713534b493e2b", "text": "We use a switch statement to create logic for each of the possibilities. We write a different message to the statusLabel text box depending on the status, drawing from data in the gameState object.\n\nNext we update the player name text boxes. First we reset them, in case one of the players has dropped out. Then we update the text boxes with the players' symbols and names. Note that we first check if there are the corresponding players in the array.\n\nNow that we're done with updating from the game state, let's try running the game again. Open the game window in a new tab so that requests to the repl server don't get blocked by the browser due to the CORS header 'Access-Control-Allow-Origin' not matching in the embedded window.\n\nMake sure the server is also running, and enter your name. You should see something like this:\n\nYou can connect to your game in another browser tab, and enter another name. Then you should see both names come up, and the status message change to allow a player to make a move. Of course, we haven't yet implemented the code to enable making a move from the UI, so let's do that now.\n\nHandling player moves\u200b\n\nWe want a player to be able to click on a block to place their move. Kaboom has a function onMouseRelease that we can use to handle mouse click events. All we need then is the position the mouse cursor is at, and we can map that to one of the board positions using our boardSquares array to do the lookup. We'll use the Kaboom function mousePos to get the coordinates of the mouse:\n\nonMouseRelease\n\n=>\n\nconst\n\nmpos\n\nmousePos\n\n// find the square we clicked on\n\nfor\n\nlet\n\nindex\n\nindex\n\nboardSquares\n\nlength\n\nindex\n\n++\n\nconst\n\nsquare\n\nboardSquares\n\nindex\n\nif\n\nmpos\n\nsquare\n\n&&\n\nmpos\n\nsquare\n\nsquare\n\nwidth\n\n&&\n\nmpos\n\nsquare\n\n&&\n\nmpos\n\nsquare\n\nsquare\n\nheight\n\nsocket\n\nemit\n\n\"action\"\n\ngridIndex\n\nsquare\n\nindex\n\nbreak\n\nIf we find a 'hit' on one of the board squares, we emit our action event. We pass the index of the square that was clicked on as the payload data. The server listens for this event, and runs the logic we added for the action event on the server side. If the action changes the game state, the server will send back the new game state, and the UI elements update.\n\ncharInput to listen for key press events. We'll check if the key is\n\ncharInput\n\nch\n\n=>\n\nif\n\nch\n\n===\n\n\"r\"\n\n||\n\nch\n\n===\n\n\"R\"\n\nsocket\n\nemit\n\n\"rematch\"\n\nnull\n\nNow you can run the game (and the server), and open the game in another tab, and you should be able to play tic-tac-toe against yourself! Send a link to the game to a friend, and see if they can join and play against you.\n\nNext Steps\u200b\n\nNow that you know the basics of creating a multiplayer online game, try your hand at making some different games, like checkers or chess or go.\n\nHappy coding!\n\nTic-tac-toe repl\u200b\n\nTic-tac-toe server repl\u200b\n\n< Previous: Space Shooter with Kaboom.js\n\nNext: Conway's Game of Life with Kaboom.js >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nHow do multiplayer games work?\n\nCreating a new project\n\nSetting up Socket.IO on the server\n\nTracking the game state\n\nAccepting connections\n\nHandling new players\n\nHandling player actions\n\nHandling a rematch request\n\nHandling disconnects\n\nChecking for the end of the game\n\nSetting up Kaboom\n\nSetting up Kaboom with Socket.IO\n\nAdding the game board\n\nAdding player names and game status\n\nConnecting to the server\n\nHandling updated game state\n\nHandling player moves\n\nNext Steps\n\nTic-tac-toe repl\n\nTic-tac-toe server repl", "start_char_idx": 22378, "end_char_idx": 25847, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"4f41115b-cfa4-45d7-a84c-4b7891fbed48": {"node_ids": ["ecbf8f12-f9d4-4424-b86c-fbecb20d4535", "77376030-5e54-4339-8a91-8071c8b28bd5", "6c3b197f-621a-4fbb-ab1f-0d6b010d301c", "52c7e2d3-2309-4e95-843a-00ec22e9d2c8", "d5704410-46e2-4dad-ae4a-ab6f39764b17", "592f4d81-068f-442d-b881-6b5648b11f2a", "4128df84-42f8-4ca9-a005-ab9d37f8b9b7", "d58ab79f-4964-41ba-8a67-590ef3dedcfb"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-tictactoe-with-websockets-kaboom.html"}}}, "docstore/metadata": {"ecbf8f12-f9d4-4424-b86c-fbecb20d4535": {"doc_hash": "662546ddc100f32f8eef6280d7718737960a092081cf789b62b631fe41338c68", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}, "77376030-5e54-4339-8a91-8071c8b28bd5": {"doc_hash": "95c1d0e231cbd0ef57e1f7d36dad890f89c364bb82b995d73e14fb6007fd6901", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}, "6c3b197f-621a-4fbb-ab1f-0d6b010d301c": {"doc_hash": "4ab76f135598edbb6f3485c191d4b9ab99de7854cd272f3265ae96b88334a634", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}, "52c7e2d3-2309-4e95-843a-00ec22e9d2c8": {"doc_hash": "2f963e47fbfe0118fe7ebd4c1d1f0128fa61a2d8bbec4b63b34304e1173bfd4c", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}, "d5704410-46e2-4dad-ae4a-ab6f39764b17": {"doc_hash": "1705c6594645d64cc55e57324c10de9ef1b0198f28fb44b66a66b430f5f62a74", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}, "592f4d81-068f-442d-b881-6b5648b11f2a": {"doc_hash": "5fff0900a96b55a263f98e08d3b5bec47a7ec15e88c4ee92dfedab24b4227b69", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}, "4128df84-42f8-4ca9-a005-ab9d37f8b9b7": {"doc_hash": "67ccd890a79c076dd21faacf960f9948770dc5f470923ae163c58c73c1dd4c68", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}, "d58ab79f-4964-41ba-8a67-590ef3dedcfb": {"doc_hash": "d1ebb46ce10773b0f76a64eae203335411c004d1f7cf3a6b67f713534b493e2b", "ref_doc_id": "4f41115b-cfa4-45d7-a84c-4b7891fbed48"}}}