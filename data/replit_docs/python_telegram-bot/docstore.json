{"docstore/data": {"d22fca00-ccd2-4da1-a582-f2a45d3507e3": {"__data__": {"id_": "d22fca00-ccd2-4da1-a582-f2a45d3507e3", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "12968328-f1a0-46a6-91be-56fdc84355bd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "hash": "f8bcefd4124c628cabfe558f5c2187ab557fea5340be9b867a735ad8d6311c2f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8aa15327-13f7-42e7-96b6-a616792569e7", "node_type": "1", "metadata": {}, "hash": "7189db96d3a63c232bc4029a3a7f39a48f61d76e42ffc21ee650c422eb3c9769", "class_name": "RelatedNodeInfo"}}, "hash": "de19c7fe1eff9eeaa3eb82d669bcf8442f573c2f932cc1b1cb042ecac5ed1f56", "text": "dispatcher\n\nupdater\n\ndispatcher\n\ndispatcher\n\nadd_handler\n\nCommandHandler\n\n\"start\"\n\nhelp_command\n\ndispatcher\n\nadd_handler\n\nCommandHandler\n\n\"help\"\n\nhelp_command\n\nupdater\n\nstart_polling\n\nupdater\n\nidle\n\nif\n\n__name__\n\n==\n\n'__main__'\n\nmain\n\nAt the top, we import os so that we can get our token from the environment variable.\n\nWe then import classes from the Telegram library.\n\nThe comments starting with #upm are not optional. They are used by Replit to download the correct package. It is not needed in general, but it is needed here because there are a lot of similar Telegram libraries.\n\nThe help_command function is run whenever the user sends us a \"/start\" or \"/help\" command. \"/start\" is also automatically run when a new user joins your bot (like we did earlier with the BotFather). The bot knows to use this function because we tell it later in the main function's body.\n\nThe main function initialises an updater for us, using our token.\n\nupdater\n\nUpdater\n\nos\n\ngetenv\n\n\"TOKEN\"\n\nThe updater is the class that will continuously check Telegram for new messages for our bot.\n\nWhen the updater gets a new message, it hands it over to the dispatcher. The dispatcher checks if we have an appropriate handler for the message. As mentioned above, we define ours to handle the commands \"/start\" and \"/help\". We do that with the add_handler function, like this:\n\ndispatcher\n\nadd_handler\n\nCommandHandler\n\n\"start\"\n\nhelp_command\n\nand\n\ndispatcher\n\nadd_handler\n\nCommandHandler\n\n\"help\"\n\nhelp_command\n\nTo keep it simple, the \"/start\" command and the \"/help\" command have the same handler here, but you could decide to have a different function for handling each if you wanted.\n\nWe then need to actually tell the updater to start checking for new messages. We accomplish that with this line:\n\nupdater\n\nstart_polling\n\nIt's important to know that start_polling is a non-blocking function. That means that the code won't halt execution here. It will just carry on until the program terminates.\n\nIn other words, if we left this as our last line of the main function, the code would execute and then immediately exit because there was nothing else blocking it. So to keep our bot listening, we use the line updater.idle() to block the script while we are listening.\n\nLogging functionality\u200b\n\nAccording to the help text, there are two things the bot should do.\n\nIf you send a message to the bot, it should store it somehow.\n\nIf you send the bot the \"/fetch\" command, it should send you back the latest message.\n\nTo accomplish this, we will use Replit's key-value database. Start by importing the API.\n\nfrom\n\nreplit\n\nimport\n\ndb\n\ndb is an object that behaves like a dictionary but persists its content between runs. It also serializes its keys as strings.\n\nSince we want to store logged messages in a certain order, but the db object is not inherently ordered, let's create a helper function that can get the largest key (assuming we are only going to use numeric indices). Add this function before the definition of the help_command function:\n\ndef\n\nlatest_key\n\nks\n\ndb\n\nkeys\n\nif\n\nlen\n\nks\n\nreturn\n\nmax\n\nmap\n\nint\n\nks\n\nelse\n\nreturn\n\nlatest_key gets all the keys from our db. If there are keys, convert them all to integers and return the biggest one. If there aren't any keys, return -1.\n\nWe can now create a handler that logs the user's messages to the database. Add this function after the definition of the help_command function:\n\ndef\n\nlog\n\nupdate\n\nUpdate\n\ncontext\n\nCallbackContext\n\nNone\n\ndb\n\nstr\n\nlatest_key\n\nupdate\n\nmessage\n\ntext\n\nThis gets the latest key from the database, increments it by one, and sets a new key-pair with the message.\n\nHowever, this will not be run until we register the handler, so add the following line after the other dispatcher.add_handler(...) lines:\n\ndispatcher\n\nadd_handler\n\nMessageHandler\n\nFilters\n\ntext\n\nFilters\n\ncommand\n\nlog\n\nYou may notice that MessageHandler is used instead of CommandHandler. This is a more general handler that selects messages based off flags that you supply. In this case, it handles messages that contain text but aren't commands.\n\nWe can now log messages, but we can't see them yet. Let's add a handler that lets a user fetch the latest message. Add this function after the definition of the log function:\n\ndef\n\nfetch\n\nupdate\n\nUpdate\n\ncontext\n\nCallbackContext\n\nNone\n\nupdate\n\nmessage\n\nreply_text\n\ndb\n\nget\n\nstr\n\nlatest_key\n\n'No Messages yet.'", "start_char_idx": 0, "end_char_idx": 4374, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8aa15327-13f7-42e7-96b6-a616792569e7": {"__data__": {"id_": "8aa15327-13f7-42e7-96b6-a616792569e7", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "12968328-f1a0-46a6-91be-56fdc84355bd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "hash": "f8bcefd4124c628cabfe558f5c2187ab557fea5340be9b867a735ad8d6311c2f", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d22fca00-ccd2-4da1-a582-f2a45d3507e3", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "hash": "de19c7fe1eff9eeaa3eb82d669bcf8442f573c2f932cc1b1cb042ecac5ed1f56", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c3b908e-7644-4d1f-a9e9-2f6fdd3860f1", "node_type": "1", "metadata": {}, "hash": "4980f3a779d5add9c71204e0e1e99d2de175b95017ca3549f1b7e3357d8d0091", "class_name": "RelatedNodeInfo"}}, "hash": "7189db96d3a63c232bc4029a3a7f39a48f61d76e42ffc21ee650c422eb3c9769", "text": "However, this will not be run until we register the handler, so add the following line after the other dispatcher.add_handler(...) lines:\n\ndispatcher\n\nadd_handler\n\nMessageHandler\n\nFilters\n\ntext\n\nFilters\n\ncommand\n\nlog\n\nYou may notice that MessageHandler is used instead of CommandHandler. This is a more general handler that selects messages based off flags that you supply. In this case, it handles messages that contain text but aren't commands.\n\nWe can now log messages, but we can't see them yet. Let's add a handler that lets a user fetch the latest message. Add this function after the definition of the log function:\n\ndef\n\nfetch\n\nupdate\n\nUpdate\n\ncontext\n\nCallbackContext\n\nNone\n\nupdate\n\nmessage\n\nreply_text\n\ndb\n\nget\n\nstr\n\nlatest_key\n\n'No Messages yet.'\n\nWe can register this one along with the other command handlers. Add this after the existing dispatcher.add_handler(...) lines:\n\ndispatcher\n\nadd_handler\n\nCommandHandler\n\n\"fetch\"\n\nfetch\n\nMake a Web UI\u200b\n\nNow that we have a functional bot, we want to add a web interface for it. The tool we'll use is Flask. We can include the following code after our other imports and before our latest_key function definition.\n\nfrom\n\nmath\n\nimport\n\nceil\n\nfrom\n\nflask\n\nimport\n\nrender_template\n\nfrom\n\nflask\n\nimport\n\nFlask\n\napp\n\nFlask\n\n__name__\n\n@app\n\nroute\n\n'/'\n\n@app\n\nroute\n\n'/<int:page>'\n\ndef\n\nhome\n\npage\n\nNone\n\nks\n\nsorted\n\nmap\n\nint\n\ndb\n\nkeys\n\npages\n\nceil\n\nlen\n\nks\n\n10\n\nif\n\npage\n\nis\n\nNone\n\n#Default to latest page\n\npage\n\npages\n\nif\n\npage\n\npages\n\nnext_page\n\npage\n\nelse\n\nnext_page\n\nNone\n\nif\n\npage\n\nprev_page\n\npage\n\nelse\n\nprev_page\n\nNone\n\nmessages\n\ntuple\n\ndb\n\nstr\n\nkey\n\nfor\n\nkey\n\nin\n\nks\n\npage\n\n10\n\npage\n\n10\n\nreturn\n\nrender_template\n\n'home.html'\n\nmessages\n\nmessages\n\nnext_page\n\nnext_page\n\npage\n\npage\n\nprev_page\n\nprev_page\n\nThis defines a small Flask app. Replit takes care of our Flask import. For this tutorial, we'll only make a single page.\n\nWe tell Flask how the page should be reachable with special decorators. @app.route('/') says that when the user accesses at https://example.com, it will serve this handler. In this case, the variable \"page\" will default to None.\n\n@app.route('/<int:page>') says that when a user accesses something like https://example.com/4 then it will open to page 4 of the logged messages. In this case, the variable \"page\" will be set to 4.\n\nThis won't work yet, because our template home.html doesn't exist. Let's create that now in a folder called \"templates\" (i.e. templates/home.html):\n\n!doctype html\n\nh1\n\nMessages\n\nPage\n\npage\n\nh1\n\nul\n\nfor\n\nmsg\n\nin\n\nmessages\n\nli\n\nmsg\n\nescape\n\nli\n\nendfor\n\nul\n\nif\n\nprev_page\n\na href\n\n'/{{ prev_page }}'\n\nPrevious Page\n\nendif\n\nif\n\nprev_page\n\nand\n\nnext_page\n\nendif\n\nif\n\nnext_page\n\na href\n\n'/{{ next_page }}'\n\nNext Page\n\nendif\n\nThis template will output a page of logged messages and links to the next or previous page at the bottom.\n\nThe template requires a variable \"page\" for the page number and an array of \"messages\" that is looped through and displayed as a list. It also takes in variables \"prev_page\" and \"next_page\" which we use to create links to the previous page and next page, if they exist respectively. These are all provided in our route function above when we run render_template.\n\nHow do we calculate the maximum number of pages?\n\npages\n\nceil\n\nlen\n\nks\n\n10\n\nThat is to say, we divide the number of keys in our Replit database by ten and round it up. We can also use this number as our default. That way, if someone visits the plain \"/\" route, we will just display the latest page.\n\nif\n\npage\n\nis\n\nNone\n\npage\n\npages\n\nWe know that the last messages will be the \"latest\" because we sorted them in ascending order in the line before.\n\n\"prev_page\" and \"next_page\" are the current page either decremented or incremented if they are a valid page numbers (otherwise set to None so that the template doesn't display them).\n\nPutting it All Together\u200b\n\nIf we run our program now, the Flask web app won\u2019t work yet. Flask needs to listen for requests in a similar way to the Telegram library.", "start_char_idx": 3617, "end_char_idx": 7611, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c3b908e-7644-4d1f-a9e9-2f6fdd3860f1": {"__data__": {"id_": "1c3b908e-7644-4d1f-a9e9-2f6fdd3860f1", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "12968328-f1a0-46a6-91be-56fdc84355bd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "hash": "f8bcefd4124c628cabfe558f5c2187ab557fea5340be9b867a735ad8d6311c2f", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8aa15327-13f7-42e7-96b6-a616792569e7", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}, "hash": "7189db96d3a63c232bc4029a3a7f39a48f61d76e42ffc21ee650c422eb3c9769", "class_name": "RelatedNodeInfo"}}, "hash": "4980f3a779d5add9c71204e0e1e99d2de175b95017ca3549f1b7e3357d8d0091", "text": "How do we calculate the maximum number of pages?\n\npages\n\nceil\n\nlen\n\nks\n\n10\n\nThat is to say, we divide the number of keys in our Replit database by ten and round it up. We can also use this number as our default. That way, if someone visits the plain \"/\" route, we will just display the latest page.\n\nif\n\npage\n\nis\n\nNone\n\npage\n\npages\n\nWe know that the last messages will be the \"latest\" because we sorted them in ascending order in the line before.\n\n\"prev_page\" and \"next_page\" are the current page either decremented or incremented if they are a valid page numbers (otherwise set to None so that the template doesn't display them).\n\nPutting it All Together\u200b\n\nIf we run our program now, the Flask web app won\u2019t work yet. Flask needs to listen for requests in a similar way to the Telegram library. We might normally end the program with app.run() to start the Flask server.\n\nThe problem is that this line of code would never be reached in normal circumstances because we have the line updater.idle() blocking our code before that. To solve this, we can replace this line with the line that starts our Flask server in the foreground. This is because the only reason we had the line was to stop the program from quitting prematurely and Flask accomplishes the same anyway. So, let's change it to this:\n\n#updater.idle()\n\napp\n\nrun\n\nhost\n\n'0.0.0.0'\n\nport\n\n8080\n\nThe parameters, host and port set to these values allow Replit to access the server and should normally display a window with our page\u2019s content. We can now browse through messages sent to this bot by users.\n\nMake it Your Own\u200b\n\nIf you've followed along, you'll have your own version of the repl to extend. Otherwise, start from ours.\n\nWhere Next?\u200b\n\nTry using the \"/setcommands\" command in the BotFather to add a quick-menu for the commands in your bot. Usage is described here.\n\nIf we wanted access to the username of a person sending a message, we could access it in a similar way that we would access the message's text:\n\nusername\n\nupdate\n\nmessage\n\nfrom_user\n\nusername\n\nYou can check the documentation for a list of additional data made available.\n\n< Previous: Technical challenge site with replit.web\n\nNext: Test-driven development >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nPrerequisites\n\nRegistering a Bot\n\nMaking a Bot InterfaceCreating a barebones botLogging functionality\n\nMake a Web UI\n\nPutting it All Together\n\nMake it Your Own\n\nWhere Next?", "start_char_idx": 6816, "end_char_idx": 9230, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"12968328-f1a0-46a6-91be-56fdc84355bd": {"node_ids": ["d22fca00-ccd2-4da1-a582-f2a45d3507e3", "8aa15327-13f7-42e7-96b6-a616792569e7", "1c3b908e-7644-4d1f-a9e9-2f6fdd3860f1"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/telegram-bot.html"}}}, "docstore/metadata": {"d22fca00-ccd2-4da1-a582-f2a45d3507e3": {"doc_hash": "de19c7fe1eff9eeaa3eb82d669bcf8442f573c2f932cc1b1cb042ecac5ed1f56", "ref_doc_id": "12968328-f1a0-46a6-91be-56fdc84355bd"}, "8aa15327-13f7-42e7-96b6-a616792569e7": {"doc_hash": "7189db96d3a63c232bc4029a3a7f39a48f61d76e42ffc21ee650c422eb3c9769", "ref_doc_id": "12968328-f1a0-46a6-91be-56fdc84355bd"}, "1c3b908e-7644-4d1f-a9e9-2f6fdd3860f1": {"doc_hash": "4980f3a779d5add9c71204e0e1e99d2de175b95017ca3549f1b7e3357d8d0091", "ref_doc_id": "12968328-f1a0-46a6-91be-56fdc84355bd"}}}