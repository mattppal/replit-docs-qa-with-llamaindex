{"docstore/data": {"ed679c1a-8dae-4974-b3d5-df8a083aabd2": {"__data__": {"id_": "ed679c1a-8dae-4974-b3d5-df8a083aabd2", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c77acc19-9c58-4b57-9d58-20abe77b96de", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "1a16d8c8daf73b1200371c8dbe465f80382a821d2037d33c2a1a2bd54fb95eb8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "35e5bf16-6e07-4fca-84cf-6c386d4fdd02", "node_type": "1", "metadata": {}, "hash": "df07b8dc9cdce7d34d83acb4abb6431d328faff6e49da1fe2319b8c9eb3905cb", "class_name": "RelatedNodeInfo"}}, "hash": "ba0ebe71116b38a09059bd1f2e8afefb654905b7677e0627e6ade5eee98668b7", "text": "Let's get started with the application. We'll build two separate components in parallel, piece by piece:\n\nThe database logic to create, read, update, and delete contacts.\n\nThe command line interface to prompt the user to choose what to do, get input, and show output.\n\nWe'll keep the code that interacts with users in our main.py file and the database logic in a new module called contacts.py\n\nAs we don't have any contacts yet, we'll start by allowing our users to add them.\n\nAllowing the user to add contacts to the phonebook\u200b\n\nLet's build the user interaction side first. We need to be able to accept input from the user and show them prompts and output. Add the following code to main.py:\n\ndef\n\nprompt_add_contact\n\nname\n\ninput\n\n\"Please enter the contact's name: \"\n\nnumber\n\ninput\n\n\"Please enter the contact's phone number: \"\n\nprint\n\nf\"Adding\n\nname\n\nwith\n\nnumber\n\nprompt_add_contact\n\nThis doesn't actually store the contact anywhere yet, but you can test it out to see how it prompts the user for input and then displays a confirmation message.\n\nNext we need to add some logic to store this in our database.\n\nCreate a new file called contacts.py and add the following code.\n\nfrom\n\nreplit\n\nimport\n\ndb\n\ndef\n\nadd_contact\n\nname\n\nphone_number\n\nif\n\nname\n\nin\n\ndb\n\nprint\n\n\"Name already exists\"\n\nelse\n\ndb\n\nname\n\nphone_number\n\nBecause we will use people's names as keys in our database and because it's possible that different people share the same name, it's possible that our users could overwrite important phone numbers by adding a new contact with the same name as an existing one. To prevent this, we'll ensure that they use a unique name for each contact and only add information with this method to new names.\n\nBack in the main.py file add two lines to import our new module and call the add_contact function. The new code should look as follows:\n\nimport\n\ncontacts\n\ndef\n\nprompt_add_contact\n\nname\n\ninput\n\n\"Please enter the contact's name: \"\n\nnumber\n\ninput\n\n\"Please enter the contact's phone number: \"\n\nprint\n\nf\"Adding\n\nname\n\nwith\n\nnumber\n\ncontacts\n\nadd_contact\n\nname\n\nnumber\n\nprompt_add_contact\n\nTest that this works - run it twice and enter the same name both times, with a different phone number. You should see the confirmation the first time, but the second time it will inform you that the contact already exists, as shown below.\n\nAllowing users to retrieve details of stored contacts\u200b\n\nNow that we've added a contact to our database, let's allow users to retrieve this information. We want the user to be able to input a name and get the associated phone number in return. We can follow a similar pattern to before: adding a function to both our main.py file to handle user interaction and a separate one to our contacts.py file to handle database interaction.\n\nIn main.py add the following function and change the last line to call our new function instead of the prompt_add_contact() one, as follows:\n\ndef\n\nprompt_get_contact\n\nname\n\ninput\n\n\"Please enter the name to find: \"\n\nnumber\n\ncontacts\n\nget_contact\n\nname\n\nif\n\nnumber\n\nprint\n\nf\"\n\nname\n\n's number is\n\nnumber\n\nelse\n\nprint\n\nf\"It looks like\n\nname\n\ndoes not exist\"\n\nprompt_get_contact\n\nNote that this time we call the get_contact function before we write it - we have a blueprint that works now from our previous example so we can skip some back-and-forth steps.\n\nAdd the following function to contacts.py:\n\ndef\n\nget_contact\n\nname\n\nnumber\n\ndb\n\nget\n\nname\n\nreturn\n\nnumber\n\nOur new code to go into contact.py is very simple and it might be tempting to just put this logic directly in the main.py file as it's so short. However it's good to stay consistent as each of the files is likely to grow in length and complexity over time, and it will be easier to maintain our codebase if our user interaction code is strictly separate from our database interaction code.\n\nRun the code again and input the same name as before. If all went well, you'll see the number, as in the example below.\n\nInterlude: Creating a main menu\u200b\n\nWe now have functionality to add and retrieve contacts, and still need to add:\n\nsearching for names with partial matches\n\nupdating existing contacts (name or number)\n\nremoving contacts.\n\nBut before we get started on those problems, we need to allow users to choose what kind of functionality they want to activate. With a GUI or web application, we could add some menu items or buttons, but our command line application is driven only by text input and output on a simple console.", "start_char_idx": 0, "end_char_idx": 4454, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35e5bf16-6e07-4fca-84cf-6c386d4fdd02": {"__data__": {"id_": "35e5bf16-6e07-4fca-84cf-6c386d4fdd02", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c77acc19-9c58-4b57-9d58-20abe77b96de", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "1a16d8c8daf73b1200371c8dbe465f80382a821d2037d33c2a1a2bd54fb95eb8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ed679c1a-8dae-4974-b3d5-df8a083aabd2", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "ba0ebe71116b38a09059bd1f2e8afefb654905b7677e0627e6ade5eee98668b7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d7a4c6ad-2fd2-4e61-b8e7-ccb29b1a5cf9", "node_type": "1", "metadata": {}, "hash": "5bd72c1dab4f8075fe7c54b4c24425c9b02777fb64375c9da5fb1ab25e874c7d", "class_name": "RelatedNodeInfo"}}, "hash": "df07b8dc9cdce7d34d83acb4abb6431d328faff6e49da1fe2319b8c9eb3905cb", "text": "However it's good to stay consistent as each of the files is likely to grow in length and complexity over time, and it will be easier to maintain our codebase if our user interaction code is strictly separate from our database interaction code.\n\nRun the code again and input the same name as before. If all went well, you'll see the number, as in the example below.\n\nInterlude: Creating a main menu\u200b\n\nWe now have functionality to add and retrieve contacts, and still need to add:\n\nsearching for names with partial matches\n\nupdating existing contacts (name or number)\n\nremoving contacts.\n\nBut before we get started on those problems, we need to allow users to choose what kind of functionality they want to activate. With a GUI or web application, we could add some menu items or buttons, but our command line application is driven only by text input and output on a simple console. Let's build a main menu that allows users to specify what they want to do.\n\nTo make life easier for our users, we'll let them make choices by inputting a single number that's associated with the relevant menu item.\n\nChange your main.py file to look as follows:\n\nimport\n\ncontacts\n\nfrom\n\nos\n\nimport\n\nsystem\n\nmain_message\n\n\"\"\"WELCOME TO PHONEBOOK\n\n----------------------------------\n\nPlease choose:\n\n1 - to add a new contact\n\n2 - to find a contact\n\n----------------------------------\n\n\"\"\"\n\ndef\n\nprompt_add_contact\n\nname\n\ninput\n\n\"Please enter the contact's name: \"\n\nnumber\n\ninput\n\n\"Please enter the contact's phone number: \"\n\nprint\n\nf\"Adding\n\nname\n\nwith\n\nnumber\n\ncontacts\n\nadd_contact\n\nname\n\nnumber\n\ndef\n\nprompt_get_contact\n\nname\n\ninput\n\n\"Please enter the name to find: \"\n\nnumber\n\ncontacts\n\nget_contact\n\nname\n\nif\n\nnumber\n\nprint\n\nf\"\n\nname\n\n's number is\n\nnumber\n\nelse\n\nprint\n\nf\"It looks like\n\nname\n\ndoes not exist\"\n\ndef\n\nmain\n\nprint\n\nmain_message\n\nchoice\n\ninput\n\n\"Please make your choice: \"\n\nstrip\n\nif\n\nchoice\n\n==\n\n\"1\"\n\nprompt_add_contact\n\nelif\n\nchoice\n\n==\n\n\"2\"\n\nprompt_get_contact\n\nelse\n\nprint\n\n\"Invalid input. Please try again.\"\n\nwhile\n\nTrue\n\nsystem\n\n\"clear\"\n\nmain\n\ninput\n\n\"Press enter to continue: \"\n\nThis looks like a lot more code than we had before, but if you ignore the multi-line string at the top and the two functions that we already had, there's not much more. Our new main() function asks the users to choose an item from the menu, makes sure that it's a valid choice, and then calls the appropriate function.\n\nBelow our main() function, we have an infinite loop so that the user can keep using our application without re-running it after the first action. We call system(\"clear\") between runs to clean up the old inputs and outputs (and we also added a new import at the top of the file for this).\n\nExtending our search functionality\u200b\n\nWe already allow users to find contacts by entering their exact name, but it's useful to be able to do partial matches too. If our user inputs \"Smith\" and we have a \"Smith, John\" and a \"Smith, Mary\", we should be able to show the user both of these contacts.\n\nThe Replit database has a prefix function that can find all keys that start with a specific string. Giving \"Smi\" to this prefix function would match \"Smith\", \"Smith, John\" and \"Smith, Mary\", but not \"John Smith\", as it only matches from the start of each key.\n\nYou can use this by calling, for example, db.prefix(\"Smi\") which will return all of the keys that match the \"Smi\" prefix. Note that this does not return the values (in our case, the phone numbers), so once we have our matches we still need to look up each phone number individually.\n\nWe want our application to prefer finding an exact match if one exists, or gracefully fall back to returning a list of matches by prefix only if there is no exact match.", "start_char_idx": 3573, "end_char_idx": 7273, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7a4c6ad-2fd2-4e61-b8e7-ccb29b1a5cf9": {"__data__": {"id_": "d7a4c6ad-2fd2-4e61-b8e7-ccb29b1a5cf9", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c77acc19-9c58-4b57-9d58-20abe77b96de", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "1a16d8c8daf73b1200371c8dbe465f80382a821d2037d33c2a1a2bd54fb95eb8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "35e5bf16-6e07-4fca-84cf-6c386d4fdd02", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "df07b8dc9cdce7d34d83acb4abb6431d328faff6e49da1fe2319b8c9eb3905cb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2b11c87c-58b2-418e-aedf-e13e83121075", "node_type": "1", "metadata": {}, "hash": "e638972c9b7f296e2c1e3180831e9bec672e026906f65a3228734ec3d31790f4", "class_name": "RelatedNodeInfo"}}, "hash": "5bd72c1dab4f8075fe7c54b4c24425c9b02777fb64375c9da5fb1ab25e874c7d", "text": "If our user inputs \"Smith\" and we have a \"Smith, John\" and a \"Smith, Mary\", we should be able to show the user both of these contacts.\n\nThe Replit database has a prefix function that can find all keys that start with a specific string. Giving \"Smi\" to this prefix function would match \"Smith\", \"Smith, John\" and \"Smith, Mary\", but not \"John Smith\", as it only matches from the start of each key.\n\nYou can use this by calling, for example, db.prefix(\"Smi\") which will return all of the keys that match the \"Smi\" prefix. Note that this does not return the values (in our case, the phone numbers), so once we have our matches we still need to look up each phone number individually.\n\nWe want our application to prefer finding an exact match if one exists, or gracefully fall back to returning a list of matches by prefix only if there is no exact match.\n\nAdd a new function to contacts.py that can search for contacts and extract each phone number as follows:\n\ndef\n\nsearch_contacts\n\nsearch\n\nmatch_keys\n\ndb\n\nprefix\n\nsearch\n\nreturn\n\ndb\n\nfor\n\nin\n\nmatch_keys\n\nAnd over in main.py modify the prompt_get_contacts() function to call this if necessary (when there is no exact match) as follows:\n\ndef\n\nprompt_get_contact\n\nname\n\ninput\n\n\"Please enter the name to find: \"\n\nnumber\n\ncontacts\n\nget_contact\n\nname\n\nif\n\nnumber\n\nprint\n\nf\"\n\nname\n\n's number is\n\nnumber\n\nelse\n\nmatches\n\ncontacts\n\nsearch_contacts\n\nname\n\nif\n\nmatches\n\nfor\n\nin\n\nmatches\n\nprint\n\nf\"\n\n's number is\n\nmatches\n\nelse\n\nprint\n\nf\"It looks like\n\nname\n\ndoes not exist\"\n\nRun the code again and choose to add a contact. Enter \"Smith, Mary\" when prompted and any phone number. When the program starts over, choose to find a contact and input \"Smi\". It should print out both \"Smith\" matches that we have, as shown below.\n\nAllowing users to update contacts\u200b\n\nThere are two ways that users might want to update contacts. They should be able to:\n\nChange the name of a contact but keep the same phone number\n\nChange the phone number of a contact but keep the same name\n\nBecause we are storing contacts as keys and values, to do 1) we need to create a new contact and remove the original one, while for 2) we can simply update the value of the existing key.\n\nWe can handle both cases with a single prompt by allowing the user to leave either field blank, in this case preserving the old value. Add the following function to your main.py file.\n\ndef\n\nprompt_update_contact\n\nold_name\n\ninput\n\n\"Please enter the name of the contact to update: \"\n\nold_number\n\ncontacts\n\nget_contact\n\nold_name\n\nif\n\nold_number\n\nnew_name\n\ninput\n\nf\"Please enter the new name for this contact (leave blank to keep\n\nold_name\n\n): \"\n\nstrip\n\nnew_number\n\ninput\n\nf\"Please enter the new number for this contact (leave blank to keep\n\nold_number\n\n): \"\n\nstrip\n\nif\n\nnot\n\nnew_number\n\nnew_number\n\nold_number\n\nif\n\nnot\n\nnew_name\n\ncontacts\n\nupdate_number\n\nold_name\n\nnew_number\n\nelse\n\ncontacts\n\nupdate_contact\n\nold_name\n\nnew_name\n\nnew_number\n\nelse\n\nprint\n\nf\"It looks like\n\nold_name\n\ndoes not exist\"\n\nThis uses two functions in our contacts.py file that don't exist yet. These are:\n\nupdate_number to keep the contact but change the phone number\n\nupdate_contact to update the name (and maybe also the number) by removing the old contact and creating a new one.\n\nCreate these two functions in contacts.py as follows.\n\ndef\n\nupdate_number\n\nold_name\n\nnew_number\n\ndb\n\nold_name\n\nnew_number\n\ndef\n\nupdate_contact\n\nold_name\n\nnew_name\n\nnew_number\n\ndb\n\nnew_name\n\nnew_number\n\ndel\n\ndb\n\nold_name\n\nNote how we can use the del Python keyword to remove things from our database. We'll use this again in the next section.\n\nNow we need to allow users to choose \"update\" as an option from the menu.", "start_char_idx": 6423, "end_char_idx": 10086, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2b11c87c-58b2-418e-aedf-e13e83121075": {"__data__": {"id_": "2b11c87c-58b2-418e-aedf-e13e83121075", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c77acc19-9c58-4b57-9d58-20abe77b96de", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "1a16d8c8daf73b1200371c8dbe465f80382a821d2037d33c2a1a2bd54fb95eb8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d7a4c6ad-2fd2-4e61-b8e7-ccb29b1a5cf9", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "5bd72c1dab4f8075fe7c54b4c24425c9b02777fb64375c9da5fb1ab25e874c7d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bd64def2-8baa-4a87-8805-86257e248863", "node_type": "1", "metadata": {}, "hash": "09db78ec9d1b1e578634f0bf3a292a7f3665ba9f20588c9c64fbcb77a7e19f02", "class_name": "RelatedNodeInfo"}}, "hash": "e638972c9b7f296e2c1e3180831e9bec672e026906f65a3228734ec3d31790f4", "text": "These are:\n\nupdate_number to keep the contact but change the phone number\n\nupdate_contact to update the name (and maybe also the number) by removing the old contact and creating a new one.\n\nCreate these two functions in contacts.py as follows.\n\ndef\n\nupdate_number\n\nold_name\n\nnew_number\n\ndb\n\nold_name\n\nnew_number\n\ndef\n\nupdate_contact\n\nold_name\n\nnew_name\n\nnew_number\n\ndb\n\nnew_name\n\nnew_number\n\ndel\n\ndb\n\nold_name\n\nNote how we can use the del Python keyword to remove things from our database. We'll use this again in the next section.\n\nNow we need to allow users to choose \"update\" as an option from the menu. In the main.py file, add a new line to the menu prompt to inform our users about the option and update the main() function to call the new update function when appropriate, as follows:\n\nmain_message\n\n\"\"\"WELCOME TO PHONEBOOK\n\n----------------------------------\n\nPlease choose:\n\n1 - to add a new contact\n\n2 - to find a contact\n\n3 - to update a contact\n\n----------------------------------\n\n\"\"\"\n\n# ...\n\ndef\n\nmain\n\nprint\n\nmain_message\n\nchoice\n\ninput\n\n\"Please make your choice: \"\n\nstrip\n\nif\n\nchoice\n\n==\n\n\"1\"\n\nprompt_add_contact\n\nelif\n\nchoice\n\n==\n\n\"2\"\n\nprompt_get_contact\n\nelif\n\nchoice\n\n==\n\n\"3\"\n\nprompt_update_contact\n\nelse\n\nprint\n\n\"Invalid input. Please try again.\"\n\nTest it out! Change someone's name, someone else's number, and then update both the name and the number at once.\n\nAllowing users to remove contacts\u200b\n\nSometimes there are people we just don't want to talk to any more. We've already seen how to remove contacts by updating their key and removing the old one, but let's allow for removals without updates too. By now, you should be familiar with the parts of the code that you need to update. To recap, these are:\n\nadding a new prompt_* function to the main.py file\n\nadding a new *_contact function to contacts.py\n\nadding a new line to the menu prompt in main.py\n\nadding a new elif block to the main() function in main.py.\n\nThese are each shown in turn below.\n\ndef\n\nprompt_delete_contact\n\nname\n\ninput\n\n\"Please enter the name to delete: \"\n\ncontact\n\ncontacts\n\nget_contact\n\nname\n\nif\n\ncontact\n\nprint\n\nf\"Deleting\n\nname\n\ncontacts\n\ndelete_contact\n\nname\n\nelse\n\nprint\n\nf\"It looks like\n\nname\n\ndoes not exist\"\n\ndef\n\ndelete_contact\n\nname\n\ndel\n\ndb\n\nname\n\nmain_message\n\n\"\"\"WELCOME TO PHONEBOOK\n\n----------------------------------\n\nPlease choose:\n\n1 - to add a new contact\n\n2 - to find a contact\n\n3 - to update a contact\n\n4 - to delete a contact\n\n----------------------------------\n\n\"\"\"\n\ndef\n\nmain\n\nprint\n\nmain_message\n\nchoice\n\ninput\n\n\"Please make your choice: \"\n\nstrip\n\nif\n\nchoice\n\n==\n\n\"1\"\n\nprompt_add_contact\n\nelif\n\nchoice\n\n==\n\n\"2\"\n\nprompt_get_contact\n\nelif\n\nchoice\n\n==\n\n\"3\"\n\nprompt_update_contact\n\nelif\n\nchoice\n\n==\n\n\"4\"\n\nprompt_delete_contact\n\nelse\n\nprint\n\n\"Invalid input. Please try again.\"\n\nIt may be a bit inconvenient to type out the whole name of a contact that you want to delete, but it's usually acceptable to make \"dangerous\" operations less user friendly. As there is no way to recover contacts, it's good to make it a bit more difficult to delete them. Maybe our user will change their mind while typing out the name of an old friend to delete the record and reach out instead :).\n\nMake it your own\u200b\n\nIf you've followed along, you'll have your own version of the repl to extend. Otherwise start from ours below.\n\nWhere next\u200b\n\nYou've learned how basic databases work. Databases are a complicated topic on their own and it can take years or decades to master the more advanced aspects of them, but they can also do more than the simple operations that we've covered here. Spend some time reading about PostgreSQL and relational databases in general, or other key-value stores like the Replit database.\n\nEven without further research, the basic Create, Read, Update, and Delete (CRUD) operations that we covered here will get you far and you can build nearly any app you can imagine with just these.\n\nNext we'll take a look at playing audio files programmatically so you can use Python to control your music.\n\n< Previous: Wordle with Python & Rich\n\nNext: Node.js >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nAdding and reading data using the Replit databaseHow is this different from a dictionary?", "start_char_idx": 9480, "end_char_idx": 13695, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bd64def2-8baa-4a87-8805-86257e248863": {"__data__": {"id_": "bd64def2-8baa-4a87-8805-86257e248863", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c77acc19-9c58-4b57-9d58-20abe77b96de", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "1a16d8c8daf73b1200371c8dbe465f80382a821d2037d33c2a1a2bd54fb95eb8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2b11c87c-58b2-418e-aedf-e13e83121075", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}, "hash": "e638972c9b7f296e2c1e3180831e9bec672e026906f65a3228734ec3d31790f4", "class_name": "RelatedNodeInfo"}}, "hash": "09db78ec9d1b1e578634f0bf3a292a7f3665ba9f20588c9c64fbcb77a7e19f02", "text": "Otherwise start from ours below.\n\nWhere next\u200b\n\nYou've learned how basic databases work. Databases are a complicated topic on their own and it can take years or decades to master the more advanced aspects of them, but they can also do more than the simple operations that we've covered here. Spend some time reading about PostgreSQL and relational databases in general, or other key-value stores like the Replit database.\n\nEven without further research, the basic Create, Read, Update, and Delete (CRUD) operations that we covered here will get you far and you can build nearly any app you can imagine with just these.\n\nNext we'll take a look at playing audio files programmatically so you can use Python to control your music.\n\n< Previous: Wordle with Python & Rich\n\nNext: Node.js >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nAdding and reading data using the Replit databaseHow is this different from a dictionary?\n\nBuilding a basic phonebook application that can read and store dataAllowing the user to add contacts to the phonebookAllowing users to retrieve details of stored contactsInterlude: Creating a main menuExtending our search functionalityAllowing users to update contactsAllowing users to remove contacts\n\nMake it your own\n\nWhere next", "start_char_idx": 12773, "end_char_idx": 14028, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"c77acc19-9c58-4b57-9d58-20abe77b96de": {"node_ids": ["ed679c1a-8dae-4974-b3d5-df8a083aabd2", "35e5bf16-6e07-4fca-84cf-6c386d4fdd02", "d7a4c6ad-2fd2-4e61-b8e7-ccb29b1a5cf9", "2b11c87c-58b2-418e-aedf-e13e83121075", "bd64def2-8baa-4a87-8805-86257e248863"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/using-the-replit-database.html"}}}, "docstore/metadata": {"ed679c1a-8dae-4974-b3d5-df8a083aabd2": {"doc_hash": "ba0ebe71116b38a09059bd1f2e8afefb654905b7677e0627e6ade5eee98668b7", "ref_doc_id": "c77acc19-9c58-4b57-9d58-20abe77b96de"}, "35e5bf16-6e07-4fca-84cf-6c386d4fdd02": {"doc_hash": "df07b8dc9cdce7d34d83acb4abb6431d328faff6e49da1fe2319b8c9eb3905cb", "ref_doc_id": "c77acc19-9c58-4b57-9d58-20abe77b96de"}, "d7a4c6ad-2fd2-4e61-b8e7-ccb29b1a5cf9": {"doc_hash": "5bd72c1dab4f8075fe7c54b4c24425c9b02777fb64375c9da5fb1ab25e874c7d", "ref_doc_id": "c77acc19-9c58-4b57-9d58-20abe77b96de"}, "2b11c87c-58b2-418e-aedf-e13e83121075": {"doc_hash": "e638972c9b7f296e2c1e3180831e9bec672e026906f65a3228734ec3d31790f4", "ref_doc_id": "c77acc19-9c58-4b57-9d58-20abe77b96de"}, "bd64def2-8baa-4a87-8805-86257e248863": {"doc_hash": "09db78ec9d1b1e578634f0bf3a292a7f3665ba9f20588c9c64fbcb77a7e19f02", "ref_doc_id": "c77acc19-9c58-4b57-9d58-20abe77b96de"}}}