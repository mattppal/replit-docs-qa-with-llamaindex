{"docstore/data": {"7d62db4f-1a27-49ad-b3f2-e679ca5a83a6": {"__data__": {"id_": "7d62db4f-1a27-49ad-b3f2-e679ca5a83a6", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "668af67800b9fa5edacfe5bce4bce49142bc975cc8fb32d705a142ec187f3020", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b2341b4-2369-4199-8597-0f514f93a9c6", "node_type": "1", "metadata": {}, "hash": "ff07d81ea0c7f1bda1beace3131bfbc0fe61722752710079876a5d2e524511d5", "class_name": "RelatedNodeInfo"}}, "hash": "88a50235c825e2ea7a7c4bc781fd125c5d96c0ddae6d75b79f69f9d2dbfec91c", "text": "submit\n\nclass\n\nbutton\n\nvalue\n\nBreed new ReplBot!\n\n</\n\ninput\n\n</\n\nform\n\ndiv\n\nid\n\nbots\n\nscript\n\nsrc\n\n./app.js\n\n</\n\nscript\n\n</\n\nbody\n\n</\n\nhtml\n\nIn this file, we've created the following:\n\nA button element for minting a new ReplBot.\n\nA form element for breeding a new ReplBot from two parents.\n\nA div element for displaying the user's owned ReplBots.\n\nWe've also linked our stylesheet at the top of the file and our JavaScript file at the bottom.\n\nAdd the following CSS to frontend/style.css:\n\nbody\n\nfont-family\n\nmonospace\n\n.button\n\nfont-size\n\n1.1\n\nem\n\nborder-width\n\npx\n\nbackground-color\n\nwhite\n\nmargin\n\nem\n\nform\n\nborder\n\npx\n\nsolid\n\nblack\n\npadding\n\nem\n\ndisplay\n\ninline-block\n\n#bots\n\ndisplay\n\nflex\n\nflex-wrap\n\nwrap\n\n#bots\n\nsvg\n\nwidth\n\n30\n\nem\n\nFinally, add this code skeleton to frontend/app.js:\n\nApp\n\nreplbotAddress\n\n\"INSERT-CONTRACT-ADDRESS-HERE\"\n\nreplbotContract\n\nnull\n\ninit\n\nasync\n\nfunction\n\nApp\n\ninit\n\nThis App object will contain all of the status and functionality we'll implement. Insert the contract address you copied earlier as the value of replbotAddress.\n\nConnecting to the blockchain\u200b\n\nThe majority of Ethereum dapps use one of two libraries for interacting with the blockchain: web3.js or ethers.js. The ethers.js library was used for Replit's Solidity Starter interface, but we'll use web3.js for this tutorial.\n\nWe can import web3.js by adding the following line to index.html, just above the line where we import app.js:\n\nscript\n\nsrc\n\nhttps://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\n\n</\n\nscript\n\nThen, returning to frontend/app.js, we'll connect to the blockchain in our app's init function. Add the following code to the function's body:\n\ninit\n\nasync\n\nfunction\n\nif\n\nwindow\n\nethereum\n\nawait\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n'eth_requestAccounts'\n\nwindow\n\nweb3\n\nnew\n\nWeb3\n\nwindow\n\nethereum\n\nThis code will interface with MetaMask and show a pop-up window asking the user to connect their wallet to our dapp. If the user accepts, we'll instantiate a Web3 object using their account details.\n\nThe majority of web3.js functions are asynchronous, so we have to use await to get their return values. As await can only be used in asynchronous functions or top-level JavaScript, the majority of our functions will also be asynchronous.\n\nBecause we're building on the Replit Testnet, we'll need to add some code that prompts the user to switch to this network. Add the following function definition just below the definition of init:\n\nswitchToReplitTestnet\n\nfunction\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n\"wallet_addEthereumChain\"\n\nparams\n\nchainId\n\n\"0x7265706c\"\n\nchainName\n\n\"Replit Testnet\"\n\nrpcUrls\n\n\"https://eth.replit.com\"\n\niconUrls\n\n\"https://upload.wikimedia.org/wikipedia/commons/b/b2/Repl.it_logo.svg\"\n\nnativeCurrency\n\nname\n\n\"Replit ETH\"\n\nsymbol\n\n\"R\u039e\"\n\ndecimals\n\n18\n\nThis code provides the details MetaMask needs to prompt the user to switch networks. We'll invoke it from our init function, as below:\n\ninit\n\nasync\n\nfunction\n\nif\n\nwindow\n\nethereum\n\nawait\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n'eth_requestAccounts'\n\nwindow\n\nweb3\n\nnew\n\nWeb3\n\nwindow\n\nethereum\n\n// NEW CODE BELOW\n\n// Switch networks\n\nApp\n\nswitchToReplitTestnet\n\nInterfacing with the smart contract\u200b\n\nNow that we can connect to the blockchain, we need to access our ReplBots contract. To connect to a contract and run its functions, we need two things: the contract's address, which shows us where to find it, and its ABI, which tells us what functions it implements and what their parameters are. We've already provided the address, so now we just need to specify the ABI.\n\nCreate a new file in frontend called replbotABI.js and add the following code to it:\n\nconst\n\nreplbotABI\n\nFind the ABI data you copied after deploying the ReplBots contract and paste it in as the value of replbotABI. Once that's done, add the following line to frontend/index.html, just below the line where you import web3:\n\nscript\n\nsrc\n\n./replbotABI.js\n\n</\n\nscript\n\nNow we can instantiate App.replbotContract as a web3.eth.Contract.", "start_char_idx": 0, "end_char_idx": 3988, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b2341b4-2369-4199-8597-0f514f93a9c6": {"__data__": {"id_": "9b2341b4-2369-4199-8597-0f514f93a9c6", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "668af67800b9fa5edacfe5bce4bce49142bc975cc8fb32d705a142ec187f3020", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7d62db4f-1a27-49ad-b3f2-e679ca5a83a6", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "88a50235c825e2ea7a7c4bc781fd125c5d96c0ddae6d75b79f69f9d2dbfec91c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e6ccf5f2-fd34-4def-b2ff-fc860ee05281", "node_type": "1", "metadata": {}, "hash": "02dfd72562a0112a790f49e4e7e1cc83ffe9f7809c8ba6312e0bf66be8c84c46", "class_name": "RelatedNodeInfo"}}, "hash": "ff07d81ea0c7f1bda1beace3131bfbc0fe61722752710079876a5d2e524511d5", "text": "To connect to a contract and run its functions, we need two things: the contract's address, which shows us where to find it, and its ABI, which tells us what functions it implements and what their parameters are. We've already provided the address, so now we just need to specify the ABI.\n\nCreate a new file in frontend called replbotABI.js and add the following code to it:\n\nconst\n\nreplbotABI\n\nFind the ABI data you copied after deploying the ReplBots contract and paste it in as the value of replbotABI. Once that's done, add the following line to frontend/index.html, just below the line where you import web3:\n\nscript\n\nsrc\n\n./replbotABI.js\n\n</\n\nscript\n\nNow we can instantiate App.replbotContract as a web3.eth.Contract. Amend your init function in frontend/app.js so that it matches the following:\n\ninit\n\nasync\n\nfunction\n\nif\n\nwindow\n\nethereum\n\nawait\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n'eth_requestAccounts'\n\nwindow\n\nweb3\n\nnew\n\nWeb3\n\nwindow\n\nethereum\n\n// Switch networks\n\nApp\n\nswitchToReplitTestnet\n\n// NEW CODE BELOW\n\n// Interface with contract\n\nApp\n\nreplbotContract\n\nnew\n\nweb3\n\neth\n\nContract\n\nreplbotABI\n\nApp\n\nreplbotAddress\n\nThat's all we need to connect to our contract. Now we can implement some of its functions on our frontend.\n\nRunning contract functions\u200b\n\nWe'll start by implementing some functions in App to get information from the contract. This first one, getMyReplBotIds, will return a list of ReplBots in the current user's wallet. Add the following code within the definition of App at the bottom.\n\n// view data in contract\n\ngetMyReplBotIds\n\nasync\n\nfunction\n\n// get user's address\n\nconst\n\naccounts\n\nawait\n\nweb3\n\neth\n\ngetAccounts\n\nconst\n\naccount\n\naccounts\n\n// get number of ReplBots owned\n\nlet\n\nbalance\n\nawait\n\nApp\n\nreplbotContract\n\nmethods\n\nbalanceOf\n\naccount\n\ncall\n\n// get each one's ID\n\nvar\n\nbotIds\n\nfor\n\nbalance\n\n++\n\nbotIds\n\npush\n\nawait\n\nApp\n\nreplbotContract\n\nmethods\n\ntokenOfOwnerByIndex\n\naccount\n\ncall\n\nreturn\n\nbotIds\n\nweb3.eth.getAccounts() to find the user's wallet address, which we use in subsequent calls to\n\nERC-721 NFT standard (although the latter belongs to an optional extension,\n\nNext, let's implement a function that returns details about a given ReplBot. Add the following code below the definition of getMyReplBotIds():\n\ngetReplBotDetails\n\nasync\n\nfunction\n\ntokenId\n\nvar\n\nbot\n\nbot\n\ncolors\n\nawait\n\nApp\n\nreplbotContract\n\nmethods\n\nbotColors\n\ntokenId\n\ncall\n\nbot\n\naccessories\n\nawait\n\nApp\n\nreplbotContract\n\nmethods\n\nbotAccessories\n\ntokenId\n\ncall\n\nbot\n\nparentage\n\nawait\n\nApp\n\nreplbotContract\n\nmethods\n\nbotParentage\n\ntokenId\n\ncall\n\nreturn\n\nbot\n\nThis code is pretty simple. We've combined all three of our contract's bot information functions into a single function with a single return value.\n\nThose are the only view functions we'll need to worry about for now, so let's move on to functions that change state. First, we'll implement a function for mint. Add the following code to the bottom of your App definition:\n\n// create new NFTs\n\nmintReplBot\n\nasync\n\nfunction\n\nconst\n\naccounts\n\nawait\n\nweb3\n\neth\n\ngetAccounts\n\nconst\n\naccount\n\naccounts\n\n// Mint to own address\n\nApp\n\nreplbotContract\n\nmethods\n\nmint\n\naccount\n\nsend\n\nfrom\n\naccount\n\nWhen we call functions that return information without changing state, we can use .call() and don't have to specify a caller address. This is because external calls to view functions do not cost gas \u2013 they can be run on a single, local node instead of by the whole network. Functions that change state, however, must be run by the whole network, to reach consensus, and this costs gas. Therefore, we use .send() instead of .call(), and must specify a sender, who will need to pay for the gas.\n\nOur function for the breed() function is similar.", "start_char_idx": 3265, "end_char_idx": 6971, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e6ccf5f2-fd34-4def-b2ff-fc860ee05281": {"__data__": {"id_": "e6ccf5f2-fd34-4def-b2ff-fc860ee05281", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "668af67800b9fa5edacfe5bce4bce49142bc975cc8fb32d705a142ec187f3020", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9b2341b4-2369-4199-8597-0f514f93a9c6", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "ff07d81ea0c7f1bda1beace3131bfbc0fe61722752710079876a5d2e524511d5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0bef68ed-a9ff-4fb7-bc79-ff13573c7f41", "node_type": "1", "metadata": {}, "hash": "24ba8b993977615b94cf51c62f5be39cd82251864ed090cc9a3dddd7037fee8a", "class_name": "RelatedNodeInfo"}}, "hash": "02dfd72562a0112a790f49e4e7e1cc83ffe9f7809c8ba6312e0bf66be8c84c46", "text": "Add the following code to the bottom of your App definition:\n\n// create new NFTs\n\nmintReplBot\n\nasync\n\nfunction\n\nconst\n\naccounts\n\nawait\n\nweb3\n\neth\n\ngetAccounts\n\nconst\n\naccount\n\naccounts\n\n// Mint to own address\n\nApp\n\nreplbotContract\n\nmethods\n\nmint\n\naccount\n\nsend\n\nfrom\n\naccount\n\nWhen we call functions that return information without changing state, we can use .call() and don't have to specify a caller address. This is because external calls to view functions do not cost gas \u2013 they can be run on a single, local node instead of by the whole network. Functions that change state, however, must be run by the whole network, to reach consensus, and this costs gas. Therefore, we use .send() instead of .call(), and must specify a sender, who will need to pay for the gas.\n\nOur function for the breed() function is similar. Add the following code just below your mintReplBot definition:\n\nbreedReplBot\n\nasync\n\nfunction\n\nparentOneId\n\nparentTwoId\n\nconst\n\naccounts\n\nawait\n\nweb3\n\neth\n\ngetAccounts\n\nconst\n\naccount\n\naccounts\n\nawait\n\nApp\n\nreplbotContract\n\nmethods\n\nbreed\n\nparentOneId\n\nparentTwoId\n\naccount\n\nsend\n\nfrom\n\naccount\n\nViewing and combining SVGs\u200b\n\nWe've implemented the key contract functions above, including functions that will allow us to retrieve the details of individual ReplBot NFTs. For the moment, the details of these NFTs are just lists of strings. In this part of the tutorial, we'll turn those lists into unique images, using the powerful SVG image format.\n\nMost common image files, such as JPEGs and PNGs, are raster graphics \u2013 highly compressed representations of a grid of pixels. SVGs, on the other hand, are vector graphics, made out of shapes. A good way to think about this is as follows: raster graphics files contain instructions like \"color the pixel at (10,20) in red\", whereas vector graphics files contain instructions like \"draw a red line from point (10,12) to (20,14)\".\n\nBoth image formats have their advantages and disadvantages \u2013 a relevant advantage to SVGs is that they're formatted a lot like HTML files, so it's pretty simple to manipulate them programmatically in JavaScript. To see what an SVG looks like under the hood, rename one of the files in frontend/svg from .svg to .html.\n\nAs you can see, an SVG is made up of a whole lot of XML tags. It even includes CSS for styling, inside the <defs> tag \u2013 we'll use this to change colors. When you're done looking at the file, change its file extension back to .svg.\n\nSVGs can be stored in external files or written inline in HTML. To keep our code clean, we'll keep them in external files. So the first thing we'll need is a function that fetches SVG data from external files. Open frontend/app.js and add the following helper function code above the definition of App:\n\n// helper function\n\nasync\n\nfunction\n\nfetchSvg\n\nfilename\n\nlet\n\nsvgFile\n\nawait\n\nfetch\n\nsvg/\n\n${\n\nfilename\n\nlet\n\nsvgText\n\nawait\n\nsvgFile\n\ntext\n\nconst\n\nparser\n\nnew\n\nDOMParser\n\nreturn\n\nparser\n\nparseFromString\n\nsvgText\n\n\"text/html\"\n\ngetElementsByTagName\n\n\"svg\"\n\nHere we use fetch() to retrieve a specified file from our svg directory. We then extract the file's text, which will be a string, and use a DOMParser to convert this text to HTML. This will allow us to manipulate it using standard JavaScript DOM functions.\n\nNow we have everything we need to write our SVG construction function. This function needs to do the following:\n\nGet the color and accessory details of a given tokenID.\n\nFetch SVGs for the ReplBot's head and change its colors per the ReplBot's details.\n\nFetch SVGs for the ReplBot's accessories and merge them with the ReplBot head.", "start_char_idx": 6151, "end_char_idx": 9750, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0bef68ed-a9ff-4fb7-bc79-ff13573c7f41": {"__data__": {"id_": "0bef68ed-a9ff-4fb7-bc79-ff13573c7f41", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "668af67800b9fa5edacfe5bce4bce49142bc975cc8fb32d705a142ec187f3020", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e6ccf5f2-fd34-4def-b2ff-fc860ee05281", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "02dfd72562a0112a790f49e4e7e1cc83ffe9f7809c8ba6312e0bf66be8c84c46", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f219ac9a-746b-4287-9303-cb659aa9c746", "node_type": "1", "metadata": {}, "hash": "128fe2ee8f9623860f17f651bb82119586bfe0c873355e000c94505eefa402cf", "class_name": "RelatedNodeInfo"}}, "hash": "24ba8b993977615b94cf51c62f5be39cd82251864ed090cc9a3dddd7037fee8a", "text": "We then extract the file's text, which will be a string, and use a DOMParser to convert this text to HTML. This will allow us to manipulate it using standard JavaScript DOM functions.\n\nNow we have everything we need to write our SVG construction function. This function needs to do the following:\n\nGet the color and accessory details of a given tokenID.\n\nFetch SVGs for the ReplBot's head and change its colors per the ReplBot's details.\n\nFetch SVGs for the ReplBot's accessories and merge them with the ReplBot head.\n\nAdd the code below within your App definition at the bottom:\n\n// SVG handling\n\ncreateReplBotSVG\n\nasync\n\nfunction\n\ntokenId\n\n// get bot details\n\nlet\n\ndetails\n\nawait\n\nApp\n\ngetReplBotDetails\n\ntokenId\n\n// get bothead\n\nlet\n\nbotSvg\n\nawait\n\nfetchSvg\n\n\"bothead.svg\"\n\n// change bot colors\n\nbotSvg\n\nquerySelectorAll\n\n'.frame'\n\nforEach\n\n=>\n\nstyle\n\nfill\n\nrgb\n\n${\n\ndetails\n\ncolors\n\nbotSvg\n\nquerySelectorAll\n\n'.visor'\n\nforEach\n\n=>\n\nstyle\n\nfill\n\nrgb\n\n${\n\ndetails\n\ncolors\n\nbotSvg\n\nquerySelectorAll\n\n'.background'\n\nforEach\n\n=>\n\nstyle\n\nfill\n\nrgb\n\n${\n\ndetails\n\ncolors\n\nFirst, we get the ReplBot details and the base ReplBot SVG. We then apply the bot's colors by setting style.fill for every instance of each of the relevant classes, using the CSS rgb() function with the color information from details.\n\nNext, we need to get the bot's accessories. Add the following code above this function's closing curly brace (}):\n\n// get bot accessories\n\nlet\n\naccessorySvgs\n\nfor\n\nlet\n\n++\n\nlet\n\nfilename\n\ndetails\n\naccessories\n\ntoLowerCase\n\nreplaceAll\n\n\" \"\n\n\"-\"\n\n\".svg\"\n\nlet\n\nsvg\n\nawait\n\nfetchSvg\n\nfilename\n\naccessorySvgs\n\npush\n\nsvg\n\nHere we fetch each of the bot's three accessories and add them to a list. We get the filename for the accessory by transforming the string we received from getReplBotDetails(). So, for example, \"Bunny Ears\" becomes \"bunny-ears.svg\".\n\nOnce we've got our accessory SVGs, we can merge them into the base ReplBot SVG. Enter the following code just below the for loop above:\n\n// merge SVGs\n\naccessorySvgs\n\nforEach\n\n=>\n\nArray\n\nfrom\n\ngetElementsByTagName\n\n\"style\"\n\nforEach\n\n=>\n\nbotSvg\n\ngetElementsByTagName\n\n\"defs\"\n\nappendChild\n\nArray\n\nfrom\n\ngetElementsByTagName\n\n\"path\"\n\nforEach\n\n=>\n\nbotSvg\n\nappendChild\n\nArray\n\nfrom\n\ngetElementsByTagName\n\n\"polyline\"\n\nforEach\n\n=>\n\nbotSvg\n\nappendChild\n\nWe merge SVGs by appending all of <style> elements in our accessory SVG to the <defs> element in our base ReplBot SVG, and all of the accessory's <path> and <polyline> elements to the SVG's main body. This is sufficient for the collection of SVGs we're using for this tutorial, but other SVGs may have additional elements that you'll need to account for.\n\nFinally, we'll add the following code that uses insertAdjacentHTML() to add details about the ReplBot's ID and generation before returning the final botSvg in all its glory. Add the following code just below the code above:\n\n// add ID and generation details\n\nbotSvg\n\ninsertAdjacentHTML\n\n\"beforeend\"\n\n<text x=\"5\" y=\"20\">ID:\n\n${\n\ntokenId\n\n</text>\n\nbotSvg\n\ninsertAdjacentHTML\n\n\"beforeend\"\n\n<text x=\"5\" y=\"40\">Gen:\n\n${\n\ndetails\n\nparentage\n\n</text>\n\nreturn\n\nbotSvg\n\nConnecting the UI\u200b\n\nWe've written all of our app functionality \u2013 now we just need to make it usable by binding our HTML interface to our JavaScript functions. Add the following function definition to App.js, just below the definition of switchToReplitTestnet:\n\n// interface\n\nbindEvents\n\nfunction\n\n// mint\n\nconst\n\nmintButton\n\ndocument\n\ngetElementById\n\n\"mint\"\n\nmintButton\n\naddEventListener\n\n\"click\"\n\n=>\n\nApp\n\nmintReplBot\n\n// breed\n\nconst\n\nbreedForm\n\ndocument\n\ngetElementById\n\n\"breed\"\n\nbreedForm\n\naddEventListener\n\n\"submit\"\n\nevent\n\n=>\n\nevent\n\npreventDefault\n\nApp\n\nbreedReplBot\n\nbreedForm\n\nelements\n\n'parentOneId'\n\nvalue\n\nbreedForm\n\nelements\n\n'parentTwoId'\n\nvalue\n\nThis code will trigger mintReplBot() when the mint button is pressed, and breedReplBot() when the ReplBot breeding form is submitted.", "start_char_idx": 9233, "end_char_idx": 13144, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f219ac9a-746b-4287-9303-cb659aa9c746": {"__data__": {"id_": "f219ac9a-746b-4287-9303-cb659aa9c746", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "668af67800b9fa5edacfe5bce4bce49142bc975cc8fb32d705a142ec187f3020", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0bef68ed-a9ff-4fb7-bc79-ff13573c7f41", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "24ba8b993977615b94cf51c62f5be39cd82251864ed090cc9a3dddd7037fee8a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "862d8b7d-3401-4963-9cd0-666a3639b16e", "node_type": "1", "metadata": {}, "hash": "0773adddd63b0e19478b4b9175c4c2ce76925e21da8d68c2aa60c850ebf15b48", "class_name": "RelatedNodeInfo"}}, "hash": "128fe2ee8f9623860f17f651bb82119586bfe0c873355e000c94505eefa402cf", "text": "Add the following function definition to App.js, just below the definition of switchToReplitTestnet:\n\n// interface\n\nbindEvents\n\nfunction\n\n// mint\n\nconst\n\nmintButton\n\ndocument\n\ngetElementById\n\n\"mint\"\n\nmintButton\n\naddEventListener\n\n\"click\"\n\n=>\n\nApp\n\nmintReplBot\n\n// breed\n\nconst\n\nbreedForm\n\ndocument\n\ngetElementById\n\n\"breed\"\n\nbreedForm\n\naddEventListener\n\n\"submit\"\n\nevent\n\n=>\n\nevent\n\npreventDefault\n\nApp\n\nbreedReplBot\n\nbreedForm\n\nelements\n\n'parentOneId'\n\nvalue\n\nbreedForm\n\nelements\n\n'parentTwoId'\n\nvalue\n\nThis code will trigger mintReplBot() when the mint button is pressed, and breedReplBot() when the ReplBot breeding form is submitted. We'll invoke this function in init, by adding the following:\n\ninit\n\nasync\n\nfunction\n\nif\n\nwindow\n\nethereum\n\nawait\n\nwindow\n\nethereum\n\nrequest\n\nmethod\n\n'eth_requestAccounts'\n\nwindow\n\nweb3\n\nnew\n\nWeb3\n\nwindow\n\nethereum\n\n// Switch networks\n\nApp\n\nswitchToReplitTestnet\n\n// Interface with contract\n\nApp\n\nreplbotContract\n\nnew\n\nweb3\n\neth\n\nContract\n\nreplbotABI\n\nApp\n\nreplbotAddress\n\nApp\n\nbindEvents\n\n// <-- NEW LINE\n\nNext, let's create a function to display our NFT collection. This function will retrieve a list of the current user's NFTs and create an SVG for each of them. Add the following code below the definition of bindEvents:\n\npopulateCollection\n\nasync\n\nfunction\n\n// get bot IDs\n\nlet\n\nbotIds\n\nawait\n\nApp\n\ngetMyReplBotIds\n\n// get container\n\nlet\n\nbotContainer\n\ndocument\n\ngetElementById\n\n\"bots\"\n\nbotContainer\n\ninnerHTML\n\n\"\"\n\n// clear current content\n\n// create bot SVGs\n\nbotIds\n\nforEach\n\nid\n\n=>\n\nApp\n\ncreateReplBotSVG\n\nid\n\nthen\n\nresult\n\n=>\n\nbotContainer\n\nappendChild\n\nresult\n\nWe'll want to call this function periodically to keep our ReplBot collection up to date. We can use JavaScript's setInterval for this. Add a new line to the definition of bindEvents as below:\n\n// interface\n\nbindEvents\n\nfunction\n\n// mint\n\nconst\n\nmintButton\n\ndocument\n\ngetElementById\n\n\"mint\"\n\nmintButton\n\naddEventListener\n\n\"click\"\n\n=>\n\nApp\n\nmintReplBot\n\n// breed\n\nconst\n\nbreedForm\n\ndocument\n\ngetElementById\n\n\"breed\"\n\nbreedForm\n\naddEventListener\n\n\"submit\"\n\nevent\n\n=>\n\nevent\n\npreventDefault\n\nApp\n\nbreedReplBot\n\nbreedForm\n\nelements\n\n'parentOneId'\n\nvalue\n\nbreedForm\n\nelements\n\n'parentTwoId'\n\nvalue\n\n// show collection\n\nsetInterval\n\nApp\n\npopulateCollection\n\n5000\n\n// <-- new line\n\nThis will work, but it will recreate all of our SVGs once per second, which will usually be more than we need, and will cause the page to flash constantly. Let's add some caching to prevent this. First, we'll define a new attribute near the top of our App definition:\n\nApp\n\nreplbotAddress\n\n\"YOUR-CONTRACT-ADDRESS\"\n\nreplbotContract\n\nnull\n\nownedReplBots\n\n// <-- NEW\n\n...\n\nThis attribute will store our list of ReplBot IDs. Every time we call populateCollection, we'll first check whether the list we get from the contract matches our local list. If it does, we'll skip the rest of the function, otherwise, we'll update the cache and continue. Add the following new code to the populateCollection function:\n\npopulateCollection\n\nasync\n\nfunction\n\n// get bot IDs\n\nlet\n\nbotIds\n\nawait\n\nApp\n\ngetMyReplBotIds\n\n// === NEW CODE BELOW ===\n\n// check cache\n\nif\n\ncompareArrays\n\nbotIds\n\nApp\n\nownedReplBots\n\nreturn\n\n// array is unchanged\n\nelse\n\nApp\n\nownedReplBots\n\nbotIds\n\nslice\n\n// update cache and continue\n\n// === NEW CODE ABOVE ===\n\n// get container\n\nlet\n\nbotContainer\n\ndocument\n\ngetElementById\n\n\"bots\"\n\nbotContainer\n\ninnerHTML\n\n\"\"\n\n// create bot SVGs\n\nbotIds\n\nforEach\n\nid\n\n=>\n\nApp\n\ncreateReplBotSVG\n\nid\n\nthen\n\nresult\n\n=>\n\nbotContainer\n\nappendChild\n\nresult\n\nNote the use of slice() \u2013 this will ensure that ownedReplBots contains a copy of botIds rather than a reference to it.\n\nJavaScript does not have a built-in compareArrays() function, so we'll need to define one.", "start_char_idx": 12509, "end_char_idx": 16244, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "862d8b7d-3401-4963-9cd0-666a3639b16e": {"__data__": {"id_": "862d8b7d-3401-4963-9cd0-666a3639b16e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "668af67800b9fa5edacfe5bce4bce49142bc975cc8fb32d705a142ec187f3020", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f219ac9a-746b-4287-9303-cb659aa9c746", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}, "hash": "128fe2ee8f9623860f17f651bb82119586bfe0c873355e000c94505eefa402cf", "class_name": "RelatedNodeInfo"}}, "hash": "0773adddd63b0e19478b4b9175c4c2ce76925e21da8d68c2aa60c850ebf15b48", "text": "JavaScript does not have a built-in compareArrays() function, so we'll need to define one. Navigate to the top of frontend/app.js and add the following code below the definition of fetchSvg():\n\nfunction\n\ncompareArrays\n\narray1\n\narray2\n\n// arrays must be same length\n\nif\n\narray1\n\nlength\n\n!==\n\narray2\n\nlength\n\nreturn\n\nfalse\n\n// arrays must be sorted\n\nlet\n\narray1Sorted\n\narray1\n\nslice\n\nsort\n\nlet\n\narray2Sorted\n\narray2\n\nslice\n\nsort\n\n// all values must match\n\nfor\n\nlet\n\narray1\n\nlength\n\n++\n\nif\n\narray1Sorted\n\n!==\n\narray2Sorted\n\nreturn\n\nfalse\n\nreturn\n\ntrue\n\nThis function checks that our two arrays are the same length, sorts them and then compares each value. If a single value is different, it returns false, otherwise, it returns true.\n\nRunning our application\u200b\n\nTo run our frontend, we'll create a simple Node.js Express application. Create a file named frontend.js at the home directory of your repl and add the following code to it:\n\nconst\n\nexpress\n\nrequire\n\n\"express\"\n\nconst\n\napp\n\nexpress\n\nconst\n\nPORT\n\n433\n\napp\n\nuse\n\nexpress\n\nstatic\n\n\"frontend\"\n\napp\n\nlisten\n\nPORT\n\n=>\n\nconsole\n\nlog\n\nServer listening on port:\n\n${\n\nPORT\n\nThis script will serve the files we created in frontend. To make it execute when we run our repl, make sure that config files are showing and open .replit.\n\nIn .replit, replace the line run = \"node tools\" with the following:\n\nrun = \"node frontend.js\"\n\nRun your repl. You should now see your frontend. If you've minted any ReplBot NFTs already, those will also show up.\n\nWhere next?\u200b\n\nIn this two-part tutorial, we've built a fully functional decentralised application, but there's a lot more you can do to improve it. Some suggestions:\n\nImplement an interface for viewing ReplBot NFTs owned by other users.\n\nImplement an interface for transferring ReplBot tokens to other addresses.\n\nAlter the breeding form to show drop-down menus of the user's ReplBots.\n\nUse the contract event log to track ReplBot creations and births.\n\nChange the dapp's stylesheet.\n\nImplement frontend components for any of the new functions you added to the contract after completing part one!\n\nYour can find our repl below:\n\n< Previous: Web3\n\nNext: Robot NFT Part 1: on Ethereum blockchain >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nGetting started\n\nSetting up the front-end\n\nConnecting to the blockchain\n\nInterfacing with the smart contract\n\nRunning contract functions\n\nViewing and combining SVGs\n\nConnecting the UI\n\nRunning our application\n\nWhere next?", "start_char_idx": 16154, "end_char_idx": 18611, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"f6e75b60-50d9-47ba-89c6-b6940e8daabd": {"node_ids": ["7d62db4f-1a27-49ad-b3f2-e679ca5a83a6", "9b2341b4-2369-4199-8597-0f514f93a9c6", "e6ccf5f2-fd34-4def-b2ff-fc860ee05281", "0bef68ed-a9ff-4fb7-bc79-ff13573c7f41", "f219ac9a-746b-4287-9303-cb659aa9c746", "862d8b7d-3401-4963-9cd0-666a3639b16e"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/web3/build-a-robot-nft-p2.html"}}}, "docstore/metadata": {"7d62db4f-1a27-49ad-b3f2-e679ca5a83a6": {"doc_hash": "88a50235c825e2ea7a7c4bc781fd125c5d96c0ddae6d75b79f69f9d2dbfec91c", "ref_doc_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd"}, "9b2341b4-2369-4199-8597-0f514f93a9c6": {"doc_hash": "ff07d81ea0c7f1bda1beace3131bfbc0fe61722752710079876a5d2e524511d5", "ref_doc_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd"}, "e6ccf5f2-fd34-4def-b2ff-fc860ee05281": {"doc_hash": "02dfd72562a0112a790f49e4e7e1cc83ffe9f7809c8ba6312e0bf66be8c84c46", "ref_doc_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd"}, "0bef68ed-a9ff-4fb7-bc79-ff13573c7f41": {"doc_hash": "24ba8b993977615b94cf51c62f5be39cd82251864ed090cc9a3dddd7037fee8a", "ref_doc_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd"}, "f219ac9a-746b-4287-9303-cb659aa9c746": {"doc_hash": "128fe2ee8f9623860f17f651bb82119586bfe0c873355e000c94505eefa402cf", "ref_doc_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd"}, "862d8b7d-3401-4963-9cd0-666a3639b16e": {"doc_hash": "0773adddd63b0e19478b4b9175c4c2ce76925e21da8d68c2aa60c850ebf15b48", "ref_doc_id": "f6e75b60-50d9-47ba-89c6-b6940e8daabd"}}}