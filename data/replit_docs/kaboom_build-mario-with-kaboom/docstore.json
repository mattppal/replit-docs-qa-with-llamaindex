{"docstore/data": {"58f4f2e5-c5f7-4411-bb1f-e7bf4030119e": {"__data__": {"id_": "58f4f2e5-c5f7-4411-bb1f-e7bf4030119e", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0b1c3b50-a514-40bc-abfc-19dbcf067195", "node_type": "1", "metadata": {}, "hash": "fbda8576180f83528ec8b5e7e7ff398582c2df66ca66547eabea1034f03a071d", "class_name": "RelatedNodeInfo"}}, "hash": "bf1e6ba992d9fc10ae2b8ecb84cbda7fe37025041a93f1c63cf27e9927c1564b", "text": "\"shrubbery.png\"\n\nloadSprite\n\n\"hill\"\n\n\"hill.png\"\n\nloadSprite\n\n\"cloud\"\n\n\"cloud.png\"\n\nloadSprite\n\n\"castle\"\n\n\"castle.png\"\n\nThe first line, loadRoot, specifies which folder to load all the sprites and game elements from, so we don't have to keep typing it in for each sprite. Then each line loads a game sprite and gives it a name so that we can refer to it in code later.\n\nloadAseprite, and have an extra parameter specifying a\n\nAseprite, which is a pixel art and animation app. If you open the\n\n.play() method on a sprite. We can also choose a particular frame to show at any time, using the sprite's\n\n.frame property, and specifying the frame number to use, starting from 0.\n\nCreating the level maps\u200b\n\nLet's add 2 levels to start. You can create and add as many levels as you want - that's one of the great benefits of writing your own game!\n\nKaboom has a really cool way of defining levels. It allows us to draw a layout of the level using only text. Each letter or symbol in this text map can be mapped to a character in the Kaboom game. In Kaboom, characters are anything that makes up the game world, including floor, platforms, and so on, and not only the players and bots.\n\nAdd the following to define the levels:\n\nconst\n\nLEVELS\n\n\"                                                                                                \"\n\n\"                                                                                                \"\n\n\"                                                                                                \"\n\n\"                                                                                                \"\n\n\"                                                                                                \"\n\n\"                                                                                                \"\n\n\"                                                                                                \"\n\n\"      -?-b-                                                                                     \"\n\n\"                                                    ?        ?                                  \"\n\n\"                                                                                                \"\n\n\"                                      _                 ?                                       \"\n\n\"                                 _    |                                                         \"\n\n\"                           _     |    |                _                                        \"\n\n\"       E                   |     |    |   E   E        |                            H           \"\n\n\"================     ===========================================================================\"\n\n\"================     ===========================================================================\"\n\n\"                                                                                             \"\n\n\"                                                                                             \"\n\n\"                                                                                             \"\n\n\"                                       ?                                                     \"\n\n\"                                                                                             \"\n\n\"                                   -?-                                                       \"\n\n\"                                                                                             \"\n\n\"      -?-b-                  -?-                                                             \"\n\n\"                                                                                             \"\n\n\"                                                                                             \"\n\n\"                                                                                             \"\n\n\"                                                                                             \"\n\n\"       _                                            _                                        \"\n\n\"       |                                            |          E    E            H           \"\n\n\"================     ========================================================================\"\n\n\"================     ========================================================================\"\n\nNow we can map each symbol and letter in the levels to a character definition:\n\nconst\n\nlevelConf\n\n// grid size\n\nwidth\n\n16\n\nheight\n\n16\n\npos\n\nvec2\n\n// define each object as a list of components\n\n\"=\"\n\n=>\n\nsprite\n\n\"ground\"\n\narea\n\nsolid\n\norigin\n\n\"bot\"\n\n\"ground\"\n\n\"-\"\n\n=>\n\nsprite\n\n\"brick\"\n\narea\n\nsolid\n\norigin\n\n\"bot\"\n\n\"brick\"\n\n=>\n\nsprite\n\n\"castle\"\n\narea\n\nwidth\n\nheight\n\n240\n\norigin\n\n\"bot\"\n\n\"castle\"\n\n\"?\"\n\n=>\n\nsprite\n\n\"questionBox\"\n\narea\n\nsolid\n\norigin\n\n\"bot\"\n\n\"questionBox\"\n\n\"coinBox\"\n\n=>\n\nsprite\n\n\"questionBox\"\n\narea\n\nsolid\n\norigin\n\n\"bot\"\n\n\"questionBox\"\n\n\"mushyBox\"\n\n\"!\"\n\n=>\n\nsprite\n\n\"emptyBox\"\n\narea\n\nsolid\n\n// bump(),\n\norigin\n\n\"bot\"\n\n\"emptyBox\"\n\n=>\n\nsprite\n\n\"coin\"\n\narea\n\nsolid\n\n//bump(64, 8),\n\ncleanup\n\nlifespan\n\n0.4\n\nfade\n\n0.01\n\norigin\n\n\"bot\"\n\n\"coin\"\n\n=>\n\nsprite\n\n\"bigMushy\"\n\narea\n\nsolid\n\n//patrol(10000),\n\nbody\n\ncleanup\n\norigin\n\n\"bot\"\n\n\"bigMushy\"\n\n\"|\"\n\n=>\n\nsprite\n\n\"pipeBottom\"\n\narea\n\nsolid\n\norigin\n\n\"bot\"\n\n\"pipe\"\n\n=>\n\nsprite\n\n\"pipeTop\"\n\narea\n\nsolid\n\norigin\n\n\"bot\"\n\n\"pipe\"\n\n=>\n\nsprite\n\n\"enemies\"\n\nanim\n\n\"Walking\"\n\narea\n\nwidth\n\n16\n\nheight\n\n16\n\nsolid\n\nbody\n\n//patrol(50),\n\n//enemy(),\n\norigin\n\n\"bot\"\n\n\"badGuy\"\n\n=>\n\nsprite\n\n\"mario\"\n\nframe\n\narea\n\nwidth\n\n16\n\nheight\n\n16\n\nbody\n\n//mario(),\n\n//bump(150, 20, false),\n\norigin\n\n\"bot\"\n\n\"player\"\n\nThat looks like a lot, but it's really one pattern repeated for each element. Let's take it apart.\n\nThe first 3 lines of the config set the default width and height of each element in the level maps. We use pos to specify where to position the whole map in the Kaboom canvas. This is normally going to be (0,0), i.e. at the top left of the screen.", "start_char_idx": 0, "end_char_idx": 5966, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b1c3b50-a514-40bc-abfc-19dbcf067195": {"__data__": {"id_": "0b1c3b50-a514-40bc-abfc-19dbcf067195", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "58f4f2e5-c5f7-4411-bb1f-e7bf4030119e", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "bf1e6ba992d9fc10ae2b8ecb84cbda7fe37025041a93f1c63cf27e9927c1564b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8eff35ca-757c-48e2-9498-05d56189a3c6", "node_type": "1", "metadata": {}, "hash": "7de4fba645485b075b9b4bd688ca0c4b62085e0334195b9f020e112a7eeee014", "class_name": "RelatedNodeInfo"}}, "hash": "fbda8576180f83528ec8b5e7e7ff398582c2df66ca66547eabea1034f03a071d", "text": "Let's take it apart.\n\nThe first 3 lines of the config set the default width and height of each element in the level maps. We use pos to specify where to position the whole map in the Kaboom canvas. This is normally going to be (0,0), i.e. at the top left of the screen.\n\nNext we have definitions for each of the symbols we used in the map. Each definition is a function that returns an array of components. In Kaboom, every character is made up of 1 or more components. Components give special properties to each character. There are built-in components for many properties, like sprite to give the character an avatar, body, to make the character respond to gravity, solid to make the character solid so other characters can't move through it, and many others.\n\nKaboom also allows you to write your own custom components to create any property or behavior you like for a character. The components patrol, mario, enemy, and bump are all custom here. You'll notice that those custom components are commented out (//), as we'll need to create the implementations for them before we can use them. We'll do that later in this tutorial.\n\nAdding a scene\u200b\n\nKaboom \"scenes\" allow us to group logic and levels together. In this game we'll have 2 scenes:\n\nA \"start\" or intro scene, which waits for a player to press a button to start the game. We'll also return to this scene if the player dies, so they can start again.\n\nA main \"game\" scene, which will contain the game levels and all the logic to move Mario, and the logic for the enemies and rewards, etc.\n\nWe can use the go function to switch between scenes.\n\nLet's add the \"start\" scene, and make the game go to that scene by default:\n\nscene\n\n\"start\"\n\n=>\n\nadd\n\ntext\n\n\"Press enter to start\"\n\nsize\n\n24\n\npos\n\nvec2\n\n160\n\n120\n\norigin\n\n\"center\"\n\ncolor\n\n255\n\n255\n\n255\n\nonKeyRelease\n\n\"enter\"\n\n=>\n\ngo\n\n\"game\"\n\ngo\n\n\"start\"\n\nWe define the scene using the scene function. This function takes a string as the scene name \u2013 we're calling the scene \"start\". We're using an inline function here, using arrow function notation. You could also use the function keyword, if you'd like to specify a function in that way.\n\nWe also add some instruction text in the scene function, using the text component and setting the text's content and size. The pos component sets the position of the text on the screen, and the origin component specifies that the center of the text should be used to position it. Finally, we set the color of the text to white using the color component, which takes RGB (red, green, blue) values from 0-255.\n\nWe also have a call to the function onKeyRelease, which listens for the enter key being pressed. If the enter key is pressed, we go to the main game scene (which we'll add shortly!).\n\nFinally, we use the go function to go to the start scene when the game starts up.\n\nAfter copying the code into your repl, press Command + S (Mac) or Control + S (Windows/Linux) to update the output window. You should see something like this:\n\nNote that if you push enter now to start the game, you'll get an error message. Don't worry, we'll sort that out soon.\n\nAdding the main game scene\u200b\n\nNow let's get the game scene up and running. Add the code below:\n\nscene\n\n\"game\"\n\nlevelNumber\n\n=>\n\nlayers\n\n\"bg\"\n\n\"game\"\n\n\"ui\"\n\n\"game\"\n\nconst\n\nlevel\n\naddLevel\n\nLEVELS\n\nlevelNumber\n\nlevelConf\n\nadd\n\nsprite\n\n\"cloud\"\n\npos\n\n20\n\n50\n\nlayer\n\n\"bg\"\n\nadd\n\nsprite\n\n\"hill\"\n\npos\n\n32\n\n208\n\nlayer\n\n\"bg\"\n\norigin\n\n\"bot\"\n\nadd\n\nsprite\n\n\"shrubbery\"\n\npos\n\n200\n\n208\n\nlayer\n\n\"bg\"\n\norigin\n\n\"bot\"\n\nadd\n\ntext\n\n\"Level \"\n\nlevelNumber\n\nsize\n\n24\n\npos\n\nvec2\n\n160\n\n120\n\ncolor\n\n255\n\n255\n\n255\n\norigin\n\n\"center\"\n\nlayer\n\n\"ui\"\n\nlifespan\n\nfade\n\n0.5\n\nconst\n\nplayer\n\nlevel\n\nspawn\n\n\"p\"\n\n10\n\nPress Command + S or Control + S now, and push enter at the start screen prompt. You should see our replica of Mario World instead of the error message.\n\nYou should also see the enemy character wobble its feet, like it's trying to walk.", "start_char_idx": 5697, "end_char_idx": 9611, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8eff35ca-757c-48e2-9498-05d56189a3c6": {"__data__": {"id_": "8eff35ca-757c-48e2-9498-05d56189a3c6", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0b1c3b50-a514-40bc-abfc-19dbcf067195", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "fbda8576180f83528ec8b5e7e7ff398582c2df66ca66547eabea1034f03a071d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "96f39962-ef84-498f-91d4-57bc653f325c", "node_type": "1", "metadata": {}, "hash": "2516e24f088dbb075241305acaf063a82cc289c8166f3ee9ee433d88a811fff8", "class_name": "RelatedNodeInfo"}}, "hash": "7de4fba645485b075b9b4bd688ca0c4b62085e0334195b9f020e112a7eeee014", "text": "You should see our replica of Mario World instead of the error message.\n\nYou should also see the enemy character wobble its feet, like it's trying to walk. This is because when we added the enemy definition E in the level config, we specified in the sprite component that it must use the Walking animation, which is defined in the enemies.json file. Kaboom starts the character using that animation.\n\nOk, back to looking at the code we added and what it does. First, we define a new scene like we did for the start scene. This time, we specify a parameter levelNumber that can be passed to the scene. We give this parameter a default value of 0. This will be the first level in our LEVELS array - remember, arrays start at index 0, so 0 is level 1. This parameter will let us call the same scene again when we get to the end of the level, but with 1 as the parameter so that we can play the next level. You can specify any parameters you like or need when creating a scene, and you can pass values from one scene to another. This is very useful, for example if you want to pass the player score to an end game scene, or pass in player options from the start scene.\n\nlayers. Layers allow us to have backgrounds that don't affect the game - we call that layer\n\nIn the next line of code, we initialize and create the level by calling the addLevel function. Here we pass in the level from the LEVELS array, using the index from the levelNumber parameter we added to the scene. We also pass in the configuration for all the symbols in the level map that we assigned to the levelConf variable. At this point, the map and all the characters in it are drawn to the screen. Note that, because the map is much wider than the size we set in the settings for the Kaboom window, we only see part of the map. This is great, because it will allow us to show more of the map as Mario starts walking.\n\nThen we add a few elements to the background layer - clouds, hills and shrubberies. Note the use of the layer component on these elements. We do this so that they don't interact with our game objects - they just add some visual interest. You can add as many as you like - the original Mario has them in a repeating pattern across the whole level.\n\nWe also add some temporary text to the ui layer to let the player know which level they are on. Notice that we use the lifespan component here to automatically fade out and remove the info text after 1 second.\n\nFinally, we add Mario to the game! We could have added him by placing his symbol, p, on our level map definition. However, by adding him manually to the scene using level.spawn(), we can get a reference to him. This will be useful later when we are dealing with collisions and other interactions. We also set the position we want the character to initially be placed at.\n\nMaking Mario move\u200b\n\nThe scene is all set up, so let's add in some interaction. The player will use the arrow keys to move Mario left and right, and the space bar to make him jump. We'll use the onKeyDown function for moving left and right, as we want Mario to keep moving as long as the player holds down either key. Then we can use the onKeyPress function to make Mario jump. The player will need to push the space key each time they want Mario to jump - it's always fun to smash buttons! Add the following code at the bottom of the game scene:\n\nconst\n\nSPEED\n\n120\n\nonKeyDown\n\n\"right\"\n\n=>\n\nplayer\n\nflipX\n\nfalse\n\nplayer\n\nmove\n\nSPEED\n\nonKeyDown\n\n\"left\"\n\n=>\n\nplayer\n\nflipX\n\ntrue\n\nif\n\ntoScreen\n\nplayer\n\npos\n\n20\n\nplayer\n\nmove\n\nSPEED\n\nonKeyPress\n\n\"space\"\n\n=>\n\nif\n\nplayer\n\ngrounded\n\nplayer\n\njump\n\nsprite component. If this is\n\npos component. Our\n\nIn the \"left\" handler, there is also another check. In Mario, you can't walk back to previous parts of a level once it's gone off screen. We can simulate this by checking if Mario is near the left edge of the screen. We get Mario's current position by calling the pos method which is added by the pos component. However, this position will be relative to the whole level, and not just the onscreen view.", "start_char_idx": 9456, "end_char_idx": 13515, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96f39962-ef84-498f-91d4-57bc653f325c": {"__data__": {"id_": "96f39962-ef84-498f-91d4-57bc653f325c", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8eff35ca-757c-48e2-9498-05d56189a3c6", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "7de4fba645485b075b9b4bd688ca0c4b62085e0334195b9f020e112a7eeee014", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b0147196-013e-4af6-8ec6-668e9f568952", "node_type": "1", "metadata": {}, "hash": "b53f94e3b9db0fc0589bb16dc6aaa7578972a19df1dc1b7f1b125972d152f4b6", "class_name": "RelatedNodeInfo"}}, "hash": "2516e24f088dbb075241305acaf063a82cc289c8166f3ee9ee433d88a811fff8", "text": "If this is\n\npos component. Our\n\nIn the \"left\" handler, there is also another check. In Mario, you can't walk back to previous parts of a level once it's gone off screen. We can simulate this by checking if Mario is near the left edge of the screen. We get Mario's current position by calling the pos method which is added by the pos component. However, this position will be relative to the whole level, and not just the onscreen view. To help us figure out if Mario is near the edge of the screen, and not just at the beginning of the level, we can use the toScreen function, which converts \"game world\" or level co-ordinates to actual screen co-ordinates.\n\njump method, which is added to the character through the\n\nbody component. However,\n\nsolid object. The\n\nbody component also adds the\n\ngrounded() function, which returns\n\nPress Command + S or Control + S to update the output, and test it out. Mario should move around, but it doesn't look very natural and Mario-like - yet! Another thing you'll notice is that the screen does not scroll when Mario walks to the right, so we can't get to the rest of the level. Let's fix that first.\n\nAdding scrolling\u200b\n\nKaboom has a number of functions to control the \"camera\" of the scene. The camera represents the field of view that the player can see. At the moment, the camera only shows the first part of the level. By using the camPos function, we can move the camera to show more of the level as Mario walks across the scene.\n\nLet's add this code to the game scene:\n\nplayer\n\nonUpdate\n\n=>\n\n// center camera to player\n\nvar\n\ncurrCam\n\ncamPos\n\nif\n\ncurrCam\n\nplayer\n\npos\n\ncamPos\n\nplayer\n\npos\n\ncurrCam\n\nHere we add a handler to the onUpdate event for the player. This is called for each frame that is rendered. In this handler, we get the camera's current position by calling the camPos function without any arguments. Then we can check if Mario is further to the right of the scene than the camera is. If he is, then we set the camera's X position to that of Mario, so essentially the camera is following Mario. We only do this if he is further to the right of the camera, and not for positions further to the left. This is because we don't want the player to be able to go back on a level.\n\nUpdate the output again and test it out. As you move Mario past the center of the screen, the camera should start following him, giving the sense of scrolling.\n\nCreating a custom component\u200b\n\nTo add more abilities to the characters and features to the game, we'll use components that we create ourselves and can add to our games objects. To define a new component in Kaboom, we make a function that returns an object with a few required fields and methods. Here's a template to illustrate code for a custom component (not part of the game code):\n\nfunction\n\ncustomComponent\n\nargs\n\nreturn\n\nid\n\n\"name\"\n\nrequire\n\n\"component1\"\n\n\"component2\"\n\nadd\n\nupdate\n\nIn the object we return, Kaboom requires an id, which is a unique name for the component. Kaboom also needs a require property, which is a list of other components this component needs in order to work. When a component is first initialized on a game object, Kaboom calls the add() method so we have the opportunity to run any setup code we need. The method update() is called on every game frame, so we can make animation and collision updates there.\n\nOne behavior we need is for the enemy characters to walk up and down, instead of just standing in one place. Let's make a custom component we can add to our enemy characters so that they automatically move back and forth, or patrol their part of the level.", "start_char_idx": 13080, "end_char_idx": 16670, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b0147196-013e-4af6-8ec6-668e9f568952": {"__data__": {"id_": "b0147196-013e-4af6-8ec6-668e9f568952", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "96f39962-ef84-498f-91d4-57bc653f325c", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "2516e24f088dbb075241305acaf063a82cc289c8166f3ee9ee433d88a811fff8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7f7fd200-a797-4978-becc-65ac39a1b597", "node_type": "1", "metadata": {}, "hash": "20574d7b62ab7d48e2067623378fa21392a592d015e84421ab026a8739231d2c", "class_name": "RelatedNodeInfo"}}, "hash": "b53f94e3b9db0fc0589bb16dc6aaa7578972a19df1dc1b7f1b125972d152f4b6", "text": "Kaboom also needs a require property, which is a list of other components this component needs in order to work. When a component is first initialized on a game object, Kaboom calls the add() method so we have the opportunity to run any setup code we need. The method update() is called on every game frame, so we can make animation and collision updates there.\n\nOne behavior we need is for the enemy characters to walk up and down, instead of just standing in one place. Let's make a custom component we can add to our enemy characters so that they automatically move back and forth, or patrol their part of the level. Add the code below to the bottom of main.js:\n\nfunction\n\npatrol\n\ndistance\n\n100\n\nspeed\n\n50\n\ndir\n\nreturn\n\nid\n\n\"patrol\"\n\nrequire\n\n\"pos\"\n\n\"area\"\n\nstartingPos\n\nvec2\n\nadd\n\nthis\n\nstartingPos\n\nthis\n\npos\n\nthis\n\non\n\n\"collide\"\n\nobj\n\nside\n\n=>\n\nif\n\nside\n\n===\n\n\"left\"\n\n||\n\nside\n\n===\n\n\"right\"\n\ndir\n\ndir\n\nupdate\n\nif\n\nMath\n\nabs\n\nthis\n\npos\n\nthis\n\nstartingPos\n\n>=\n\ndistance\n\ndir\n\ndir\n\nthis\n\nmove\n\nspeed\n\ndir\n\npos component), and the\n\narea component), we add the\n\ncollide handler, so we know if the character bumps into anything, so we can turn it and move it in the opposite direction again.\n\ncollide handler has 2 arguments passed to it: the\n\nMath.abs function, which returns the absolute value of a number. The absolute value of a number is always positive, and this allows us to compare it to our\n\npos component) and use the\n\nNow that we've created this component, let's use it on a character. Uncomment the lines //patrol wherever you see it in the levelConf setup we created. Update the output and test it out. You should see the enemy character walk back and forth.\n\nYou'll notice we also make use of the patrol component on the bigMushy character, which we'll use to make Mario grow from small Mario to big Mario. We'll get to that in a bit.\n\nCreating a custom component for the enemies\u200b\n\nNow that the enemies are moving around, we can give them some more behaviors and properties. One of the most important things to do is to squash the enemies if Mario jumps on them. If you take a look at the enemies.png sprite file, you'll see that the 3rd frame (index 2) is an image of the enemy, but squashed.\n\nWe can swap out the animation that is played when the enemy is patrolling for this frame. Kaboom has a built in lifespan component that also has a fade out function. This component allows us to slowly fade out the squashed enemy from the scene, and then automatically remove it entirely once the specified lifetime is reached. Kaboom also allows us to dynamically add and remove components from characters using the use and unuse methods. These methods are not yet documented, but you can find them (and more tricks!) by looking at the Kaboom source code. Let's use this knowledge to build a custom component to handle the enemy getting squashed and fading out of the scene:\n\nfunction\n\nenemy\n\nreturn\n\nid\n\n\"enemy\"\n\nrequire\n\n\"pos\"\n\n\"area\"\n\n\"sprite\"\n\n\"patrol\"\n\nisAlive\n\ntrue\n\nupdate\n\nsquash\n\nthis\n\nisAlive\n\nfalse\n\nthis\n\nunuse\n\n\"patrol\"\n\nthis\n\nstop\n\nthis\n\nframe\n\nthis\n\narea\n\nwidth\n\n16\n\nthis\n\narea\n\nheight\n\nthis\n\nuse\n\nlifespan\n\n0.5\n\nfade\n\n0.1\n\nWe define the custom component as we did before. Because we need to stop the enemy from patrolling, we require the patrol custom component. We also require the sprite component so we can stop the animation and set the squashed frame to display. The area component is necessary, as the squashed enemy frame is half the height of the regular enemy frames (8 pixels vs 16 pixels). We're going to need to adjust the height of the area so that the collision zone the enemy occupies once squashed is correct.\n\nAs a side note, pressing F1 in the game turns on Kaboom debugging, which will draw the area box around each game element, so you can easily see when characters collide. It also shows other handy info, like the frame rate and character properties.\n\nsprite component. Calling\n\narea width and height to be the same size as the frame. Finally, we call\n\nlifespan component so that the character is removed from the scene after\n\nNow let's add this custom component to the enemy.", "start_char_idx": 16051, "end_char_idx": 20175, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7f7fd200-a797-4978-becc-65ac39a1b597": {"__data__": {"id_": "7f7fd200-a797-4978-becc-65ac39a1b597", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b0147196-013e-4af6-8ec6-668e9f568952", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "b53f94e3b9db0fc0589bb16dc6aaa7578972a19df1dc1b7f1b125972d152f4b6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d373d4aa-8bdc-48eb-827a-0f793087636a", "node_type": "1", "metadata": {}, "hash": "8e23ff8e8f3c10213128ece11760e0c126a1f2aed8d9ff36acbd04426f1d502b", "class_name": "RelatedNodeInfo"}}, "hash": "20574d7b62ab7d48e2067623378fa21392a592d015e84421ab026a8739231d2c", "text": "We also require the sprite component so we can stop the animation and set the squashed frame to display. The area component is necessary, as the squashed enemy frame is half the height of the regular enemy frames (8 pixels vs 16 pixels). We're going to need to adjust the height of the area so that the collision zone the enemy occupies once squashed is correct.\n\nAs a side note, pressing F1 in the game turns on Kaboom debugging, which will draw the area box around each game element, so you can easily see when characters collide. It also shows other handy info, like the frame rate and character properties.\n\nsprite component. Calling\n\narea width and height to be the same size as the frame. Finally, we call\n\nlifespan component so that the character is removed from the scene after\n\nNow let's add this custom component to the enemy. First, uncomment the //enemy(), line in the levelConf setup we created earlier. Now create a collision handler in the game scene between Mario and the enemy, so we know when it gets squashed:\n\nlet\n\ncanSquash\n\nfalse\n\nplayer\n\nonCollide\n\n\"badGuy\"\n\nbaddy\n\n=>\n\nif\n\nbaddy\n\nisAlive\n\n==\n\nfalse\n\nreturn\n\nif\n\ncanSquash\n\n// Mario has jumped on the bad guy:\n\nbaddy\n\nsquash\n\nelse\n\n// Mario has been hurt. Add logic here later...\n\nModify the onKeyPress handler for the space key as follows:\n\nonKeyPress\n\n\"space\"\n\n=>\n\nif\n\nplayer\n\ngrounded\n\nplayer\n\njump\n\ncanSquash\n\ntrue\n\nHere, we set the canSquash variable to true to allow the player to squash the enemy if the player has jumped over it upon collision.\n\nAdd the following code to the player.onUpdate handler:\n\nif\n\nplayer\n\ngrounded\n\ncanSquash\n\nfalse\n\nThis code will reset the canSquash variable so that the player will not squash the enemy if it hasn't jumped over it in the collision handler we added earlier.\n\nUpdate the output and test our game out. If you jump on an enemy, it should be squashed and then disappear after half a second.\n\nHeadbutting surprise boxes\u200b\n\nAnother key Mario action is headbutting the surprise boxes (the ones with \"?\" on them). In Mario World, this could release a coin, a super mushroom (one that makes Mario grow bigger), etc. When Mario headbutts these boxes, the box is 'bumped' and moves up and down quickly, while releasing its surprise. Once the box is empty, the \"?\" is removed from it. Let's create the logic to control these boxes. As above, we'll make more use of custom components.\n\nWe'll take care of the boxes for coins and for the grow-bigger mushrooms. If you take a look in the levelConf setup we added in the beginning, you'll see entries for coin and mushroom \"question boxes\". The only real difference between the two is the final tag, which marks which surprise the box should release. We also have definitions for an empty box (!), the coin (c), and the mushroom (M).\n\nLet's create a component that makes the box jump up and fall back down when it is headbutted. We can also re-use it on the coin to make it flip as it's bumped out of the box. We'll call this new component bump:\n\nfunction\n\nbump\n\noffset\n\nspeed\n\nstopAtOrigin\n\ntrue\n\nreturn\n\nid\n\n\"bump\"\n\nrequire\n\n\"pos\"\n\nbumpOffset\n\noffset\n\nspeed\n\nspeed\n\nbumped\n\nfalse\n\norigPos\n\ndirection\n\nupdate\n\nif\n\nthis\n\nbumped\n\nthis\n\npos\n\nthis\n\npos\n\nthis\n\ndirection\n\nthis\n\nspeed\n\nif\n\nthis\n\npos\n\nthis\n\norigPos\n\nthis\n\nbumpOffset\n\nthis\n\ndirection\n\nif\n\nstopAtOrigin\n\n&&\n\nthis\n\npos\n\n>=\n\nthis\n\norigPos\n\nthis\n\nbumped\n\nfalse\n\nthis\n\npos\n\nthis\n\norigPos\n\nthis\n\ndirection\n\nbump\n\nthis\n\nbumped\n\ntrue\n\nthis\n\norigPos\n\nthis\n\npos\n\nThis looks a bit more complicated than our other custom components, but that's only because it has code for the object moving in both directions. First off, we have a few parameters when creating this component:\n\noffset is how far up we want the object to be bumped before settling down again.\n\nspeed is how fast we want it to move when bumped.", "start_char_idx": 19339, "end_char_idx": 23155, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d373d4aa-8bdc-48eb-827a-0f793087636a": {"__data__": {"id_": "d373d4aa-8bdc-48eb-827a-0f793087636a", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7f7fd200-a797-4978-becc-65ac39a1b597", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "20574d7b62ab7d48e2067623378fa21392a592d015e84421ab026a8739231d2c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2e5767a7-5566-4b8c-ba28-3ac339ebb081", "node_type": "1", "metadata": {}, "hash": "207d395e050ecaf073e6b1fdde775e221c819da39315fe147bb27cd789f18444", "class_name": "RelatedNodeInfo"}}, "hash": "8e23ff8e8f3c10213128ece11760e0c126a1f2aed8d9ff36acbd04426f1d502b", "text": "First off, we have a few parameters when creating this component:\n\noffset is how far up we want the object to be bumped before settling down again.\n\nspeed is how fast we want it to move when bumped.\n\nstopAtOrigin specifies whether we want the object to return to its original position after being bumped, or just keep falling down - if this parameter is false, then bumping the object will make it look like it got dislodged and it will fall down.\n\nThe object this component is added to must also have the pos component. We'll use that to move the object when it is bumped.\n\nNext, we have a check to see if the flag stopAtOrigin is set. If the object has fallen down to its original position (or further), we set the bumped flag back to false and update the object's position exactly back to its original position. We also set the direction flag back to -1, so the object is back in a state that it can be bumped again.\n\nNow that this bump component exists, you can uncomment the //bump(), lines in the levelConf setup we created earlier.\n\nTo trigger the bump and add the code to make the surprise come out, we'll need to add a collision handler. Believe it or not, Kaboom has a special case collision event called headbutt (which is not documented, but you can also find it in the source code) just for this type of thing!\n\nplayer\n\non\n\n\"headbutt\"\n\nobj\n\n=>\n\nif\n\nobj\n\nis\n\n\"questionBox\"\n\nif\n\nobj\n\nis\n\n\"coinBox\"\n\nlet\n\ncoin\n\nlevel\n\nspawn\n\n\"c\"\n\nobj\n\ngridPos\n\nsub\n\ncoin\n\nbump\n\nelse\n\nif\n\nobj\n\nis\n\n\"mushyBox\"\n\nlevel\n\nspawn\n\n\"M\"\n\nobj\n\ngridPos\n\nsub\n\nvar\n\npos\n\nobj\n\ngridPos\n\ndestroy\n\nobj\n\nvar\n\nbox\n\nlevel\n\nspawn\n\n\"!\"\n\npos\n\nbox\n\nbump\n\nIn the handler for headbutt, we are passed the object, obj, that the player headbutted. We check to see if it is indeed one of our questionBox objects. If it is, we check if it is a coinBox (a coin must pop out) or a mushyBox (a grow-bigger mushroom should pop out).\n\nIf it is a coinBox, we spawn a new coin 1 block above the coin box, using the configuration c we setup for a coin in the levelConf in the beginning. Then we call bump on the coin to invoke our custom component's method to make it appear to flip up out of the box.\n\nIf it is a mushyBox, we do the same, except we don't bump the mushroom. The mushroom has our custom patrol component added to it (check in the levelConf for M), so it will start moving immediately. We set the patrol distance very large on the mushroom so it won't automatically turn around, it will just keep going until if falls of the screen.\n\ndestroy it, and\n\nCool, time to update the output and test this out. When you jump up using the space key and headbutt the question boxes now, they should move and have things pop out!\n\nAdding special behaviors to Mario\u200b\n\nNow we've got the basics of all the other game elements down, it's time to create a custom component for Mario himself. This component will need to do quite a bit, as Mario is the main character. Here are the things it will need to handle:\n\nMake Mario get bigger or smaller.\n\nRun the \"running\" animation when Mario is running, and change to a standing or jumping frame in other cases.\n\n\"Freeze\" Mario when he gets to the castle or has died, so the player can no longer move him.\n\nHandle Mario dying, with a classic spring up and out of the scene.", "start_char_idx": 22957, "end_char_idx": 26226, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2e5767a7-5566-4b8c-ba28-3ac339ebb081": {"__data__": {"id_": "2e5767a7-5566-4b8c-ba28-3ac339ebb081", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d373d4aa-8bdc-48eb-827a-0f793087636a", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "8e23ff8e8f3c10213128ece11760e0c126a1f2aed8d9ff36acbd04426f1d502b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29e4ea66-ae11-4788-afe4-3c6c6946ede7", "node_type": "1", "metadata": {}, "hash": "255d550b82827246cc6ae3dc626c9d775602939b0a9945242596db182682eb7a", "class_name": "RelatedNodeInfo"}}, "hash": "207d395e050ecaf073e6b1fdde775e221c819da39315fe147bb27cd789f18444", "text": "destroy it, and\n\nCool, time to update the output and test this out. When you jump up using the space key and headbutt the question boxes now, they should move and have things pop out!\n\nAdding special behaviors to Mario\u200b\n\nNow we've got the basics of all the other game elements down, it's time to create a custom component for Mario himself. This component will need to do quite a bit, as Mario is the main character. Here are the things it will need to handle:\n\nMake Mario get bigger or smaller.\n\nRun the \"running\" animation when Mario is running, and change to a standing or jumping frame in other cases.\n\n\"Freeze\" Mario when he gets to the castle or has died, so the player can no longer move him.\n\nHandle Mario dying, with a classic spring up and out of the scene.\n\nOk, here it is, our Mario custom component:\n\nfunction\n\nmario\n\nreturn\n\nid\n\n\"mario\"\n\nrequire\n\n\"body\"\n\n\"area\"\n\n\"sprite\"\n\n\"bump\"\n\nsmallAnimation\n\n\"Running\"\n\nbigAnimation\n\n\"RunningBig\"\n\nsmallStopFrame\n\nbigStopFrame\n\nsmallJumpFrame\n\nbigJumpFrame\n\n13\n\nisBig\n\nfalse\n\nisFrozen\n\nfalse\n\nisAlive\n\ntrue\n\nupdate\n\nif\n\nthis\n\nisFrozen\n\nthis\n\nstanding\n\nreturn\n\nif\n\nthis\n\ngrounded\n\nthis\n\njumping\n\nelse\n\nif\n\nkeyIsDown\n\n\"left\"\n\n||\n\nkeyIsDown\n\n\"right\"\n\nthis\n\nrunning\n\nelse\n\nthis\n\nstanding\n\nbigger\n\nthis\n\nisBig\n\ntrue\n\nthis\n\narea\n\nwidth\n\n24\n\nthis\n\narea\n\nheight\n\n32\n\nsmaller\n\nthis\n\nisBig\n\nfalse\n\nthis\n\narea\n\nwidth\n\n16\n\nthis\n\narea\n\nheight\n\n16\n\nstanding\n\nthis\n\nstop\n\nthis\n\nframe\n\nthis\n\nisBig\n\nthis\n\nbigStopFrame\n\nthis\n\nsmallStopFrame\n\njumping\n\nthis\n\nstop\n\nthis\n\nframe\n\nthis\n\nisBig\n\nthis\n\nbigJumpFrame\n\nthis\n\nsmallJumpFrame\n\nrunning\n\nconst\n\nanimation\n\nthis\n\nisBig\n\nthis\n\nbigAnimation\n\nthis\n\nsmallAnimation\n\nif\n\nthis\n\ncurAnim\n\n!==\n\nanimation\n\nthis\n\nplay\n\nanimation\n\nfreeze\n\nthis\n\nisFrozen\n\ntrue\n\ndie\n\nthis\n\nunuse\n\n\"body\"\n\nthis\n\nbump\n\nthis\n\nisAlive\n\nfalse\n\nthis\n\nfreeze\n\nthis\n\nuse\n\nlifespan\n\nfade\n\nFirstly, we require the character to have a few other components: body, so we can determine if Mario is jumping or on the ground; area, so we can change the collision box area of Mario as he grows or shrinks; sprite, so we can start and stop animations and set static frames; and our custom bump component, so we can throw Mario off the screen if he dies.\n\nIf we measure the size of the big Mario images, we'll see that the tightest crop we can get on them is about 24x32 pixels. For small Mario, the size is 16x16 pixels. We'll use this knowledge to set the correct Mario animation and area collision boxes when changing between animations and sizes.\n\nIn the mario component, we define a number of custom methods. Let's go through them.\n\nThe bigger and smaller methods provide a way to change the size of Mario. We set a flag isBig that we check in the other methods to choose appropriate animations and frames. We also set the collision area size appropriate for the size of Mario.\n\nThe standing and jumping methods are called from our main update method, which is called with each frame. In these 2 methods, we stop any animation that is currently running using the stop method provided by the sprite component. Then, depending on the size of Mario, determined by the isBig flag, we set the appropriate static frame to make Mario look like he is standing still or jumping.\n\nIn the running method, we find the correct running animation depending on whether Mario is big or small. Then we check if that animation is the same animation that Mario is currently using, by calling the curAnim method provided by the sprite component. If they are not the same, we update the current animation by calling play to start the new animation. We first check the current animation because, if we set the animation regardless of what is currently playing, we'd keep resetting the current animation to the beginning with each frame and make it appear as a static frame.\n\nThe freeze method sets a flag isFrozen, which is used in the update method to determine whether Mario can move.\n\nWhen Mario is killed, we can call the die method. This first removes the body component on Mario so that he is no longer subject to gravity or collisions, because these are things that ghosts are not worried about.", "start_char_idx": 25459, "end_char_idx": 29581, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "29e4ea66-ae11-4788-afe4-3c6c6946ede7": {"__data__": {"id_": "29e4ea66-ae11-4788-afe4-3c6c6946ede7", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2e5767a7-5566-4b8c-ba28-3ac339ebb081", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "207d395e050ecaf073e6b1fdde775e221c819da39315fe147bb27cd789f18444", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7652e70d-7b8d-4ad2-a6d6-7f2475a4b923", "node_type": "1", "metadata": {}, "hash": "286358c63d6e1a9975b7ac52331c3dc91a1f09199c0217f4bf21ee2ea87d9428", "class_name": "RelatedNodeInfo"}}, "hash": "255d550b82827246cc6ae3dc626c9d775602939b0a9945242596db182682eb7a", "text": "In the running method, we find the correct running animation depending on whether Mario is big or small. Then we check if that animation is the same animation that Mario is currently using, by calling the curAnim method provided by the sprite component. If they are not the same, we update the current animation by calling play to start the new animation. We first check the current animation because, if we set the animation regardless of what is currently playing, we'd keep resetting the current animation to the beginning with each frame and make it appear as a static frame.\n\nThe freeze method sets a flag isFrozen, which is used in the update method to determine whether Mario can move.\n\nWhen Mario is killed, we can call the die method. This first removes the body component on Mario so that he is no longer subject to gravity or collisions, because these are things that ghosts are not worried about. Then we call the bump method that is added by our custom bump component. This shoots Mario up into the air, and back down again. We also set the isAlive flag to false, to signal to any collision handlers that Mario is dead before they try kill him again, or give him a 1-up mushroom or coin. We freeze() Mario so that he reverts to a standing pose and keyboard input doesn't affect him, and finally, we use the lifespan component to fade Mario out and remove him from the scene.\n\nbody component. This method returns\n\nIf Mario is not jumping, i.e. he is grounded, then we check if the user currently has the left or right key down. If so, this means Mario is running(). The final condition is if Mario is on the ground but is not moving, then he must be standing().\n\nNice! Uncomment the mario component line in the levelConf to activate this new component on Mario. Update the output and test the animation changes out. Instead of Mario in a single pose, you should see an animation as he runs, changing to a static frame as he stands still or jumps.\n\nNow we can hook up collision handlers to check if Mario has eaten the mushroom to grow larger, or if he gets injured or killed by an enemy or falling off the screen.\n\nAdding more Mario collisions and events\u200b\n\nFirst, let's add a collision handler between the mushroom and Mario. Then we can call our bigger method from our custom mario component to grow him.\n\nplayer\n\nonCollide\n\n\"bigMushy\"\n\nmushy\n\n=>\n\ndestroy\n\nmushy\n\nplayer\n\nbigger\n\nIn this handler, we remove the mushroom from the scene, and then make Mario bigger().\n\nLet's add some more code to the handler we created earlier for Mario colliding with an enemy. There, we only handled the case of Mario jumping on the enemy. We still need to account for Mario being injured or killed by the enemy. Update the badGuy collision handler like this:\n\nplayer\n\nonCollide\n\n\"badGuy\"\n\nbaddy\n\n=>\n\nif\n\nbaddy\n\nisAlive\n\n==\n\nfalse\n\nreturn\n\nif\n\nplayer\n\nisAlive\n\n==\n\nfalse\n\nreturn\n\nif\n\ncanSquash\n\n// Mario has jumped on the bad guy:\n\nbaddy\n\nsquash\n\nelse\n\n// Mario has been hurt\n\nif\n\nplayer\n\nisBig\n\nplayer\n\nsmaller\n\nelse\n\n// Mario is dead :(\n\nkilled\n\nWe add in a condition at the top of the handler to exit early if Mario is not alive.\n\nIn the else condition, if Mario did not squash the bad guy, we check if we are dealing with big Mario. If so, Mario World rules are that he doesn't die, he just gets smaller(). However, if Mario is already small, he unfortunately is now dead. We call out to another function killed to handle Mario's death scene. Let's add that function:\n\nfunction\n\nkilled\n\n// Mario is dead :(\n\nif\n\nplayer\n\nisAlive\n\n==\n\nfalse\n\nreturn\n\n// Don't run it if mario is already dead\n\nplayer\n\ndie\n\nadd\n\ntext\n\n\"Game Over :(\"\n\nsize\n\n24\n\npos\n\ntoWorld\n\nvec2\n\n160\n\n120\n\ncolor\n\n255\n\n255\n\n255\n\norigin\n\n\"center\"\n\nlayer\n\n\"ui\"\n\nwait\n\n=>\n\ngo\n\n\"start\"\n\nadd some\n\ntext to notify the player that the game is over. We\n\nwait for 2 seconds as we pay Mario our final respects, and then we\n\ngo back to the start scene to play again.\n\nAnother way Mario can die in Mario World is if he falls off the platform into the void.", "start_char_idx": 28673, "end_char_idx": 32681, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7652e70d-7b8d-4ad2-a6d6-7f2475a4b923": {"__data__": {"id_": "7652e70d-7b8d-4ad2-a6d6-7f2475a4b923", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29e4ea66-ae11-4788-afe4-3c6c6946ede7", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "255d550b82827246cc6ae3dc626c9d775602939b0a9945242596db182682eb7a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24d99564-b3ee-4acd-8e84-355e5df49559", "node_type": "1", "metadata": {}, "hash": "b63e8df362896bda18fb1802b072fb350e1fcbf13162283ded2ab20b2f5b0ebe", "class_name": "RelatedNodeInfo"}}, "hash": "286358c63d6e1a9975b7ac52331c3dc91a1f09199c0217f4bf21ee2ea87d9428", "text": "However, if Mario is already small, he unfortunately is now dead. We call out to another function killed to handle Mario's death scene. Let's add that function:\n\nfunction\n\nkilled\n\n// Mario is dead :(\n\nif\n\nplayer\n\nisAlive\n\n==\n\nfalse\n\nreturn\n\n// Don't run it if mario is already dead\n\nplayer\n\ndie\n\nadd\n\ntext\n\n\"Game Over :(\"\n\nsize\n\n24\n\npos\n\ntoWorld\n\nvec2\n\n160\n\n120\n\ncolor\n\n255\n\n255\n\n255\n\norigin\n\n\"center\"\n\nlayer\n\n\"ui\"\n\nwait\n\n=>\n\ngo\n\n\"start\"\n\nadd some\n\ntext to notify the player that the game is over. We\n\nwait for 2 seconds as we pay Mario our final respects, and then we\n\ngo back to the start scene to play again.\n\nAnother way Mario can die in Mario World is if he falls off the platform into the void. We can check for this by modifying the player.onUpdate handler we added earlier for moving the camera:\n\nplayer\n\nonUpdate\n\n=>\n\n// center camera to player\n\nvar\n\ncurrCam\n\ncamPos\n\nif\n\ncurrCam\n\nplayer\n\npos\n\ncamPos\n\nplayer\n\npos\n\ncurrCam\n\nif\n\nplayer\n\nisAlive\n\n&&\n\nplayer\n\ngrounded\n\ncanSquash\n\nfalse\n\n// Check if Mario has fallen off the screen\n\nif\n\nplayer\n\npos\n\nheight\n\n16\n\nkilled\n\nHere, we check if Mario's y co-ordinate is greater than the height of the Kaboom window, less the size of one platform block, which is 16 pixels. If this is the case, it means Mario has fallen off the top row of the platform, and therefore has been killed().\n\nWe also need to update our left and right key handler events to check if Mario isFrozen. In this case the handlers should just return early without moving Mario:\n\nonKeyDown\n\n\"right\"\n\n=>\n\nif\n\nplayer\n\nisFrozen\n\nreturn\n\nplayer\n\nflipX\n\nfalse\n\nplayer\n\nmove\n\nSPEED\n\nonKeyDown\n\n\"left\"\n\n=>\n\nif\n\nplayer\n\nisFrozen\n\nreturn\n\nplayer\n\nflipX\n\ntrue\n\nif\n\ntoScreen\n\nplayer\n\npos\n\n20\n\nplayer\n\nmove\n\nSPEED\n\nThen we also modify the space key handler to only jump if Mario is still alive:\n\nonKeyPress\n\n\"space\"\n\n=>\n\nif\n\nplayer\n\nisAlive\n\n&&\n\nplayer\n\ngrounded\n\nplayer\n\njump\n\ncanSquash\n\ntrue\n\nTime to update the output and test all these changes out! First thing to test is if Mario grows bigger by eating the mushroom. Second thing to check is if Mario then gets smaller again by colliding with an enemy. Also check if Mario is killed when colliding with an enemy when he is small, or when falling off the platform.\n\nEnding when we get to the castle\u200b\n\nThe final thing to do for this tutorial is to handle the case when Mario reaches the castle. At this point, when Mario is at the door, we want him to freeze, a congratulations message to appear to the player, and then move on to the next level.\n\nWe can use a regular collision handler to check if Mario is at the castle. Notice in the setup for the castle in the levelConf we added earlier, we set the collision area of the castle to a very narrow, completely vertical line of width 1 pixel and height 240, which is the screen height:\n\n\"H\"\n\n=>\n\nsprite\n\n\"castle\"\n\narea\n\nwidth\n\nheight\n\n240\n\norigin\n\n\"bot\"\n\n\"castle\"\n\nThis is so that the collision between Mario and the castle is only registered when Mario gets to the center of the castle, where the door is. We can visualize this by pressing F1 in the game to enable the debugger and look at the area box at the castle:\n\nThe reason we make the area box the height of the screen is make sure the player can't accidentally jump over the ending point and fall off the end of the level.\n\nNow let's add our collision handler for the castle to the game scene:\n\nplayer\n\nonCollide\n\n\"castle\"\n\ncastle\n\nside\n\n=>\n\nplayer\n\nfreeze\n\nadd\n\ntext\n\n\"Well Done!\"\n\nsize\n\n24\n\npos\n\ntoWorld\n\nvec2\n\n160\n\n120\n\ncolor\n\n255\n\n255\n\n255\n\norigin\n\n\"center\"\n\nlayer\n\n\"ui\"\n\nwait\n\n=>\n\nlet\n\nnextLevel\n\nlevelNumber\n\nif\n\nnextLevel\n\n>=\n\nLEVELS\n\nlength\n\ngo\n\n\"start\"\n\nelse\n\ngo\n\n\"game\"\n\nnextLevel\n\nFirst, we freeze Mario so the player can't control him anymore. Then we add our \"Well Done!\" text message to the center of the screen.", "start_char_idx": 31981, "end_char_idx": 35777, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24d99564-b3ee-4acd-8e84-355e5df49559": {"__data__": {"id_": "24d99564-b3ee-4acd-8e84-355e5df49559", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "148ee967-bd82-4576-9e25-0237ab43a478", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "dd973710070ee8e57d468b327addf02e7d429cfcbba76bc3597073e64002d2ff", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7652e70d-7b8d-4ad2-a6d6-7f2475a4b923", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}, "hash": "286358c63d6e1a9975b7ac52331c3dc91a1f09199c0217f4bf21ee2ea87d9428", "class_name": "RelatedNodeInfo"}}, "hash": "b63e8df362896bda18fb1802b072fb350e1fcbf13162283ded2ab20b2f5b0ebe", "text": "Now let's add our collision handler for the castle to the game scene:\n\nplayer\n\nonCollide\n\n\"castle\"\n\ncastle\n\nside\n\n=>\n\nplayer\n\nfreeze\n\nadd\n\ntext\n\n\"Well Done!\"\n\nsize\n\n24\n\npos\n\ntoWorld\n\nvec2\n\n160\n\n120\n\ncolor\n\n255\n\n255\n\n255\n\norigin\n\n\"center\"\n\nlayer\n\n\"ui\"\n\nwait\n\n=>\n\nlet\n\nnextLevel\n\nlevelNumber\n\nif\n\nnextLevel\n\n>=\n\nLEVELS\n\nlength\n\ngo\n\n\"start\"\n\nelse\n\ngo\n\n\"game\"\n\nnextLevel\n\nFirst, we freeze Mario so the player can't control him anymore. Then we add our \"Well Done!\" text message to the center of the screen. We wait a second before incrementing our level number and going to the next level, or going back to the start of the game if we have completed all levels.\n\nNext steps\u200b\n\nThere are few things left to do to complete the game:\n\nAdd in some scoring. You can check out a previous Kaboom tutorial, like Space Shooter, to see how scoring works.\n\nAdd in sounds and music. If you get your own copy of the Mario soundtrack and effects, you can use the play sound function in Kaboom to get those classic tunes blasting as you play.\n\nAdd in some more levels. This is the really fun part, where you get to create Mario levels you wish existed.\n\nYou can also add in some more of the Mario World game characters.\n\nCredits\u200b\n\nhttps://twitter.com/Arrow_N_TheKnee for the Mario Visual Assets\n\nYou can find the code for this tutorial here:\n\n< Previous: Flappy Bird with Kaboom.js\n\nNext: Snake game with Kaboom.js >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nDesigning the game\n\nCreating a new project in Replit\n\nSetting up Kaboom\n\nCreating the level maps\n\nAdding a scene\n\nAdding the main game scene\n\nMaking Mario move\n\nAdding scrolling\n\nCreating a custom component\n\nCreating a custom component for the enemies\n\nHeadbutting surprise boxes\n\nAdding special behaviors to Mario\n\nAdding more Mario collisions and events\n\nEnding when we get to the castle\n\nNext steps\n\nCredits", "start_char_idx": 35275, "end_char_idx": 37132, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"148ee967-bd82-4576-9e25-0237ab43a478": {"node_ids": ["58f4f2e5-c5f7-4411-bb1f-e7bf4030119e", "0b1c3b50-a514-40bc-abfc-19dbcf067195", "8eff35ca-757c-48e2-9498-05d56189a3c6", "96f39962-ef84-498f-91d4-57bc653f325c", "b0147196-013e-4af6-8ec6-668e9f568952", "7f7fd200-a797-4978-becc-65ac39a1b597", "d373d4aa-8bdc-48eb-827a-0f793087636a", "2e5767a7-5566-4b8c-ba28-3ac339ebb081", "29e4ea66-ae11-4788-afe4-3c6c6946ede7", "7652e70d-7b8d-4ad2-a6d6-7f2475a4b923", "24d99564-b3ee-4acd-8e84-355e5df49559"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/kaboom/build-mario-with-kaboom.html"}}}, "docstore/metadata": {"58f4f2e5-c5f7-4411-bb1f-e7bf4030119e": {"doc_hash": "bf1e6ba992d9fc10ae2b8ecb84cbda7fe37025041a93f1c63cf27e9927c1564b", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "0b1c3b50-a514-40bc-abfc-19dbcf067195": {"doc_hash": "fbda8576180f83528ec8b5e7e7ff398582c2df66ca66547eabea1034f03a071d", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "8eff35ca-757c-48e2-9498-05d56189a3c6": {"doc_hash": "7de4fba645485b075b9b4bd688ca0c4b62085e0334195b9f020e112a7eeee014", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "96f39962-ef84-498f-91d4-57bc653f325c": {"doc_hash": "2516e24f088dbb075241305acaf063a82cc289c8166f3ee9ee433d88a811fff8", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "b0147196-013e-4af6-8ec6-668e9f568952": {"doc_hash": "b53f94e3b9db0fc0589bb16dc6aaa7578972a19df1dc1b7f1b125972d152f4b6", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "7f7fd200-a797-4978-becc-65ac39a1b597": {"doc_hash": "20574d7b62ab7d48e2067623378fa21392a592d015e84421ab026a8739231d2c", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "d373d4aa-8bdc-48eb-827a-0f793087636a": {"doc_hash": "8e23ff8e8f3c10213128ece11760e0c126a1f2aed8d9ff36acbd04426f1d502b", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "2e5767a7-5566-4b8c-ba28-3ac339ebb081": {"doc_hash": "207d395e050ecaf073e6b1fdde775e221c819da39315fe147bb27cd789f18444", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "29e4ea66-ae11-4788-afe4-3c6c6946ede7": {"doc_hash": "255d550b82827246cc6ae3dc626c9d775602939b0a9945242596db182682eb7a", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "7652e70d-7b8d-4ad2-a6d6-7f2475a4b923": {"doc_hash": "286358c63d6e1a9975b7ac52331c3dc91a1f09199c0217f4bf21ee2ea87d9428", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}, "24d99564-b3ee-4acd-8e84-355e5df49559": {"doc_hash": "b63e8df362896bda18fb1802b072fb350e1fcbf13162283ded2ab20b2f5b0ebe", "ref_doc_id": "148ee967-bd82-4576-9e25-0237ab43a478"}}}