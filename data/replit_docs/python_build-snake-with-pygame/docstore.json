{"docstore/data": {"88206b6a-9f88-41ba-8b14-8ec236b838fc": {"__data__": {"id_": "88206b6a-9f88-41ba-8b14-8ec236b838fc", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "99c025ea4b62aff37f5df55ba63c150e481a5f29efe1d2b178acb5bdd1b41323", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "553051c1-145c-4f69-8635-abe7f27aff87", "node_type": "1", "metadata": {}, "hash": "cb897f9b20a0ed9729ebf62fb77ef17a1c69f42b2a1c419dc9687ed3217b81d4", "class_name": "RelatedNodeInfo"}}, "hash": "3c0b97e296d7ea6ee5078b3346a65e89f1df6d95bef665ba62f27207398c7397", "text": "block_size\n\nNone\n\ncolor\n\n255\n\nbounds\n\nNone\n\ndef\n\n__init__\n\nself\n\nblock_size\n\nbounds\n\nself\n\nblock_size\n\nblock_size\n\nself\n\nbounds\n\nbounds\n\nself\n\nrespawn\n\ndef\n\nrespawn\n\nself\n\nself\n\nlength\n\nself\n\nbody\n\n20\n\n20\n\n20\n\n40\n\n20\n\n60\n\nself\n\ndirection\n\nDirection\n\nDOWN\n\nThe first class in this file is an enumeration, which is a nice way to group together a set of related constants. We use this to define the allowable directions the snake can move in, and make code that checks and changes directions easy to read and change, compared to just using numbers or strings to define the directions.\n\nThen we define the Snake class itself. The first few lines are setting up some variables \u2013 this is not strictly necessary in Python, but it does make it easier to keep track of the variables, or properties, in our class.\n\nLet's look a bit at the body variable. It is a Python list, containing tuples (or pairs) of co-ordinates. Each of these co-ordinates describes the top left x and y screen positions of a body segment, or block. We will add (append) to this list as the snake grows. We also use this list when drawing the snake.\n\nDrawing the Snake\u200b\n\nNow that we have the basics of the Snake class and its initialization code up and running, let's add in a method to draw the snake to the screen. Add this to the Snake class:\n\ndef\n\ndraw\n\nself\n\ngame\n\nwindow\n\nfor\n\nsegment\n\nin\n\nself\n\nbody\n\ngame\n\ndraw\n\nrect\n\nwindow\n\nself\n\ncolor\n\nsegment\n\nsegment\n\nself\n\nblock_size\n\nself\n\nblock_size\n\nThis method takes in a pygame instance, game, and a window (or surface in general pygame terminology) to draw on. It then loops through each of the tuples in the body property, and uses the pygame built in method draw.rect to draw a rectangle for each block, or snake segment in the body list. We also use our block_size parameter to set the width and height of the rectangle drawn.\n\nLet's try out what we have so far. We'll just see a static few blocks on the screen, but it's a good test to see if everything is on the right track. To get it working, let's import and create a new Snake object, and set up the first part of our game loop in main.py.\n\nAdd the code to import the classes in the snake.py file at the top of the main.py file, just under the import pygame line:\n\nfrom\n\nsnake\n\nimport\n\nNow we add the following code just under the line pygame.display.set_caption(\"Snake\"):\n\nblock_size\n\n20\n\nsnake\n\nSnake\n\nblock_size\n\nbounds\n\nThis code sets up our block_size for our grid to a default of 20 pixels. Then we create a new instance of our Snake class, with the block size, and the bounds that we used to set our window size to, and that's what the snake will use to check if it hits the edge of the window.\n\nNow let's set up our game loop. A game loop is the central co-ordination code of most games. It handles reading in user input, updating player status (e.g., position, score etc.), checks for interactions and collisions, and handles drawing.\n\nAdd the following to the main.py file to set up our game loop:\n\nrun\n\nTrue\n\nwhile\n\nrun\n\npygame\n\ntime\n\ndelay\n\n100\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nQUIT\n\nrun\n\nFalse\n\nwindow\n\nfill\n\nsnake\n\ndraw\n\npygame\n\nwindow\n\npygame\n\ndisplay\n\nflip\n\nThis code sets up a loop that keeps repeating every 100ms until a quit signal is received from the window. This is triggered by a player clicking the \"Close Window\" button at the top of the window. Pygame has the concept of an event queue to which it writes various events that have been triggered. We can read this event queue each time we loop in our game loop and check to see if any of the events was a QUIT signal. Then we can set the condition for the loop to run to False and the next time the loop cycles round, our while condition will no longer be true, and the game will exit.\n\nOur loop also clears the window on each round in preparation for drawing the updated game state. You can see that on the line  window.fill((0,0,0)). This fills the whole window with black, specified in the RGB color tuple (0,0,0). Now that we have a clean slate, we can call the draw method on our snake object.", "start_char_idx": 0, "end_char_idx": 4085, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "553051c1-145c-4f69-8635-abe7f27aff87": {"__data__": {"id_": "553051c1-145c-4f69-8635-abe7f27aff87", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "99c025ea4b62aff37f5df55ba63c150e481a5f29efe1d2b178acb5bdd1b41323", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88206b6a-9f88-41ba-8b14-8ec236b838fc", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "3c0b97e296d7ea6ee5078b3346a65e89f1df6d95bef665ba62f27207398c7397", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7e8017c9-4163-427c-89c0-a50bb7d94649", "node_type": "1", "metadata": {}, "hash": "65b6502880efbda0e2ea761cf6195d11b77d13f0d122a1d71b41e085105b4db0", "class_name": "RelatedNodeInfo"}}, "hash": "cb897f9b20a0ed9729ebf62fb77ef17a1c69f42b2a1c419dc9687ed3217b81d4", "text": "This is triggered by a player clicking the \"Close Window\" button at the top of the window. Pygame has the concept of an event queue to which it writes various events that have been triggered. We can read this event queue each time we loop in our game loop and check to see if any of the events was a QUIT signal. Then we can set the condition for the loop to run to False and the next time the loop cycles round, our while condition will no longer be true, and the game will exit.\n\nOur loop also clears the window on each round in preparation for drawing the updated game state. You can see that on the line  window.fill((0,0,0)). This fills the whole window with black, specified in the RGB color tuple (0,0,0). Now that we have a clean slate, we can call the draw method on our snake object. We pass in the pygame and Window objects, so that the Snake can draw to them. When we render our food, we will call it after this line.\n\nLastly, we do the final render to the screen by calling pygame.display.flip(). This takes all our updates and \"flips\" them from the window buffer to the screen.\n\nTo test that the game loop and drawing is working, run the program by clicking the large \"Run >\" button at the top of the repl. At the top right section of the repl, you should see a black window with a few blocks representing a snake on it.\n\nMoving the Snake\u200b\n\nOur next step is to get the snake to move on the screen. A way to do this is to check which direction the snake is heading, and add a block in front of the snake in that direction. Then we'll need to remove a block at the tail end of the snake.\n\nTo do this, add this method to the Snake class in the snake.py file:\n\ndef\n\nmove\n\nself\n\ncurr_head\n\nself\n\nbody\n\nif\n\nself\n\ndirection\n\n==\n\nDirection\n\nDOWN\n\nnext_head\n\ncurr_head\n\ncurr_head\n\nself\n\nblock_size\n\nself\n\nbody\n\nappend\n\nnext_head\n\nelif\n\nself\n\ndirection\n\n==\n\nDirection\n\nUP\n\nnext_head\n\ncurr_head\n\ncurr_head\n\nself\n\nblock_size\n\nself\n\nbody\n\nappend\n\nnext_head\n\nelif\n\nself\n\ndirection\n\n==\n\nDirection\n\nRIGHT\n\nnext_head\n\ncurr_head\n\nself\n\nblock_size\n\ncurr_head\n\nself\n\nbody\n\nappend\n\nnext_head\n\nelif\n\nself\n\ndirection\n\n==\n\nDirection\n\nLEFT\n\nnext_head\n\ncurr_head\n\nself\n\nblock_size\n\ncurr_head\n\nself\n\nbody\n\nappend\n\nnext_head\n\nif\n\nself\n\nlength\n\nlen\n\nself\n\nbody\n\nself\n\nbody\n\npop\n\nThis method gets the \"head\" of the snake, which is the last element of our body list. Python has a handy feature of negative indices. This means an index of -1 returns the last element in the list, -2 returns the second last, and so on. This allows us to easily get the last element, or the front of the snake in our body list, by using the code curr_head = self.body[-1].\n\nAfter we get the head of the snake, we check which direction the snake is heading in. If it is going up or down, we append a new block by copying the x co-ordinate of the current head, and adding or subtracting (depending on if the snake is going up or down) one grid block_size to the y co-ordinate. Similarly, if the snake is heading left or right, we append a new block to the body list, using the y co-ordinate of the current head, but modifying the x co-ordinate by one block_size.\n\nOnce that is done, we remove a block at the tail end of the snake, using the code self.body.pop(0). We have a condition before that though: if self.length < len(self.body). This is important for when we get to the snake eating, or growing. Every time the snake eats, we will increment the length property of the snake. Then, we can use that length property to determine if we should actually remove the tail segment from the snake when it moves.\n\nNow let's add a call to this move method in our game loop. In the main.py file, modify the game loop to call this method:\n\nrun\n\nTrue\n\nwhile\n\nrun\n\npygame\n\ntime\n\ndelay\n\n100\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nQUIT\n\nrun\n\nFalse\n\nsnake\n\nmove\n\nwindow\n\nfill\n\nsnake\n\ndraw\n\npygame\n\nwindow\n\npygame\n\ndisplay\n\nupdate\n\nNotice that we've added the line snake.move().", "start_char_idx": 3292, "end_char_idx": 7247, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7e8017c9-4163-427c-89c0-a50bb7d94649": {"__data__": {"id_": "7e8017c9-4163-427c-89c0-a50bb7d94649", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "99c025ea4b62aff37f5df55ba63c150e481a5f29efe1d2b178acb5bdd1b41323", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "553051c1-145c-4f69-8635-abe7f27aff87", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "cb897f9b20a0ed9729ebf62fb77ef17a1c69f42b2a1c419dc9687ed3217b81d4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fb9c4f0a-a762-4e25-96c6-90528b5cc09b", "node_type": "1", "metadata": {}, "hash": "be809b7cba23224706ce1ab896ab1aaaf0e99a97fd2b34155f40749056a455e4", "class_name": "RelatedNodeInfo"}}, "hash": "65b6502880efbda0e2ea761cf6195d11b77d13f0d122a1d71b41e085105b4db0", "text": "We have a condition before that though: if self.length < len(self.body). This is important for when we get to the snake eating, or growing. Every time the snake eats, we will increment the length property of the snake. Then, we can use that length property to determine if we should actually remove the tail segment from the snake when it moves.\n\nNow let's add a call to this move method in our game loop. In the main.py file, modify the game loop to call this method:\n\nrun\n\nTrue\n\nwhile\n\nrun\n\npygame\n\ntime\n\ndelay\n\n100\n\nfor\n\nevent\n\nin\n\npygame\n\nevent\n\nget\n\nif\n\nevent\n\ntype\n\n==\n\npygame\n\nQUIT\n\nrun\n\nFalse\n\nsnake\n\nmove\n\nwindow\n\nfill\n\nsnake\n\ndraw\n\npygame\n\nwindow\n\npygame\n\ndisplay\n\nupdate\n\nNotice that we've added the line snake.move(). This will call our move method that we added to our snake on every loop. This will create the impression of the snake moving smoothly on the screen. Test it out by clicking the \"Run >\" button at the top center of the repl. The snake should start at the top left of the window and move down the screen, until it disappears out of the window bounds.\n\nSteering the Snake\u200b\n\nWe've got the snake moving! Our next task is to get the player's input to steer the snake. We'll start by adding the following method to the Snake class in the snake.py file:\n\ndef\n\nsteer\n\nself\n\ndirection\n\nif\n\nself\n\ndirection\n\n==\n\nDirection\n\nDOWN\n\nand\n\ndirection\n\n!=\n\nDirection\n\nUP\n\nself\n\ndirection\n\ndirection\n\nelif\n\nself\n\ndirection\n\n==\n\nDirection\n\nUP\n\nand\n\ndirection\n\n!=\n\nDirection\n\nDOWN\n\nself\n\ndirection\n\ndirection\n\nelif\n\nself\n\ndirection\n\n==\n\nDirection\n\nLEFT\n\nand\n\ndirection\n\n!=\n\nDirection\n\nRIGHT\n\nself\n\ndirection\n\ndirection\n\nelif\n\nself\n\ndirection\n\n==\n\nDirection\n\nRIGHT\n\nand\n\ndirection\n\n!=\n\nDirection\n\nLEFT\n\nself\n\ndirection\n\ndirection\n\nThis method works by accepting an argument direction, which must be one of our Direction enumeration values we defined earlier. We then do a check for each possible direction to ensure that the new direction input is not the complete opposite direction to which the snake is currently moving \u2013 this is because we don't want to allow reversing the snake in our game. If the input direction is a legal move, we update the snake's direction property. Recall from our move method, this property is used to determine how to update the snake's body list property, to create the snake's movement.\n\nNow that we can update the snake's direction through a steering command, we need to get the player's input. Pygame has a useful method key.get_pressed(), which returns a list containing a boolean element for each key on the keyboard. This allows us to find which key the player is pushing by looking up the value at the correct index in this keys list. Luckily, we don't need to memorize the correct index for every key, as pygame has readable names defined as constants we can use. For example, to find out if the 'Up Arrow' is being pressed, we can call keys = pygame.key.get_pressed() to get the status list for all keys. Then we can look for the 'Up Arrow' key's state by looking at the entry for that key, with the code keys[pygame.K_UP]. If the key is being pressed, it will have a True value; if not pressed its value will be False.\n\nLet's add code to our game loop to check if the \"Up\", \"Down\", \"Left\" or \"Right\" arrow keys are being pressed. Then, depending on the key pressed, we can call our steer method with the updated direction command. Add the following code above the snake.move() line in the game loop, in the main.py file:\n\nkeys\n\npygame\n\nkey\n\nget_pressed\n\nif\n\nkeys\n\npygame\n\nK_LEFT\n\nsnake\n\nsteer\n\nDirection\n\nLEFT\n\nelif\n\nkeys\n\npygame\n\nK_RIGHT\n\nsnake\n\nsteer\n\nDirection\n\nRIGHT\n\nelif\n\nkeys\n\npygame\n\nK_UP\n\nsnake\n\nsteer\n\nDirection\n\nUP\n\nelif\n\nkeys\n\npygame\n\nK_DOWN\n\nsnake\n\nsteer\n\nDirection\n\nDOWN\n\nLet's test this. Click the \"Run >\" button at the top center of the repl. For Pygame to receive keyboard input, you'll need to click into the game window first quickly, as the game is starting up. You should now be able to use the cursor keys to steer the snake around the screen! We don't have bounds checking yet, so the snake can disappear off the edge of the window.", "start_char_idx": 6518, "end_char_idx": 10622, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fb9c4f0a-a762-4e25-96c6-90528b5cc09b": {"__data__": {"id_": "fb9c4f0a-a762-4e25-96c6-90528b5cc09b", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "99c025ea4b62aff37f5df55ba63c150e481a5f29efe1d2b178acb5bdd1b41323", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7e8017c9-4163-427c-89c0-a50bb7d94649", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "65b6502880efbda0e2ea761cf6195d11b77d13f0d122a1d71b41e085105b4db0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d5556b6c-a2ad-4ec1-9d3c-450497905d83", "node_type": "1", "metadata": {}, "hash": "c79da806dd7366347d85eb60e0102eab17b6fb2bc5a28f6a313c213fdb763530", "class_name": "RelatedNodeInfo"}}, "hash": "be809b7cba23224706ce1ab896ab1aaaf0e99a97fd2b34155f40749056a455e4", "text": "Add the following code above the snake.move() line in the game loop, in the main.py file:\n\nkeys\n\npygame\n\nkey\n\nget_pressed\n\nif\n\nkeys\n\npygame\n\nK_LEFT\n\nsnake\n\nsteer\n\nDirection\n\nLEFT\n\nelif\n\nkeys\n\npygame\n\nK_RIGHT\n\nsnake\n\nsteer\n\nDirection\n\nRIGHT\n\nelif\n\nkeys\n\npygame\n\nK_UP\n\nsnake\n\nsteer\n\nDirection\n\nUP\n\nelif\n\nkeys\n\npygame\n\nK_DOWN\n\nsnake\n\nsteer\n\nDirection\n\nDOWN\n\nLet's test this. Click the \"Run >\" button at the top center of the repl. For Pygame to receive keyboard input, you'll need to click into the game window first quickly, as the game is starting up. You should now be able to use the cursor keys to steer the snake around the screen! We don't have bounds checking yet, so the snake can disappear off the edge of the window.\n\nAdding Food\u200b\n\nWe have a snake, it moves, and a player can steer it. Let's add some food that the snake can eat, which will cause it to grow longer.\n\nWe'll create the food in a similar way we created the snake. Create a new file called food.py. In this file, we'll create a Food class, to manage the position and drawing of food on the grid.\n\nIn the game of snake, once a food block is eaten, another one appears at a random location on the grid. This means we'll need a random number generator to determine the location of the food. Python has a module for this called random. This has a function called randint which we can use to find a random position on the screen to place the food. We'll start by adding a reference to the random module in the food.py file. Then we'll add the Food class.\n\nimport\n\nrandom\n\nclass\n\nFood\n\nblock_size\n\nNone\n\ncolor\n\n255\n\nbounds\n\nNone\n\ndef\n\n__init__\n\nself\n\nblock_size\n\nbounds\n\nself\n\nblock_size\n\nblock_size\n\nself\n\nbounds\n\nbounds\n\ndef\n\ndraw\n\nself\n\ngame\n\nwindow\n\ngame\n\ndraw\n\nrect\n\nwindow\n\nself\n\ncolor\n\nself\n\nself\n\nself\n\nblock_size\n\nself\n\nblock_size\n\ndef\n\nrespawn\n\nself\n\nblocks_in_x\n\nself\n\nbounds\n\nself\n\nblock_size\n\nblocks_in_y\n\nself\n\nbounds\n\nself\n\nblock_size\n\nself\n\nrandom\n\nrandint\n\nblocks_in_x\n\nself\n\nblock_size\n\nself\n\nrandom\n\nrandint\n\nblocks_in_y\n\nself\n\nblock_size\n\nNotice the commonality with the Snake class. They both have a draw method and a respawn method. Generally in games, most objects will have this functionality.\n\nThe draw method is a simplified version of the one in the snake class. This is because we only need to draw 1 block.\n\nThe respawn method is interesting. We need to align our food with our virtual grid, defined by the block_size. However, if we simply called random.randint to find an x and y position for the food, it might land up halfway through a block on the grid. This will make it strange to try aim at with the snake, as the snake will not be aligned with the food.\n\nTo keep things aligned, we need to take our information of the size of the window, encapsulated in our bounds property, and our knowledge of the block_size of our grid to figure out the dimension of the window in terms of blocks. So for example, if our window size, or bounds is 300x300 pixels, and our block_size is 20px, then there are 300px/20px = 15 blocks in each dimension. We can then choose a random position in terms of block dimensions, i.e choose a number from 1-15, in which to place the food. To get the actual x and y screen co-ordinates to draw the block, we can just multiply our block number by the block_size.\n\nIn the first 2 lines of the respawn method, we find the number of blocks in each dimension, as described above. Then the next 2 lines find a random block, and translate that block to x and y co-ordinates. You may notice that instead of finding a random number between 1 and the number of blocks in a dimension, we find one between 0 and the number of blocks minus 1. This is because the window x and y start at 0, not 1, so we need to shift the range over by 1 to compensate.\n\nWe have a Food class, so we can create an instance of it and add it to our game loop.\n\nFirst we need to add a reference to the food.py file, and import the Food class.", "start_char_idx": 9898, "end_char_idx": 13829, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d5556b6c-a2ad-4ec1-9d3c-450497905d83": {"__data__": {"id_": "d5556b6c-a2ad-4ec1-9d3c-450497905d83", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "99c025ea4b62aff37f5df55ba63c150e481a5f29efe1d2b178acb5bdd1b41323", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fb9c4f0a-a762-4e25-96c6-90528b5cc09b", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "be809b7cba23224706ce1ab896ab1aaaf0e99a97fd2b34155f40749056a455e4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a8a45b69-d219-4355-800e-962881ca1fe4", "node_type": "1", "metadata": {}, "hash": "10d9b0e3e779520690f8bb04c5e447d44c2be99a4e76f683b434440093aab85a", "class_name": "RelatedNodeInfo"}}, "hash": "c79da806dd7366347d85eb60e0102eab17b6fb2bc5a28f6a313c213fdb763530", "text": "To get the actual x and y screen co-ordinates to draw the block, we can just multiply our block number by the block_size.\n\nIn the first 2 lines of the respawn method, we find the number of blocks in each dimension, as described above. Then the next 2 lines find a random block, and translate that block to x and y co-ordinates. You may notice that instead of finding a random number between 1 and the number of blocks in a dimension, we find one between 0 and the number of blocks minus 1. This is because the window x and y start at 0, not 1, so we need to shift the range over by 1 to compensate.\n\nWe have a Food class, so we can create an instance of it and add it to our game loop.\n\nFirst we need to add a reference to the food.py file, and import the Food class. In the main.py file, just below the import pygame line, add the following:\n\nfrom\n\nfood\n\nimport\n\nFood\n\nIn the main.py file, after the line snake = Snake(block_size, bounds), and just before the game loop, create a new Food object by adding the line:\n\nfood\n\nFood\n\nblock_size\n\nbounds\n\nIn the game loop in main.py, just after the line snake.draw(pygame, window), we can add a line to draw the food. Add the following line:\n\nfood\n\ndraw\n\npygame\n\nwindow\n\nGreat! Let's test up to this point by clicking the \"Run >\" button again. You should now see the snake, as well as a green block representing the food.\n\nAdding Collision Detection for Food\u200b\n\nYou'll notice that the snake can go right over the food, and nothing happens. A core concept in games is collision detection. As we are using a strict grid system, we can use a simplified version of collision detection. We'll use this to determine if the snake has moved over, or collided with, a food object. Then we can increase the snake's length, and respawn the food again.\n\nWe'll give the responsibility for checking collisions to the Snake class. In the snake.py file, add the following two methods to the Snake class:\n\ndef\n\neat\n\nself\n\nself\n\nlength\n\n+=\n\n# sees if the head of the snake is over the food\n\ndef\n\ncheck_for_food\n\nself\n\nfood\n\nhead\n\nself\n\nbody\n\nif\n\nhead\n\n==\n\nfood\n\nand\n\nhead\n\n==\n\nfood\n\nself\n\neat\n\nfood\n\nrespawn\n\nThe first method, eat, increases the allowable length of the snake. Remember that the length property is used in the move method to determine if a tail segment needs to be removed.\n\nIn the game loop in the main.py file, add the following code, just after the snake.move() line:\n\nsnake\n\ncheck_for_food\n\nfood\n\nThis adds a call to our food collision detection method on each loop of the game, just after the snake has moved into a new block.\n\nWe can test this again, and see if our snake now grows when we eat some food. Click the \"Run >\" button again to test.\n\nTail and Bound Collision Detection\u200b\n\nWe now need to add collision detection if the snake crosses over itself. This is a deadly move, and one of the ways to reach \"Game Over\" in Snake. Similarly to checking if the snake has eaten food, we can add a method to the Snake class in the snake.py file to check if the snake has crossed over, or bitten itself:\n\ndef\n\ncheck_tail_collision\n\nself\n\nhead\n\nself\n\nbody\n\nhas_eaten_tail\n\nFalse\n\nfor\n\nin\n\nrange\n\nlen\n\nself\n\nbody\n\nsegment\n\nself\n\nbody\n\nif\n\nhead\n\n==\n\nsegment\n\nand\n\nhead\n\n==\n\nsegment\n\nhas_eaten_tail\n\nTrue\n\nreturn\n\nhas_eaten_tail\n\nThis method gets the head of the snake, as before in our check_for_food method. Then we set a flag variable to determine if the snake has eaten its tail, and initialize it to False.\n\nThe next part of the method runs through all the segments that make up the body of the snake, excluding the last element of the body list, as this element represents the head of the snake. Then we test the x and y co-ordinates of the head and the current segment. If they match, it means the head of the snake is over a body segment, so we can set our flag has_eaten_tail to true.\n\nAfter all segments are tested, we return the value of the has_eaten_tail flag.\n\nThe last detection we need to add is if the snake moves outside the bounds of the window.", "start_char_idx": 13062, "end_char_idx": 17065, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a8a45b69-d219-4355-800e-962881ca1fe4": {"__data__": {"id_": "a8a45b69-d219-4355-800e-962881ca1fe4", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "99c025ea4b62aff37f5df55ba63c150e481a5f29efe1d2b178acb5bdd1b41323", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d5556b6c-a2ad-4ec1-9d3c-450497905d83", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}, "hash": "c79da806dd7366347d85eb60e0102eab17b6fb2bc5a28f6a313c213fdb763530", "class_name": "RelatedNodeInfo"}}, "hash": "10d9b0e3e779520690f8bb04c5e447d44c2be99a4e76f683b434440093aab85a", "text": "Then we set a flag variable to determine if the snake has eaten its tail, and initialize it to False.\n\nThe next part of the method runs through all the segments that make up the body of the snake, excluding the last element of the body list, as this element represents the head of the snake. Then we test the x and y co-ordinates of the head and the current segment. If they match, it means the head of the snake is over a body segment, so we can set our flag has_eaten_tail to true.\n\nAfter all segments are tested, we return the value of the has_eaten_tail flag.\n\nThe last detection we need to add is if the snake moves outside the bounds of the window. We can add the following method to the Snake class to do that:\n\ndef\n\ncheck_bounds\n\nself\n\nhead\n\nself\n\nbody\n\nif\n\nhead\n\n>=\n\nself\n\nbounds\n\nreturn\n\nTrue\n\nif\n\nhead\n\n>=\n\nself\n\nbounds\n\nreturn\n\nTrue\n\nif\n\nhead\n\nreturn\n\nTrue\n\nif\n\nhead\n\nreturn\n\nTrue\n\nreturn\n\nFalse\n\nThis code once again retrieves the head block of the snake from the end of the body list. Then it checks each dimension against the bounds of the window. If it's outside any of these bounds, the method returns True. If the snake's head is still within bounds, it returns False.\n\nAdding the \"Game Over\" Screen\u200b\n\nNow that we can detect game-ending collisions, we can add code to the game loop to call these methods, and handle the end of the game. When the game ends, we should show a \"Game Over\" message to the player for a second or two. Then we can reset the snake and the food to give the player another chance.\n\nTo add the \"Game Over\" message, we can make use of pygame's font module. The basic steps for using a font to draw text to the screen are:\n\nCreate a new font object, specifying the font type, size and bold/italic options, using the constructor method font.SysFont.\n\nRender the desired text to a surface using the render method on the font object created above.\n\nblit the rendered text onto the main window surface.\n\nUpdate the window display to show this.\n\nTo implement the above steps, create a new font object by adding the following code under the line food = Food(block_size,bounds) in the main.py file:\n\nfont\n\npygame\n\nfont\n\nSysFont\n\n'comicsans'\n\n60\n\nTrue\n\nIn the game loop, we need to call the collision checking methods we added to the snake class earlier. If a collision is detected, we can render our \"Game Over\" message, pause, and reset the game. Add the following code under the line snake.check_for_food(food) in the game loop in the main.py file:\n\nif\n\nsnake\n\ncheck_bounds\n\n==\n\nTrue\n\nor\n\nsnake\n\ncheck_tail_collision\n\n==\n\nTrue\n\ntext\n\nfont\n\nrender\n\n'Game Over'\n\nTrue\n\n255\n\n255\n\n255\n\nwindow\n\nblit\n\ntext\n\n20\n\n120\n\npygame\n\ndisplay\n\nupdate\n\npygame\n\ntime\n\ndelay\n\n1000\n\nsnake\n\nrespawn\n\nfood\n\nrespawn\n\nThis code calls our bounds check and tail collision methods. If either of them come back True, we render a new \"Game Over\" message using the font steps above, and blit it to our main window. Then we delay for 1000ms (or 1 second), and then respawn both the snake and food objects for a new game.\n\nCongratulations! The basic Snake game is now complete. Click the \"Run >\" button at the top of the repl to try it out. When the snake crashes into itself, or goes off the edge of the window, the game will end and reset to a new one.\n\nThings to Try Next\u200b\n\nThere are endless features that could be added to this game. Some ideas are:\n\nCreate a 2-player version.\n\nAdd obstacles for the snake.\n\nIncrementally speed up the game as it goes on, to make it harder.\n\nAdd better graphics, utilizing the pygame image modules to load \"sprites\" and textures for the game.\n\nAdd sound effects and music using pygame's sound functions.\n\n< Previous: Email news digest app with Nix & Python\n\nNext: Building with Nix on Replit >\n\nWas this helpful?\n\nLast updated on Aug 31, 2023\n\nOverview and Requirements\n\nCreating a New Project\n\nGetting Started with Pygame\n\nCreating the Snake Class\n\nDrawing the Snake\n\nMoving the Snake\n\nSteering the Snake\n\nAdding Food\n\nAdding Collision Detection for Food\n\nTail and Bound Collision Detection\n\nAdding the \"Game Over\" Screen\n\nThings to Try Next", "start_char_idx": 16411, "end_char_idx": 20493, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"a5f1ca73-97da-4939-89d5-8f95b0b5d598": {"node_ids": ["88206b6a-9f88-41ba-8b14-8ec236b838fc", "553051c1-145c-4f69-8635-abe7f27aff87", "7e8017c9-4163-427c-89c0-a50bb7d94649", "fb9c4f0a-a762-4e25-96c6-90528b5cc09b", "d5556b6c-a2ad-4ec1-9d3c-450497905d83", "a8a45b69-d219-4355-800e-962881ca1fe4"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/build-snake-with-pygame.html"}}}, "docstore/metadata": {"88206b6a-9f88-41ba-8b14-8ec236b838fc": {"doc_hash": "3c0b97e296d7ea6ee5078b3346a65e89f1df6d95bef665ba62f27207398c7397", "ref_doc_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598"}, "553051c1-145c-4f69-8635-abe7f27aff87": {"doc_hash": "cb897f9b20a0ed9729ebf62fb77ef17a1c69f42b2a1c419dc9687ed3217b81d4", "ref_doc_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598"}, "7e8017c9-4163-427c-89c0-a50bb7d94649": {"doc_hash": "65b6502880efbda0e2ea761cf6195d11b77d13f0d122a1d71b41e085105b4db0", "ref_doc_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598"}, "fb9c4f0a-a762-4e25-96c6-90528b5cc09b": {"doc_hash": "be809b7cba23224706ce1ab896ab1aaaf0e99a97fd2b34155f40749056a455e4", "ref_doc_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598"}, "d5556b6c-a2ad-4ec1-9d3c-450497905d83": {"doc_hash": "c79da806dd7366347d85eb60e0102eab17b6fb2bc5a28f6a313c213fdb763530", "ref_doc_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598"}, "a8a45b69-d219-4355-800e-962881ca1fe4": {"doc_hash": "10d9b0e3e779520690f8bb04c5e447d44c2be99a4e76f683b434440093aab85a", "ref_doc_id": "a5f1ca73-97da-4939-89d5-8f95b0b5d598"}}}