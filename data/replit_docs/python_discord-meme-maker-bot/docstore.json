{"docstore/data": {"d2c54d8e-affb-46f8-bd51-4dea81b30704": {"__data__": {"id_": "d2c54d8e-affb-46f8-bd51-4dea81b30704", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "18499317ca7d0c84d45fe7b80678825a56d6c84ee615383264ba7418ac021038", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9c1989c8-39d0-40f2-ba6a-9ae79152803d", "node_type": "1", "metadata": {}, "hash": "c4efc7b971ac14d48310d64009ea14ca58fc9951e98747b86c3f3b8408d4e7c5", "class_name": "RelatedNodeInfo"}}, "hash": "fe0b0a3f935678e218996c2c544c68ef42e615c41fd245eac6f4d0d3977d09c4", "text": "Bot object. We'll use this object to listen for Discord events and respond to them. For the most part, we'll be responding to\n\nHowever, the first event we're interested in is not a command. The on_ready() event will trigger when our bot logs on to Discord (the @bot.event decorator ensures this). All this event will do is print a message to our repl's console, telling us that the bot has connected.\n\nNote that we've prepended async to the function definition \u2013 this makes our on_ready() function into a coroutine. Coroutines are largely similar to functions, but may not execute immediately, and must be invoked with the await keyword. Using coroutines makes our program asynchronous, which means it can continue executing code while waiting for the results of a long-running function, usually one that depends on input or output. If you've used JavaScript before, you'll recognize this style of programming.\n\nThe final line in our file starts the bot, providing DISCORD_TOKEN to authenticate it. Run your repl now to see it in action. Once it's started, return to your Discord server. You should see that your bot user is now online.\n\nReceiving user input\u200b\n\nThe Discord.py commands extension allows us to define command handlers using the @bot.command decorator. Without this, we'd have to manually parse the content of all user messages to determine whether a command had been issued, as was necessary for our role assignment bot tutorial`:\n\n@bot\n\ncommand\n\nname\n\n\"caption\"\n\nbrief\n\n\"Add a caption to an image.\"\n\nhelp\n\n\"\"\"Add a caption to an attached image. Example:\n\n!caption \"Hello world!\" <attached image>\n\nSupported image types: PNG, JPEG, WebP\n\n\"\"\"\n\nasync\n\ndef\n\ncaption\n\nctx\n\ncaption_text\n\npass\n\nThe @bot.command decorator will ensure that our function is invoked when a user types a message starting with !caption. We also use it to define some help text \u2013 the commands extension provides a default !help command, and each command we define can have two types of explanatory text:\n\nbrief: A short description of the command that will show alongside other defined commands when the user types !help.\n\nhelp: A longer description of the command that will show when the user types !help name_of_command.\n\nOur caption function takes two parameters:\n\nctx: This is the invocation context, a special object containing information such as the user who called the command, the server it was called in, and the files attached to the calling message, if any. All commands must take this parameter.\n\ncaption_text: This will be a string containing the caption the user wants to add to their image.\n\nWe'll start the body of the function with some user-friendly error handling. Replace pass with the function body shown below:\n\nasync\n\ndef\n\ncaption\n\nctx\n\ncaption_text\n\n# Must have caption text\n\nif\n\nnot\n\ncaption_text\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Please include some caption text after the `!caption` command. For example `!caption \\\"Hello world!\\\"\"\n\nreturn\n\nIf the user forgets to include a caption in their command, they'll receive a reply informing them of this omission.\n\nNext, we'll make sure they've attached a file to their command message with the following code:\n\n# Must have a file attached\n\nif\n\nctx\n\nmessage\n\nattachments\n\nimage_url\n\nctx\n\nmessage\n\nattachments\n\nurl\n\nelse\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Please attach an image for me to caption.\"\n\nreturn\n\nIf no file is attached, ctx.message.attachments will be an empty list and we'll send an error message to the user and abort the function. Otherwise, we'll store the URL of the first file attached to the message in image_url and continue execution. It's possible to attach multiple files to a single Discord message, but for this bot, we're going to ignore all but the first one.\n\nNext, we need to check whether the attached file is an image. We'll do this by determining the file's MIME type using Python's built-in mimetypes library. Add the following line to the top of your main.py file:\n\nimport\n\nmimetypes\n\nWe now need to specify which MIME types we'll support. According to our help text, images for captioning should be PNGs, JPEGs, or WebPs. These are the most common non-animating image types on the web, so we shouldn't need to support any more for the moment. Add the following code below the definition of DISCORD_TOKEN:\n\nSUPPORTED_MIMETYPES\n\n\"image/jpeg\"\n\n\"image/png\"\n\n\"image/webp\"\n\nReturn to the caption() function.", "start_char_idx": 0, "end_char_idx": 4382, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9c1989c8-39d0-40f2-ba6a-9ae79152803d": {"__data__": {"id_": "9c1989c8-39d0-40f2-ba6a-9ae79152803d", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "18499317ca7d0c84d45fe7b80678825a56d6c84ee615383264ba7418ac021038", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d2c54d8e-affb-46f8-bd51-4dea81b30704", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "fe0b0a3f935678e218996c2c544c68ef42e615c41fd245eac6f4d0d3977d09c4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "571bc3b5-a3b3-482a-af3d-fbeab3e15b53", "node_type": "1", "metadata": {}, "hash": "404b0ef3a36f2c2828726ed57d0d219c517cedee393cfbc53d493c9513920598", "class_name": "RelatedNodeInfo"}}, "hash": "c4efc7b971ac14d48310d64009ea14ca58fc9951e98747b86c3f3b8408d4e7c5", "text": "It's possible to attach multiple files to a single Discord message, but for this bot, we're going to ignore all but the first one.\n\nNext, we need to check whether the attached file is an image. We'll do this by determining the file's MIME type using Python's built-in mimetypes library. Add the following line to the top of your main.py file:\n\nimport\n\nmimetypes\n\nWe now need to specify which MIME types we'll support. According to our help text, images for captioning should be PNGs, JPEGs, or WebPs. These are the most common non-animating image types on the web, so we shouldn't need to support any more for the moment. Add the following code below the definition of DISCORD_TOKEN:\n\nSUPPORTED_MIMETYPES\n\n\"image/jpeg\"\n\n\"image/png\"\n\n\"image/webp\"\n\nReturn to the caption() function. Add the following code below the block of code that checks whether a file is attached to the user's message:\n\n# File must be an image\n\nif\n\nmimetypes\n\nguess_type\n\nimage_url\n\nnot\n\nin\n\nSUPPORTED_MIMETYPES\n\nawait\n\nctx\n\nmessage\n\nreply\n\n\"Sorry, the file you attached is not a supported image format. Please upload a PNG, JPEG or WebP image.\"\n\nreturn\n\nThe mimetypes.guess_type function will determine what kind of file we're dealing with from its URL. If we don't find its filetype in our list of supported types, we'll send an error message to the user and cease execution.\n\nNow that we've dealt with the most likely error cases, it's time to handle a correctly formatted !caption command. First, we need to fetch the image file \u2013 we have a URL for it, so we can use Python's requests library for this. Add the following line to the top of your main.py file:\n\nimport\n\nrequests\n\nThen return to the bottom of the caption function and add the following code:\n\n# Fetch image file\n\nresponse\n\nrequests\n\nget\n\nimage_url\n\n# Store image file name\n\nimage_filename\n\nctx\n\nmessage\n\nattachments\n\nfilename\n\nWe use a GET request to retrieve the user's image and store its filename in another variable.\n\nIt would be convenient if we could deal with this image completely in memory, without saving it to a file. We can do this by treating the image as a binary stream, provided by Python's built-in io library. Add the following line to the top of main.py:\n\nfrom\n\nio\n\nimport\n\nBytesIO\n\nReturn to the bottom of the caption function and add the following:\n\n# Caption image\n\nfinal_image\n\ncaption_image\n\nBytesIO\n\nresponse\n\ncontent\n\ncaption_text\n\nBytesIO will convert the image from HTTP response content into a binary stream, which is similar to the file object returned by open(). This allows us to work with the image as though it were a file without ever saving it to disk.\n\nWe'll write the caption_image() function in the next section. It takes an image and a caption and returns an image with the caption applied. Once we've got that implemented, we'll return to this function and send the finished image back to the user.\n\nCaptioning images\u200b\n\nThe code we're going to write in this section is quite different from the Discord API code above, so we'll put it in a separate file. That way, we can easily reuse it for other applications \u2013 for example, we might also want to write a Telegram bot, a command-line application, or even a small website that adds captions to images. By separating our code, we can implement any of these later on without having to change or even think about the image captioning logic.\n\nCreate a new file named caption.py and populate it with the code below:\n\nfrom\n\nPIL\n\nimport\n\nImage\n\nImageDraw\n\nImageFont\n\nfrom\n\nio\n\nimport\n\nBytesIO\n\ndef\n\ncaption_image\n\nimage_file\n\ncaption\n\nfont\n\n\"impact.ttf\"\n\nimg\n\nImage\n\nopen\n\nimage_file\n\nWe're using the Pillow library for image processing. This library is imported as PIL because it's a fork of an earlier, discontinued project of that name. This library has a wealth of image manipulation features, one of which is adding text to images.\n\nTo install Pillow, open pyproject.toml and add it to [tool.poetry.dependencies] as shown below:\n\n[tool.poetry.dependencies]\n\npython = \">=3.8.0,<3.9\"\n\nnumpy = \"^1.22.2\"\n\nreplit = \"^3.2.4\"\n\ndiscord = \"^1.7.3\"\n\npillow = \"^9.1.1\" # <-- new line\n\nStop and run your repl to update its dependencies and install the new package.", "start_char_idx": 3602, "end_char_idx": 7782, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "571bc3b5-a3b3-482a-af3d-fbeab3e15b53": {"__data__": {"id_": "571bc3b5-a3b3-482a-af3d-fbeab3e15b53", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "18499317ca7d0c84d45fe7b80678825a56d6c84ee615383264ba7418ac021038", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9c1989c8-39d0-40f2-ba6a-9ae79152803d", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "c4efc7b971ac14d48310d64009ea14ca58fc9951e98747b86c3f3b8408d4e7c5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0632787e-ed33-4a1d-9fe6-b8a70bb069d1", "node_type": "1", "metadata": {}, "hash": "3dfcc62109dcbd0cc1779ce2f7d0ac91807363016efe949ac7882241f9a2567f", "class_name": "RelatedNodeInfo"}}, "hash": "404b0ef3a36f2c2828726ed57d0d219c517cedee393cfbc53d493c9513920598", "text": "This library is imported as PIL because it's a fork of an earlier, discontinued project of that name. This library has a wealth of image manipulation features, one of which is adding text to images.\n\nTo install Pillow, open pyproject.toml and add it to [tool.poetry.dependencies] as shown below:\n\n[tool.poetry.dependencies]\n\npython = \">=3.8.0,<3.9\"\n\nnumpy = \"^1.22.2\"\n\nreplit = \"^3.2.4\"\n\ndiscord = \"^1.7.3\"\n\npillow = \"^9.1.1\" # <-- new line\n\nStop and run your repl to update its dependencies and install the new package. Normally we would let Replit do this for us, but later in this section, we're going to test caption.py without linking it to the Discord code in main.py, so Replit won't have a chance to detect and install our new package on its own.\n\nReturn to caption.py. Below our imports, we define the caption_image() function used in main.py. In addition to the image file and caption parameters, we'll add the ability to optionally specify a font, defaulting to Impact, a popular font for making memes. Download the font file now and upload it to your repl.\n\nWe start the caption_image() function by creating an Image object from the file provided as an argument. Next, we'll need to convert our Image into an ImageDraw so that we can add text to it. We'll do that with the following line of code, inserted below the definition of img:\n\ndraw\n\nImageDraw\n\nDraw\n\nimg\n\nNext, we need to load our font:\n\nfont_size\n\nint\n\nimg\n\nwidth\n\n16\n\nfont\n\nImageFont\n\ntruetype\n\n\"impact.ttf\"\n\nfont_size\n\nWe use ImageFont.truetype() to load a TrueType font from a file. We specify the font size in the second argument. Users will be able to upload different-sized images, so rather than hardcoding a specific font size, we've expressed the size in terms of the image's width, allowing it to scale appropriately. Feel free to experiment with this value.\n\nNow that we've got our image and font, we can start drawing. Extend your function as follows:\n\ncaption_w\n\ncaption_h\n\ndraw\n\ntextsize\n\ncaption\n\nfont\n\nfont\n\ndraw\n\ntext\n\nimg\n\nwidth\n\ncaption_w\n\nimg\n\nheight\n\ncaption_h\n\n# position\n\ncaption\n\n# text\n\n255\n\n255\n\n255\n\n# color\n\nfont\n\nfont\n\n# font\n\nstroke_width\n\n# text outline width\n\nstroke_fill\n\n# text outline color\n\nThe ImageDraw.textsize() method returns the height and width of a given string in a given font. We need this information to place our caption in the upper center of the image.\n\nThe ImageDraw.text() method actually draws our text. We provide it with our text and the necessary positioning and coloring information. To avoid situations where text blends in with the background, we make our text white with a black outline. Again, feel free to experiment with different colors, outlines and positions.\n\nOur work here is done, and all that remains is to return the image. But before we do that, let's test this code out on its own. Add the following line to the bottom of your function to save the image to a file:\n\nimg\n\nsave\n\n\"output.png\"\n\nFind an image you'd like to add a caption to. If you don't have one on hand, use this picture of a robot. Upload your chosen image to your repl.\n\nAt the bottom of caption.py, outside of the definition of caption_image(), add the following line:\n\ncaption_image\n\n\"replbot.png\"\n\n\"Hello world!\"\n\nChange the image file to your file's name and the caption to whatever you want. Then, in your repl's shell, type python caption.py and press Enter. A file named output.png should appear in your repl's file pane. Click on it to see the results of the code we've just written. Our version looks like this:\n\nReturning captioned images\u200b\n\nNow we'll tie everything together. Once you're happy with the text size and colors of your captions, delete the caption_image() function invocation from the bottom of caption.py and replace the line that reads img.save(\"output.png\") with the following:\n\nwith\n\nBytesIO\n\nas\n\nimg_bytes\n\nimg\n\nsave\n\nimg_bytes\n\nformat\n\nimg\n\nformat\n\ncontent\n\nimg_bytes\n\ngetvalue\n\nreturn\n\ncontent\n\nInstead of saving our image to a file, we save it to a binary stream object, much like we did when fetching the original image from Discord. We keep the image format the same as the original using Pillow's Image.format attribute.", "start_char_idx": 7262, "end_char_idx": 11427, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0632787e-ed33-4a1d-9fe6-b8a70bb069d1": {"__data__": {"id_": "0632787e-ed33-4a1d-9fe6-b8a70bb069d1", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "18499317ca7d0c84d45fe7b80678825a56d6c84ee615383264ba7418ac021038", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "571bc3b5-a3b3-482a-af3d-fbeab3e15b53", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "404b0ef3a36f2c2828726ed57d0d219c517cedee393cfbc53d493c9513920598", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b37aadea-1563-4b37-93b3-57604d75a1af", "node_type": "1", "metadata": {}, "hash": "3941e216f50293c7568d3acf8ee8f5ef2b8ea52a436e9ceba9fc7ed7a85399a1", "class_name": "RelatedNodeInfo"}}, "hash": "3dfcc62109dcbd0cc1779ce2f7d0ac91807363016efe949ac7882241f9a2567f", "text": "Then, in your repl's shell, type python caption.py and press Enter. A file named output.png should appear in your repl's file pane. Click on it to see the results of the code we've just written. Our version looks like this:\n\nReturning captioned images\u200b\n\nNow we'll tie everything together. Once you're happy with the text size and colors of your captions, delete the caption_image() function invocation from the bottom of caption.py and replace the line that reads img.save(\"output.png\") with the following:\n\nwith\n\nBytesIO\n\nas\n\nimg_bytes\n\nimg\n\nsave\n\nimg_bytes\n\nformat\n\nimg\n\nformat\n\ncontent\n\nimg_bytes\n\ngetvalue\n\nreturn\n\ncontent\n\nInstead of saving our image to a file, we save it to a binary stream object, much like we did when fetching the original image from Discord. We keep the image format the same as the original using Pillow's Image.format attribute. We then convert our BytesIO stream into a bytes object with .getvalue() and return it to the caller.\n\nOpen main.py and import caption_image() from caption.py with the following line near the top of the file, below your other imports:\n\nfrom\n\ncaption\n\nimport\n\ncaption_image\n\nReturn to the bottom of the caption() function definition. Add the following code below the definition of final_image:\n\n# Send reply\n\nawait\n\nctx\n\nmessage\n\nreply\n\nfile\n\ndiscord\n\nFile\n\nBytesIO\n\nfinal_image\n\nfilename\n\nf\"captioned-\n\nimage_filename\n\nThis code will reply to the user with a message containing the image we created above.\n\nStop and run your repl, and then switch to your Discord server. Enter a message such as !caption \"Hello world!\" and attach an image to it. You should receive a reply something like this:\n\nText wrapping\u200b\n\nOur bot works reasonably well for short captions, but anything longer than about five words goes off the edges of the image.\n\nWe can fix this by splitting caption text into multiple lines. We'll use Python's textwrap library to do this. Open caption.py and add the following line to the top of the file:\n\nimport\n\ntextwrap\n\nThen add the new line shown below to the caption_image() function.\n\nfont_size\n\nint\n\nimg\n\nwidth\n\n16\n\nfont\n\nImageFont\n\ntruetype\n\n\"impact.ttf\"\n\nfont_size\n\n# NEW LINE BELOW\n\ncaption\n\ntextwrap\n\nfill\n\ntext\n\ncaption\n\nwidth\n\nimg\n\nwidth\n\nfont_size\n\n# NEW LINE ABOVE\n\ncaption_w\n\ncaption_h\n\ndraw\n\ntextsize\n\ncaption\n\nfont\n\nfont\n\ndraw\n\ntext\n\nimg\n\nwidth\n\ncaption_w\n\nimg\n\nheight\n\ncaption_h\n\n# position\n\ncaption\n\n# text\n\n255\n\n255\n\n255\n\n# color\n\nfont\n\nfont\n\n# font\n\nstroke_width\n\n# text outline width\n\nstroke_fill\n\n# text outline color\n\nHere, textwrap.fill() will return a new version of our caption string with newline characters (\\n) inserted in appropriate places to ensure that each line of the text contains no more than width characters. It will do this without splitting words over multiple lines.\n\nWe use the following calculation to get width:\n\nimg.width / (font_size / 2)\n\nThis is the width of the image divided by half the font size. Most of the characters in the Impact font are taller than they are wide, so dividing the font size by two gives us reasonably good results for most text. It should also work for other fonts that aren't extremely wide. Try experimenting with different maximum line lengths.\n\nRerun your repl now and return to Discord to try out some different long captions.\n\nWhere next?\u200b\n\nOur image captioning bot is functional but quite rudimentary. If you'd like to continue working on it, here are some ideas you might want to try:\n\nMore font and text color options. You could implement these as additional bot commands.\n\nThe ability to add two captions to an image, on both the top and bottom.\n\nA different interface for your image captioning code, such as a Telegram bot or a simple website.\n\nPillow provides a number of filters that you could apply to images in addition to captioning them.\n\nIf you would like to make the text wrapping more robust for different fonts, you could try rewriting that part of caption.py. You might find this gist and this article helpful.\n\nDiscord bot code can be hosted on Replit permanently, but you'll need to use a Deployment repl to keep it running 24/7.\n\nYou can find our repl below:\n\n< Previous: Building a Discord bot with Python and Replit\n\nNext: Discord RPG bot with Python >\n\nWas this helpful?", "start_char_idx": 10570, "end_char_idx": 14812, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b37aadea-1563-4b37-93b3-57604d75a1af": {"__data__": {"id_": "b37aadea-1563-4b37-93b3-57604d75a1af", "embedding": null, "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6", "node_type": "4", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "18499317ca7d0c84d45fe7b80678825a56d6c84ee615383264ba7418ac021038", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0632787e-ed33-4a1d-9fe6-b8a70bb069d1", "node_type": "1", "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}, "hash": "3dfcc62109dcbd0cc1779ce2f7d0ac91807363016efe949ac7882241f9a2567f", "class_name": "RelatedNodeInfo"}}, "hash": "3941e216f50293c7568d3acf8ee8f5ef2b8ea52a436e9ceba9fc7ed7a85399a1", "text": "If you'd like to continue working on it, here are some ideas you might want to try:\n\nMore font and text color options. You could implement these as additional bot commands.\n\nThe ability to add two captions to an image, on both the top and bottom.\n\nA different interface for your image captioning code, such as a Telegram bot or a simple website.\n\nPillow provides a number of filters that you could apply to images in addition to captioning them.\n\nIf you would like to make the text wrapping more robust for different fonts, you could try rewriting that part of caption.py. You might find this gist and this article helpful.\n\nDiscord bot code can be hosted on Replit permanently, but you'll need to use a Deployment repl to keep it running 24/7.\n\nYou can find our repl below:\n\n< Previous: Building a Discord bot with Python and Replit\n\nNext: Discord RPG bot with Python >\n\nWas this helpful?\n\nLast updated on Nov 2, 2023\n\nGetting started\n\nCreating a Discord application\n\nWriting the Discord bot code\n\nReceiving user input\n\nCaptioning images\n\nReturning captioned images\n\nText wrapping\n\nWhere next?", "start_char_idx": 13923, "end_char_idx": 15017, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"95b61b52-aadf-44ea-bb71-afce88eb36e6": {"node_ids": ["d2c54d8e-affb-46f8-bd51-4dea81b30704", "9c1989c8-39d0-40f2-ba6a-9ae79152803d", "571bc3b5-a3b3-482a-af3d-fbeab3e15b53", "0632787e-ed33-4a1d-9fe6-b8a70bb069d1", "b37aadea-1563-4b37-93b3-57604d75a1af"], "metadata": {"path": "/home/runner/replit-docs-qa-with-llamaindex/docs.replit.com/tutorials/python/discord-meme-maker-bot.html"}}}, "docstore/metadata": {"d2c54d8e-affb-46f8-bd51-4dea81b30704": {"doc_hash": "fe0b0a3f935678e218996c2c544c68ef42e615c41fd245eac6f4d0d3977d09c4", "ref_doc_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6"}, "9c1989c8-39d0-40f2-ba6a-9ae79152803d": {"doc_hash": "c4efc7b971ac14d48310d64009ea14ca58fc9951e98747b86c3f3b8408d4e7c5", "ref_doc_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6"}, "571bc3b5-a3b3-482a-af3d-fbeab3e15b53": {"doc_hash": "404b0ef3a36f2c2828726ed57d0d219c517cedee393cfbc53d493c9513920598", "ref_doc_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6"}, "0632787e-ed33-4a1d-9fe6-b8a70bb069d1": {"doc_hash": "3dfcc62109dcbd0cc1779ce2f7d0ac91807363016efe949ac7882241f9a2567f", "ref_doc_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6"}, "b37aadea-1563-4b37-93b3-57604d75a1af": {"doc_hash": "3941e216f50293c7568d3acf8ee8f5ef2b8ea52a436e9ceba9fc7ed7a85399a1", "ref_doc_id": "95b61b52-aadf-44ea-bb71-afce88eb36e6"}}}